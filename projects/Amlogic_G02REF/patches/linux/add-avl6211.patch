diff -Nur linux-95ba9d626c0fce672caa296f5911ab9190881642/arch/arm/mach-meson6/include/mach/avosstyle_io.h linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/arch/arm/mach-meson6/include/mach/avosstyle_io.h
--- linux-95ba9d626c0fce672caa296f5911ab9190881642/arch/arm/mach-meson6/include/mach/avosstyle_io.h	2018-03-21 06:58:27.000000000 +0100
+++ linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/arch/arm/mach-meson6/include/mach/avosstyle_io.h	2018-12-29 13:24:40.384902003 +0100
@@ -12,6 +12,8 @@
 #ifndef __MACH_MESSON6_AVOSSTYL_IO_H
 #define __MACH_MESSON6_AVOSSTYL_IO_H
 
+#include <plat/io.h>
+
 #ifndef __ASSEMBLY__
 #define WRITE_REG(bus,reg, val) aml_write_reg32( bus##_REG_ADDR(reg),val)
 #define READ_REG(bus,reg) (aml_read_reg32(bus##_REG_ADDR(reg)))
diff -Nur linux-95ba9d626c0fce672caa296f5911ab9190881642/drivers/amlogic/amports/amports_config.h linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/drivers/amlogic/amports/amports_config.h
--- linux-95ba9d626c0fce672caa296f5911ab9190881642/drivers/amlogic/amports/amports_config.h	2018-03-21 06:58:27.000000000 +0100
+++ linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/drivers/amlogic/amports/amports_config.h	2018-12-29 14:25:45.818151559 +0100
@@ -14,11 +14,13 @@
 #define HAS_HEVC_VDEC 1
 #define HAS_HDEC      1
 
+#if 0
 #elif MESON_CPU_TYPE == MESON_CPU_TYPE_MESONG9BB
 #define HAS_VPU_PROT  0
 #define HAS_VDEC2     0
 #define HAS_HEVC_VDEC 1
 #define HAS_HDEC      1
+#endif
 
 #elif MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
 #define HAS_VPU_PROT  0
diff -Nur linux-95ba9d626c0fce672caa296f5911ab9190881642/drivers/amlogic/amports/esparser.c linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/drivers/amlogic/amports/esparser.c
--- linux-95ba9d626c0fce672caa296f5911ab9190881642/drivers/amlogic/amports/esparser.c	2018-03-21 06:58:27.000000000 +0100
+++ linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/drivers/amlogic/amports/esparser.c	2019-02-16 00:46:10.593678865 +0100
@@ -42,6 +42,8 @@
 #include "streambuf.h"
 #include "esparser.h"
 
+#include "tsdemux.h"
+
 #define SAVE_SCR 0
 
 #define ES_START_CODE_PATTERN 0x00000100
@@ -229,7 +231,7 @@
     return pts_checkin_offset(PTS_TYPE_AUDIO, audio_data_parsed, pts);
 }
 
-#ifdef CONFIG_AM_DVB
+#ifdef CONFIG_AVL6211
 extern int tsdemux_set_reset_flag(void);
 #endif
 
@@ -295,10 +297,11 @@
         WRITE_MPEG_REG(RESET1_REGISTER, RESET_PARSER);
 
         /* TS data path */
-#ifndef CONFIG_AM_DVB
+#ifndef CONFIG_AVL6211
         WRITE_MPEG_REG(FEC_INPUT_CONTROL, 0);
 #else
         tsdemux_set_reset_flag();
+	//tsdemux_reset();
 #endif
         CLEAR_MPEG_REG_MASK(TS_HIU_CTL, 1 << USE_HI_BSF_INTERFACE);
         CLEAR_MPEG_REG_MASK(TS_HIU_CTL_2, 1 << USE_HI_BSF_INTERFACE);
diff -Nur linux-95ba9d626c0fce672caa296f5911ab9190881642/drivers/amlogic/amports/Makefile linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/drivers/amlogic/amports/Makefile
--- linux-95ba9d626c0fce672caa296f5911ab9190881642/drivers/amlogic/amports/Makefile	2018-03-21 06:58:27.000000000 +0100
+++ linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/drivers/amlogic/amports/Makefile	2019-02-15 19:12:59.865875337 +0100
@@ -204,3 +204,7 @@
 ifneq ($(CONFIG_AM_DVB),)
 EXTRA_CFLAGS = -DENABLE_DEMUX_DRIVER -DMODIFY_TIMESTAMP_INC_WITH_PLL -DCALC_CACHED_TIME #-DUSE_VMASTER_MODE
 endif
+
+ifneq ($(CONFIG_AVL6211),)
+EXTRA_CFLAGS = -DENABLE_DEMUX_DRIVER -DMODIFY_TIMESTAMP_INC_WITH_PLL -DCALC_CACHED_TIME #-DUSE_VMASTER_MODE
+endif
diff -Nur linux-95ba9d626c0fce672caa296f5911ab9190881642/drivers/amlogic/dvb-avl/aml_dmx.c linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/drivers/amlogic/dvb-avl/aml_dmx.c
--- linux-95ba9d626c0fce672caa296f5911ab9190881642/drivers/amlogic/dvb-avl/aml_dmx.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/drivers/amlogic/dvb-avl/aml_dmx.c	2019-02-16 00:05:45.233015089 +0100
@@ -0,0 +1,4502 @@
+/*
+ * AMLOGIC demux driver.
+ */
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/wait.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/spinlock.h>
+#include <linux/fcntl.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <asm/cacheflush.h>
+#include <linux/dma-mapping.h>
+#ifdef ARC_700
+#include <asm/arch/am_regs.h>
+#else
+#include <mach/c_stb_define.h>
+#endif
+
+#define DMX_USE_SWFILTER    0x100
+
+#include <linux/pinctrl/pinmux.h>
+#include <mach/am_regs.h>
+
+#include "../amports/streambuf.h"
+//#include "aml_streambuf.h"
+#include "aml_dvb.h"
+//#include "aml_dvb_reg.h"
+
+#include <mach/io.h>
+#include <plat/io.h>
+
+#include <linux/vmalloc.h>
+
+#define ENABLE_SEC_BUFF_WATCHDOG
+#define USE_AHB_MODE
+
+#define DEBUG
+#define INPUT_TIME_OUT 12
+#define TS_OUT_CLK_INVERT 16
+
+#define COMM_DESC_2_CTL     (STB_CBUS_BASE + 0xff) /*0x16ff*/
+
+#define TRANSPORT_SCRAMBLING_CONTROL_ODD_2 24
+
+/* bit[31:0] channel_record_enable*/
+#define DEMUX_CHAN_RECORD_EN    \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x4a)         /* 0x164a*/
+#define DEMUX_CHAN_RECORD_EN_2  \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x4a)         /* 0x169a*/
+#define DEMUX_CHAN_RECORD_EN_3  \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x4a)         /* 0x16ea*/
+
+/* bit[31:0] channel_process_enable*/
+#define DEMUX_CHAN_PROCESS_EN   \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x4b)         /* 0x164b*/
+#define DEMUX_CHAN_PROCESS_EN_2 \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x4b)         /* 0x169b*/
+#define DEMUX_CHAN_PROCESS_EN_3 \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x4b)         /* 0x16eb*/
+
+/* bit[31:0] - channel_reset_timeout_disable*/
+#define DEMUX_INPUT_TIMEOUT_C   \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x46)         /* 0x1646*/
+#define DEMUX_INPUT_TIMEOUT_C_2 \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x46)         /* 0x1696*/
+#define DEMUX_INPUT_TIMEOUT_C_3 \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x46)         /* 0x16e6*/
+	
+/* bit[31] - no_match_reset_timeout_disable*/
+/* bit[30:0] input_time_out_int_cnt (0 -- means disable) Wr-setting, Rd-count*/
+#define DEMUX_INPUT_TIMEOUT     \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x47)         /* 0x1647*/
+#define DEMUX_INPUT_TIMEOUT_2   \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x47)         /* 0x1697*/
+#define DEMUX_INPUT_TIMEOUT_3   \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x47)         /* 0x16e7*/
+
+#define DEMUX_SMALL_SEC_CTL     \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x4c)         /* 0x164c*/
+#define DEMUX_SMALL_SEC_CTL_2   \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x4c)         /* 0x169c*/
+#define DEMUX_SMALL_SEC_CTL_3   \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x4c)         /* 0x16ec*/
+/* bit[31:0] small_sec_start_addr*/
+#define DEMUX_SMALL_SEC_ADDR    \
+	(STB_CBUS_BASE + DEMUX_1_OFFSET + 0x4d)         /* 0x164d*/
+#define DEMUX_SMALL_SEC_ADDR_2  \
+	(STB_CBUS_BASE + DEMUX_2_OFFSET + 0x4d)         /* 0x169d*/
+#define DEMUX_SMALL_SEC_ADDR_3  \
+	(STB_CBUS_BASE + DEMUX_3_OFFSET + 0x4d)         /* 0x16ed*/
+
+
+#define pr_dbg_flag(_f, fmt, _args...)\
+	do {\
+		if (debug_dmx&(_f))\
+			printk("DMX: %s: "fmt, __func__, ## _args);\
+	} while (0)
+#define pr_dbg_irq_flag(_f, fmt, _args...)\
+	do {\
+		if (debug_irq&(_f))\
+			printk("DMX: %s: "fmt, __func__, ## _args);\
+	} while (0)
+#define pr_dbg(fmt, args...)	pr_dbg_flag(0x1, fmt, ## args)
+#define pr_dbg_sf(fmt, args...) pr_dbg_flag(0x4, fmt, ## args)
+#define pr_dbg_ss(fmt, args...) pr_dbg_flag(0x8, fmt, ## args)
+#define pr_dbg_irq(fmt, args...)pr_dbg_irq_flag(0x1, fmt, ## args)
+#define pr_dbg_irq_dvr(fmt, args...)pr_dbg_irq_flag(0x2, fmt, ## args)
+#define pr_dbg_irq_sf(fmt, args...) pr_dbg_irq_flag(0x4, fmt, ## args)
+#define pr_dbg_irq_ss(fmt, args...) pr_dbg_irq_flag(0x8, fmt, ## args)
+#define pr_dbg_irq_pes(args...) pr_dbg_irq_flag(0x10, args)
+
+
+#define pr_error(fmt, args...) printk("DMX: " fmt, ## args)
+#define pr_inf(fmt, args...)  printk("DMX: " fmt, ## args)
+
+#define dump(b, l) \
+	do { \
+		int i; \
+		printk("dump: "); \
+		for (i = 0; i < (l); i++) {\
+			if (!(i&0xf)) \
+				printk("\n\t"); \
+			printk("%02x ", *(((unsigned char *)(b))+i)); \
+		} \
+		printk("\n"); \
+	} while (0)
+
+MODULE_PARM_DESC(debug_dmx, "\n\t\t Enable demux debug information");
+static int debug_dmx=0;
+module_param(debug_dmx, int, 0644);
+
+MODULE_PARM_DESC(debug_irq, "\n\t\t Enable demux IRQ debug information");
+static int debug_irq=0;
+module_param(debug_irq, int, 0644);
+
+static int npids = CHANNEL_COUNT;
+#define MOD_PARAM_DECLARE_CHANPIDS(_dmx) \
+MODULE_PARM_DESC(debug_dmx##_dmx##_chanpids, "\n\t\t pids of dmx channels"); \
+static short debug_dmx##_dmx##_chanpids[CHANNEL_COUNT] = \
+					{[0 ... (CHANNEL_COUNT - 1)] = -1}; \
+module_param_array(debug_dmx##_dmx##_chanpids, short, &npids, 0444)
+
+MOD_PARAM_DECLARE_CHANPIDS(0);
+MOD_PARAM_DECLARE_CHANPIDS(1);
+MOD_PARAM_DECLARE_CHANPIDS(2);
+
+#define set_debug_dmx_chanpids(_dmx, _idx, _pid)\
+	do { \
+		if ((_dmx) == 0) \
+			debug_dmx0_chanpids[(_idx)] = (_pid); \
+		else if ((_dmx) == 1) \
+			debug_dmx1_chanpids[(_idx)] = (_pid); \
+		else if ((_dmx) == 2) \
+			debug_dmx2_chanpids[(_idx)] = (_pid); \
+	} while (0)
+
+MODULE_PARM_DESC(debug_sf_user, "\n\t\t only for sf mode check");
+static int debug_sf_user=0;
+module_param(debug_sf_user, int, 0644);
+
+MODULE_PARM_DESC(force_sec_sf, "\n\t\t force sf mode for sec filter");
+static int force_sec_sf;
+module_param(force_sec_sf, int, 0644);
+
+MODULE_PARM_DESC(force_pes_sf, "\n\t\t force sf mode for pes filter");
+static int force_pes_sf;
+module_param(force_pes_sf, int, 0644);
+
+#define DMX_READ_REG(i, r)\
+	((i)?((i == 1)?READ_MPEG_REG(r##_2) :\
+	READ_MPEG_REG(r##_3)) : READ_MPEG_REG(r))
+
+#define DMX_WRITE_REG(i, r, d)\
+	do {\
+		if (i == 1) {\
+			WRITE_MPEG_REG(r##_2, d);\
+		} else if (i == 2) {\
+			WRITE_MPEG_REG(r##_3, d);\
+		} \
+		else {\
+			WRITE_MPEG_REG(r, d);\
+		} \
+	} while (0)
+
+#define READ_PERI_REG			READ_CBUS_REG
+#define WRITE_PERI_REG			WRITE_CBUS_REG
+
+#define READ_ASYNC_FIFO_REG(i, r)\
+	((i) ? READ_PERI_REG(ASYNC_FIFO2_##r) : READ_PERI_REG(ASYNC_FIFO_##r))
+
+#define WRITE_ASYNC_FIFO_REG(i, r, d)\
+	do {\
+		if (i == 1) {\
+			WRITE_PERI_REG(ASYNC_FIFO2_##r, d);\
+		} else {\
+			WRITE_PERI_REG(ASYNC_FIFO_##r, d);\
+		} \
+	} while (0)
+
+#define CLEAR_ASYNC_FIFO_REG_MASK(i, reg, mask) \
+	WRITE_ASYNC_FIFO_REG(i, reg, \
+	(READ_ASYNC_FIFO_REG(i, reg)&(~(mask))))
+
+#define DVR_FEED(f) \
+	((f) && ((f)->type == DMX_TYPE_TS) &&	\
+	(((f)->ts_type & (TS_PACKET | TS_DEMUX)) == TS_PACKET))
+
+#define MOD_PARAM_DECLARE_CHANREC(_dmx) \
+MODULE_PARM_DESC(dmx##_dmx##_chanrec_enable, \
+	       "\n\t\t record by channel, one time use in the beginning"); \
+static int dmx##_dmx##_chanrec_enable; \
+module_param(dmx##_dmx##_chanrec_enable, int, 0644); \
+MODULE_PARM_DESC(dmx##_dmx##_chanrec, "\n\t\t record channels bits"); \
+static int dmx##_dmx##_chanrec; \
+module_param(dmx##_dmx##_chanrec, int, 0644)
+
+MOD_PARAM_DECLARE_CHANREC(0);
+MOD_PARAM_DECLARE_CHANREC(1);
+MOD_PARAM_DECLARE_CHANREC(2);
+
+#define MOD_PARAM_DECLARE_CHANPROC(_dmx) \
+MODULE_PARM_DESC(dmx##_dmx##_chanproc_enable, "channel further processing"); \
+static int dmx##_dmx##_chanproc_enable; \
+module_param(dmx##_dmx##_chanproc_enable, int, 0644); \
+MODULE_PARM_DESC(dmx##_dmx##_chanproc, "further process channels bits"); \
+static int dmx##_dmx##_chanproc; \
+module_param(dmx##_dmx##_chanproc, int, 0644)
+
+MOD_PARAM_DECLARE_CHANPROC(0);
+MOD_PARAM_DECLARE_CHANPROC(1);
+MOD_PARAM_DECLARE_CHANPROC(2);
+
+#define DMX_CH_OP_CHANREC  0
+#define DMX_CH_OP_CHANPROC 1
+
+static inline int _setbit(int v, int b) { return v|(1<<b); }
+static inline int _clrbit(int v, int b) { return v&~(1<<b); }
+static inline int _set(int v, int b) { return b; }
+static void dmxn_op_chan(int dmx, int ch, int(*op)(int, int), int ch_op)
+{
+	int enable_0, enable_1, enable_2;
+	int *set_0, *set_1, *set_2;
+	int reg;
+
+	if (ch_op == DMX_CH_OP_CHANREC) {
+		enable_0 = dmx0_chanrec_enable;
+		enable_1 = dmx1_chanrec_enable;
+		enable_2 = dmx2_chanrec_enable;
+		set_0 = &dmx0_chanrec;
+		set_1 = &dmx1_chanrec;
+		set_2 = &dmx2_chanrec;
+		reg = DEMUX_CHAN_RECORD_EN;
+	} else if (ch_op == DMX_CH_OP_CHANPROC) {
+		enable_0 = dmx0_chanproc_enable;
+		enable_1 = dmx1_chanproc_enable;
+		enable_2 = dmx2_chanproc_enable;
+		set_0 = &dmx0_chanproc;
+		set_1 = &dmx1_chanproc;
+		set_2 = &dmx2_chanproc;
+		reg = DEMUX_CHAN_PROCESS_EN;
+	} else {
+		return;
+	}
+	if (dmx == 0) {
+		if (enable_0) {
+			*set_0 = op(*set_0, ch);
+			WRITE_MPEG_REG(reg+DEMUX_1_OFFSET, *set_0);
+		}
+	} else if (dmx == 1) {
+		if (enable_1) {
+			*set_1 = op(*set_1, ch);
+			WRITE_MPEG_REG(reg+DEMUX_2_OFFSET, *set_1);
+		}
+	} else if (dmx == 2) {
+		if (enable_2) {
+			*set_2 = op(*set_2, ch);
+			WRITE_MPEG_REG(reg+DEMUX_3_OFFSET, *set_2);
+		}
+	}
+}
+#define dmx_add_recchan(_dmx, _chid) \
+	do { \
+		pr_dbg("dmx[%d]_add_recchan[%d]\n", _dmx, _chid); \
+		dmxn_op_chan(_dmx, _chid, _setbit, DMX_CH_OP_CHANREC); \
+	} while (0)
+#define dmx_rm_recchan(_dmx, _chid) \
+	do { \
+		pr_dbg("dmx[%d]_rm_recchan[%ld]\n", _dmx, _chid); \
+		dmxn_op_chan(_dmx, _chid, _clrbit, DMX_CH_OP_CHANREC); \
+	} while (0)
+
+#define SYS_CHAN_COUNT    (4)
+#define SEC_GRP_LEN_0     (0xc)
+#define SEC_GRP_LEN_1     (0xc)
+#define SEC_GRP_LEN_2     (0xc)
+#define SEC_GRP_LEN_3     (0xc)
+#define LARGE_SEC_BUFF_MASK  0xFFFFFFFF
+#define LARGE_SEC_BUFF_COUNT 32
+#define WATCHDOG_TIMER    250
+#define ASYNCFIFO_PACKETS 2048
+#define ASYNCFIFO_BUFFER_SIZE_DEFAULT (188 * ASYNCFIFO_PACKETS)
+
+#define DEMUX_INT_MASK\
+			((0<<(AUDIO_SPLICING_POINT))    |\
+			(0<<(VIDEO_SPLICING_POINT))     |\
+			(0<<(OTHER_PES_READY))          |\
+			(1<<(SUB_PES_READY))            |\
+			(1<<(SECTION_BUFFER_READY))     |\
+			(0<<(OM_CMD_READ_PENDING))      |\
+			(1<<(TS_ERROR_PIN))             |\
+			(1<<(NEW_PDTS_READY))           |\
+			(0<<(DUPLICATED_PACKET))        |\
+			(0<<(DIS_CONTINUITY_PACKET)))
+
+#define TS_SRC_MAX 3
+
+/*Reset the demux device*/
+#define RESET_DEMUX2      (1<<15)
+#define RESET_DEMUX1      (1<<14)
+#define RESET_DEMUX0      (1<<13)
+#define RESET_S2P1        (1<<12)
+#define RESET_S2P0        (1<<11)
+#define RESET_DES         (1<<10)
+#define RESET_TOP         (1<<9)
+
+static int dmx_remove_feed(struct aml_dmx *dmx, struct dvb_demux_feed *feed);
+static void reset_async_fifos(struct aml_dvb *dvb);
+static int dmx_add_feed(struct aml_dmx *dmx, struct dvb_demux_feed *feed);
+static int dmx_smallsec_set(struct aml_smallsec *ss, int enable, int bufsize,
+				int force);
+static int dmx_timeout_set(struct aml_dmxtimeout *dto, int enable,
+				int timeout, int ch_dis, int nomatch,
+				int force);
+
+/*Audio & Video PTS value*/
+static u32 video_pts;
+static u32 audio_pts;
+static u32 first_video_pts;
+static u32 first_audio_pts;
+static int demux_skipbyte;
+static int tsfile_clkdiv = 4;
+
+#define SF_DMX_ID 2
+#define SF_AFIFO_ID 1
+
+#define sf_dmx_sf(_dmx) \
+	(((_dmx)->id == SF_DMX_ID) \
+	&& ((struct aml_dvb *)(_dmx)->demux.priv)->swfilter.user)
+#define sf_afifo_sf(_afifo) \
+	(((_afifo)->id == SF_AFIFO_ID) && (_afifo)->dvb->swfilter.user)
+#define dmx_get_dev(dmx) (((struct aml_dvb *)((dmx)->demux.priv))->dev)
+#define asyncfifo_get_dev(afifo) ((afifo)->dvb->dev)
+
+/*Section buffer watchdog*/
+static void section_buffer_watchdog_func(unsigned long arg)
+{
+	struct aml_dvb *dvb = (struct aml_dvb *)arg;
+	struct aml_dmx *dmx;
+	u32 section_busy32 = 0, om_cmd_status32 = 0,
+	    demux_channel_activity32 = 0;
+	u16 demux_int_status1 = 0;
+	u32 device_no = 0;
+	u32 filter_number = 0;
+	u32 i = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	for (device_no = 0; device_no < DMX_DEV_COUNT; device_no++) {
+
+		dmx = &dvb->dmx[device_no];
+
+		if (dvb->dmx_watchdog_disable[device_no])
+			continue;
+
+		if (!dmx->init)
+			continue;
+
+		om_cmd_status32 =
+		    DMX_READ_REG(device_no, OM_CMD_STATUS);
+		demux_channel_activity32 =
+		    DMX_READ_REG(device_no, DEMUX_CHANNEL_ACTIVITY);
+		section_busy32 =
+			DMX_READ_REG(device_no, SEC_BUFF_BUSY);
+
+		if (om_cmd_status32 & 0x8fc2) {
+			/* bit 15:12 -- om_cmd_count */
+			/* bit  11:9 -- overflow_count */
+			/* bit   8:6 -- om_overwrite_count */
+			/* bit     1 -- om_cmd_overflow */
+			/*BUG: If the recoder is running, return */
+			if (dmx->record)
+				goto end;
+			/*Reset the demux */
+			pr_dbg("reset the demux\n"
+			"%04x\t%03x\t%03x\t%03x\t%01x\t%01x\t"
+			"%x\t%x\tdmx%d:status:0x%x\n",
+			(om_cmd_status32 >> 12) & 0xf,
+			(om_cmd_status32 >> 9) & 0x7,
+			(om_cmd_status32 >> 6) & 0x7,
+			(om_cmd_status32 >> 3) & 0x7,
+			(om_cmd_status32 >> 2) & 0x1,
+			(om_cmd_status32 >> 1) & 0x1,
+			demux_channel_activity32, section_busy32,
+			dmx->id, om_cmd_status32);
+
+			dmx_reset_dmx_hw_ex_unlock(dvb, dmx, 0);
+			goto end;
+		}
+		section_busy32 =
+			DMX_READ_REG(device_no, SEC_BUFF_BUSY);
+		if (LARGE_SEC_BUFF_MASK ==
+				(section_busy32 & LARGE_SEC_BUFF_MASK)) {
+			/*All the largest section buffers occupied,
+			 * clear buffers */
+			DMX_WRITE_REG(device_no,
+					SEC_BUFF_READY, section_busy32);
+		} else {
+			for (i = 0; i < SEC_BUF_COUNT; i++) {
+				if (!(section_busy32 & (1 << i)))
+					continue;
+				DMX_WRITE_REG(device_no, SEC_BUFF_NUMBER, i);
+				filter_number =	DMX_READ_REG(device_no,
+							SEC_BUFF_NUMBER);
+				filter_number >>= 8;
+				if ((filter_number >= FILTER_COUNT)
+					/* >=31, do not handle this case */
+					|| ((filter_number < FILTER_COUNT)
+					&& dmx->filter[filter_number].used))
+					section_busy32 &= ~(1 << i);
+			}
+			if (section_busy32 & (dmx->smallsec.enable ?
+						0x7FFFFFFF :
+						LARGE_SEC_BUFF_MASK)) {
+				/*Clear invalid buffers */
+				DMX_WRITE_REG(device_no,
+						SEC_BUFF_READY,
+						section_busy32);
+				pr_error("clear invalid buffer 0x%x\n",
+						section_busy32);
+			}
+		}
+		demux_int_status1 =
+			DMX_READ_REG(device_no, STB_INT_STATUS) & 0xfff7;
+		if (demux_int_status1 & (1 << TS_ERROR_PIN)) {
+			DMX_WRITE_REG(device_no,
+				STB_INT_STATUS,
+				(1 << TS_ERROR_PIN));
+		}
+	}
+
+end:
+	spin_unlock_irqrestore(&dvb->slock, flags);
+#ifdef ENABLE_SEC_BUFF_WATCHDOG
+	mod_timer(&dvb->watchdog_timer,
+		  jiffies + msecs_to_jiffies(WATCHDOG_TIMER));
+#endif
+	return;
+}
+
+static inline int sec_filter_match(struct aml_dmx *dmx, struct aml_filter *f,
+				   u8 *p)
+{
+	int b;
+	u8 neq = 0;
+
+	if (!f->used || !dmx->channel[f->chan_id].used)
+		return 0;
+
+	for (b = 0; b < FILTER_LEN; b++) {
+		u8 xor = p[b] ^ f->value[b];
+
+		if (xor & f->maskandmode[b])
+			return 0;
+
+		if (xor & f->maskandnotmode[b])
+			neq = 1;
+	}
+
+	if (f->neq && !neq)
+		return 0;
+
+	return 1;
+}
+
+static int section_crc(struct aml_dmx *dmx, struct aml_filter *f, u8 *p)
+{
+	int sec_len = (((p[1] & 0xF) << 8) | p[2]) + 3;
+	struct dvb_demux_feed *feed = dmx->channel[f->chan_id].feed;
+	struct aml_dvb *dvb = (struct aml_dvb *)dmx->demux.priv;
+
+	if (feed->feed.sec.check_crc) {
+		struct dvb_demux *demux = feed->demux;
+		struct dmx_section_feed *sec = &feed->feed.sec;
+		int section_syntax_indicator;
+
+		section_syntax_indicator = ((p[1] & 0x80) != 0);
+		sec->seclen = sec_len;
+		sec->crc_val = ~0;
+		if (demux->check_crc32(feed, p, sec_len)) {
+			pr_error("section CRC check failed!\n");
+			dmx_reset_dmx_hw_ex_unlock(dvb, dmx, 0);
+			return 0;
+		}
+	}
+
+	return 1;
+}
+
+static void section_notify(struct aml_dmx *dmx, struct aml_filter *f, u8 *p)
+{
+	int sec_len = (((p[1] & 0xF) << 8) | p[2]) + 3;
+	struct dvb_demux_feed *feed = dmx->channel[f->chan_id].feed;
+
+	if (feed && feed->cb.sec)
+		feed->cb.sec(p, sec_len, NULL, 0, f->filter, DMX_OK);
+}
+
+static void hardware_match_section(struct aml_dmx *dmx,
+						u16 sec_num, u16 buf_num)
+{
+	u8 *p = (u8 *) dmx->sec_buf[buf_num].addr;
+	struct aml_filter *f;
+	int chid, i;
+	int need_crc = 1;
+
+	if (sec_num >= FILTER_COUNT) {
+		pr_dbg("sec_num invalid: %d\n", sec_num);
+		return;
+	}
+
+	dma_sync_single_for_cpu(dmx_get_dev(dmx),
+				dmx->sec_pages_map + (buf_num << 0x0c),
+				(1 << 0x0c), DMA_FROM_DEVICE);
+
+	f = &dmx->filter[sec_num];
+	chid = f->chan_id;
+
+	for (i = 0; i < FILTER_COUNT; i++) {
+		f = &dmx->filter[i];
+		if (f->chan_id != chid)
+			continue;
+		if (sec_filter_match(dmx, f, p)) {
+			if (need_crc) {
+				if (!section_crc(dmx, f, p))
+					return;
+				need_crc = 0;
+			}
+
+			section_notify(dmx, f, p);
+		}
+	}
+}
+
+static void software_match_section(struct aml_dmx *dmx, u16 buf_num)
+{
+	u8 *p = (u8 *) dmx->sec_buf[buf_num].addr;
+	struct aml_filter *f, *fmatch = NULL;
+	int i, fid = -1;
+
+	dma_sync_single_for_cpu(dmx_get_dev(dmx),
+				dmx->sec_pages_map + (buf_num << 0x0c),
+				(1 << 0x0c), DMA_FROM_DEVICE);
+
+	for (i = 0; i < FILTER_COUNT; i++) {
+		f = &dmx->filter[i];
+
+		if (sec_filter_match(dmx, f, p)) {
+			pr_dbg("[software match]filter %d match, pid %d\n",
+			       i, dmx->channel[f->chan_id].pid);
+			if (!fmatch) {
+				fmatch = f;
+				fid = i;
+			} else {
+				pr_dbg("software match]Muli-filter match this\n"
+					"section, will skip this section\n");
+				return;
+			}
+		}
+	}
+
+	if (fmatch) {
+		pr_dbg("[software match]dispatch\n"
+			"section to filter %d pid %d\n",
+			fid, dmx->channel[fmatch->chan_id].pid);
+		if (section_crc(dmx, fmatch, p))
+			section_notify(dmx, fmatch, p);
+	} else {
+		pr_dbg("[software match]this section do not\n"
+			"match any filter!!!\n");
+	}
+}
+
+
+static int _rbuf_write(struct dvb_ringbuffer *buf, const u8 *src, size_t len)
+{
+	ssize_t free;
+
+	if (!len)
+		return 0;
+	if (!buf->data)
+		return 0;
+
+	free = dvb_ringbuffer_free(buf);
+	if (len > free) {
+		pr_error("sf: buffer overflow\n");
+		return -EOVERFLOW;
+	}
+
+	return dvb_ringbuffer_write(buf, src, len);
+}
+
+static int _rbuf_filter_pkts(struct dvb_ringbuffer *rb,
+			u8 *wrapbuf,
+			void (*swfilter_packets)(struct dvb_demux *demux,
+						const u8 *buf,
+						size_t count),
+			struct dvb_demux *demux)
+{
+	ssize_t len1 = 0;
+	ssize_t len2 = 0;
+	size_t off;
+	size_t count;
+	size_t size;
+
+	if (debug_irq & 0x4)
+		dump(&rb->data[rb->pread], (debug_irq & 0xFFF00) >> 8);
+
+	/*
+	   rb|====--------===[0x47]====|
+	   ^             ^
+	   wr            rd
+	 */
+
+	len1 = rb->pwrite - rb->pread;
+	if (len1 < 0) {
+		len1 = rb->size - rb->pread;
+		len2 = rb->pwrite;
+	}
+
+	for (off = 0; off < len1; off++) {
+		if (rb->data[rb->pread + off] == 0x47)
+			break;
+	}
+
+	if (off)
+		pr_dbg_irq_sf("off ->|%zd\n", off);
+
+	len1 -= off;
+	rb->pread = (rb->pread + off) % rb->size;
+
+	count = len1 / 188;
+	if (count) {
+		pr_dbg_irq_sf("pkt >> 1[%zd<->%zd]\n", rb->pread, rb->pwrite);
+		swfilter_packets(demux, rb->data + rb->pread, count);
+
+		size = count * 188;
+		len1 -= size;
+		rb->pread += size;
+	}
+
+	if (len2 && len1 && ((len1 + len2) > 188)) {
+		pr_dbg_irq_sf("pkt >> 2[%zd<->%zd]\n", rb->pread, rb->pwrite);
+		size = 188 - len1;
+		memcpy(wrapbuf, rb->data + rb->pread, len1);
+		memcpy(wrapbuf + len1, rb->data, size);
+		swfilter_packets(demux, wrapbuf, 1);
+		rb->pread = size;
+		len2 -= size;
+	}
+
+	if (len2) {
+		pr_dbg_irq_sf("pkt >> 3[%zd<->%zd]\n", rb->pread, rb->pwrite);
+		count = len2 / 188;
+		if (count) {
+			swfilter_packets(demux, rb->data + rb->pread, count);
+			rb->pread += count * 188;
+		}
+	}
+	return 0;
+}
+
+static void smallsection_match_section(struct aml_dmx *dmx, u8 *p, u16 sec_num)
+{
+	struct aml_filter *f;
+	int chid, i;
+	int need_crc = 1;
+
+	if (sec_num >= FILTER_COUNT) {
+		pr_dbg("sec_num invalid: %d\n", sec_num);
+		return;
+	}
+
+	f = &dmx->filter[sec_num];
+	chid = f->chan_id;
+
+	for (i = 0; i < FILTER_COUNT; i++) {
+		f = &dmx->filter[i];
+		if (f->chan_id != chid)
+			continue;
+		if (sec_filter_match(dmx, f, p)) {
+			if (need_crc) {
+				if (!section_crc(dmx, f, p))
+					return;
+				need_crc = 0;
+			}
+
+			section_notify(dmx, f, p);
+		}
+	}
+
+}
+static void process_smallsection(struct aml_dmx *dmx)
+{
+
+	u32 v, wr, rd;
+	u32 data32;
+	struct aml_smallsec *ss = &dmx->smallsec;
+
+	v = DMX_READ_REG(dmx->id, DEMUX_SMALL_SEC_CTL);
+	wr = (v >> 8) & 0xff;
+	rd = (v >> 16) & 0xff;
+
+	if (rd != wr) {
+		int n1 = wr - rd,
+		    n2 = 0,
+		    max = (ss->bufsize>>8);
+		int i;
+		u8 *p;
+		int sec_len;
+
+		pr_dbg_irq_ss("secbuf[31] ctrl:0x%x\n", v);
+
+		if (n1 < 0) {
+			n1 = max - rd;
+			n2 = wr;
+		}
+		if (n1) {
+			pr_dbg_irq_ss("n1:%d\n", n1);
+			dma_sync_single_for_cpu(dmx_get_dev(dmx),
+						ss->buf_map+(rd<<8),
+						n1<<8,
+						DMA_FROM_DEVICE);
+			for (i = 0; i < n1; i++) {
+				p = (u8 *)ss->buf+((rd+i)<<8);
+				sec_len = (((p[1] & 0xF) << 8) | p[2]) + 3;
+				smallsection_match_section(dmx, p,
+							*(p+sec_len+1));
+			}
+		}
+		if (n2) {
+			pr_dbg_irq_ss("n2:%d\n", n2);
+			dma_sync_single_for_cpu(dmx_get_dev(dmx),
+						ss->buf_map,
+						n2<<8,
+						DMA_FROM_DEVICE);
+			for (i = 0; i < n2; i++) {
+				p = (u8 *)ss->buf+(i<<8);
+				sec_len = (((p[1] & 0xF) << 8) | p[2]) + 3;
+				smallsection_match_section(dmx, p,
+							*(p+sec_len+1));
+			}
+		}
+
+		rd = wr;
+		data32 = (DMX_READ_REG(dmx->id,	DEMUX_SMALL_SEC_CTL)
+				& 0xff00ffff)
+				| (rd << 16);
+		DMX_WRITE_REG(dmx->id, DEMUX_SMALL_SEC_CTL, data32);
+	}
+}
+
+
+static void process_section(struct aml_dmx *dmx)
+{
+	u32 ready, i, sec_busy;
+	u16 sec_num;
+
+	ready = DMX_READ_REG(dmx->id, SEC_BUFF_READY);
+	if (ready) {
+	pr_dbg("section ready:%08x\n",ready);
+
+		if ((ready & (1<<31)) && dmx->smallsec.enable) {
+			u32 v, wr, rd;
+			v = DMX_READ_REG(dmx->id, DEMUX_SMALL_SEC_CTL);
+			wr = (v >> 8) & 0xff;
+			rd = (v >> 16) & 0xff;
+			if ((wr < rd) && (5 > (rd - wr)))
+				pr_error("warning: small ss buf [w%dr%d]\n",
+					wr, rd);
+			pr_dbg_irq_ss("ss>%x\n",
+				DMX_READ_REG(dmx->id, DEMUX_SMALL_SEC_CTL));
+			process_smallsection(dmx);
+			/*tasklet_hi_schedule(&dmx->dmx_tasklet);*/
+			/*tasklet_schedule(&dmx->dmx_tasklet);*/
+			DMX_WRITE_REG(dmx->id, SEC_BUFF_READY, (1<<31));
+			return;
+		}
+
+		for (i = 0; i < SEC_BUF_COUNT; i++) {
+
+			if (!(ready & (1 << i)))
+				continue;
+
+			/* get section busy */
+			sec_busy = DMX_READ_REG(dmx->id, SEC_BUFF_BUSY);
+			/* get filter number */
+			DMX_WRITE_REG(dmx->id, SEC_BUFF_NUMBER, i);
+			sec_num = (DMX_READ_REG(dmx->id, SEC_BUFF_NUMBER) >> 8);
+	pr_dbg("%d. sec_busy:%08x sec_num:%d\n", i, sec_busy, sec_num); 
+
+			/*
+			 * sec_buf_watchdog_count dispatch:
+			 * byte0 -- always busy=0 's watchdog count
+			 * byte1 -- always busy=1 & filter_num=31 's
+			 * watchdog count
+			 */
+
+			/* sec_busy is not set, check busy=0 watchdog count */
+			if (!(sec_busy & (1 << i))) {
+				/* clear other wd count	of this buffer */
+				dmx->sec_buf_watchdog_count[i] &= 0x000000ff;
+				dmx->sec_buf_watchdog_count[i] += 0x1;
+				pr_dbg("bit%d ready=1, busy=0,\n"
+					"sec_num=%d for %d times\n",
+					i, sec_num,
+					dmx->sec_buf_watchdog_count[i]);
+				if (dmx->sec_buf_watchdog_count[i] >= 5) {
+					pr_dbg("busy=0 reach the max count,\n"
+						"try software match.\n");
+					software_match_section(dmx, i);
+					dmx->sec_buf_watchdog_count[i] = 0;
+					DMX_WRITE_REG(dmx->id, SEC_BUFF_READY,
+							(1 << i));
+				}
+				continue;
+			}
+
+			/* filter_num == 31 && busy == 1,check watchdog count */
+			if (sec_num >= FILTER_COUNT) {
+				/* clear other wd count	of this buffer */
+				dmx->sec_buf_watchdog_count[i] &= 0x0000ff00;
+				dmx->sec_buf_watchdog_count[i] += 0x100;
+				pr_dbg("bit%d ready=1,busy=1,\n"
+					"sec_num=%d for %d times\n",
+					i, sec_num,
+					dmx->sec_buf_watchdog_count[i] >> 8);
+				if (dmx->sec_buf_watchdog_count[i] >= 0x500) {
+					pr_dbg("busy=1&filter_num=31\n"
+					" reach the max count, clear\n"
+					" the buf ready & busy!\n");
+					software_match_section(dmx, i);
+					dmx->sec_buf_watchdog_count[i] = 0;
+					DMX_WRITE_REG(dmx->id,
+						      SEC_BUFF_READY,
+						      (1 << i));
+					DMX_WRITE_REG(dmx->id,
+						      SEC_BUFF_BUSY,
+						      (1 << i));
+				}
+				continue;
+			}
+
+			/* now, ready & busy are both set and
+			 filter number is valid */
+			if (dmx->sec_buf_watchdog_count[i] != 0)
+				dmx->sec_buf_watchdog_count[i] = 0;
+
+			/* process this section */
+			hardware_match_section(dmx, sec_num, i);
+
+			/* clear the ready & busy bit */
+			DMX_WRITE_REG(dmx->id, SEC_BUFF_READY, (1 << i));
+			DMX_WRITE_REG(dmx->id, SEC_BUFF_BUSY, (1 << i));
+		}
+	}
+}
+
+
+static void process_sub(struct aml_dmx *dmx)
+{
+
+	u32 rd_ptr = 0;
+
+	u32 wr_ptr = READ_MPEG_REG(PARSER_SUB_WP);
+	u32 start_ptr = READ_MPEG_REG(PARSER_SUB_START_PTR);
+	u32 end_ptr = READ_MPEG_REG(PARSER_SUB_END_PTR);
+
+	u32 buffer1 = 0, buffer2 = 0;
+	unsigned char *buffer1_virt = 0, *buffer2_virt = 0;
+	u32 len1 = 0, len2 = 0;
+
+	rd_ptr = READ_MPEG_REG(PARSER_SUB_RP);
+	if (!rd_ptr)
+		return;
+	if (rd_ptr > wr_ptr) {
+		len1 = end_ptr - rd_ptr + 8;
+		buffer1 = rd_ptr;
+
+		len2 = wr_ptr - start_ptr;
+		buffer2 = start_ptr;
+
+		rd_ptr = start_ptr + len2;
+	} else if (rd_ptr < wr_ptr) {
+		len1 = wr_ptr - rd_ptr;
+		buffer1 = rd_ptr;
+		rd_ptr += len1;
+		len2 = 0;
+	} else if (rd_ptr == wr_ptr) {
+		pr_dbg("sub no data\n");
+	}
+
+	if (buffer1)
+		buffer1_virt = phys_to_virt(buffer1);
+	if (buffer2)
+		buffer2_virt = phys_to_virt(buffer2);
+
+	if (len1)
+		dma_sync_single_for_cpu(dmx_get_dev(dmx),
+					(dma_addr_t) buffer1, len1,
+					DMA_FROM_DEVICE);
+	if (len2)
+		dma_sync_single_for_cpu(dmx_get_dev(dmx),
+					(dma_addr_t) buffer2, len2,
+					DMA_FROM_DEVICE);
+
+	if (dmx->channel[2].used) {
+		if (dmx->channel[2].feed && dmx->channel[2].feed->cb.ts) {
+			dmx->channel[2].feed->cb.ts(buffer1_virt, len1,
+						buffer2_virt, len2,
+						&dmx->channel[2].feed->feed.ts, DMX_OK);
+		}
+	}
+	WRITE_MPEG_REG(PARSER_SUB_RP, rd_ptr);
+}
+
+
+static void process_pes(struct aml_dmx *dmx)
+{
+	static long off, off_pre;
+	u8 *buffer1 = 0, *buffer2 = 0;
+	u8 *buffer1_phys = 0, *buffer2_phys = 0;
+	u32 len1 = 0, len2 = 0;
+	int i = 1;
+	off = (DMX_READ_REG(dmx->id, OB_PES_WR_PTR) << 3);
+
+	pr_dbg_irq_pes("[%d]WR:0x%x PES WR:0x%x\n", dmx->id,
+			DMX_READ_REG(dmx->id, OTHER_WR_PTR),
+			DMX_READ_REG(dmx->id, OB_PES_WR_PTR));
+	buffer1 = (u8 *)(dmx->pes_pages + off_pre);
+	pr_dbg_irq_pes("[%d]PES WR[%02x %02x %02x %02x %02x %02x %02x %02x",
+		dmx->id,
+		buffer1[0], buffer1[1], buffer1[2], buffer1[3],
+		buffer1[4], buffer1[5], buffer1[6], buffer1[7]);
+	pr_dbg_irq_pes(" %02x %02x %02x %02x %02x %02x %02x %02x]\n",
+			buffer1[8], buffer1[9], buffer1[10], buffer1[11],
+			buffer1[12], buffer1[13], buffer1[14], buffer1[15]);
+
+	if (off > off_pre) {
+		len1 = off-off_pre;
+		buffer1 = (unsigned char *)(dmx->pes_pages + off_pre);
+	} else if (off < off_pre) {
+		len1 = dmx->pes_buf_len-off_pre;
+		buffer1 = (unsigned char *)(dmx->pes_pages + off_pre);
+		len2 = off;
+		buffer2 = (unsigned char *)dmx->pes_pages;
+	} else if (off == off_pre) {
+		pr_dbg("pes no data\n");
+	}
+	off_pre = off;
+	if (len1) {
+		buffer1_phys = (unsigned char *)virt_to_phys(buffer1);
+		dma_sync_single_for_cpu(dmx_get_dev(dmx),
+			(dma_addr_t)buffer1_phys, len1, DMA_FROM_DEVICE);
+	}
+	if (len2) {
+		buffer2_phys = (unsigned char *)virt_to_phys(buffer2);
+		dma_sync_single_for_cpu(dmx_get_dev(dmx),
+			(dma_addr_t)buffer2_phys, len2, DMA_FROM_DEVICE);
+	}
+	if (len1 || len2) {
+		struct aml_channel *ch;
+		for (i = 0; i < CHANNEL_COUNT; i++) {
+			ch = &dmx->channel[i];
+			if (ch->used && ch->feed
+				&& (ch->feed->type == DMX_TYPE_TS)) {
+				if (ch->feed->ts_type & TS_PAYLOAD_ONLY) {
+					ch->feed->cb.ts(buffer1,
+						len1, buffer2, len2,
+						&ch->feed->feed.ts,
+						DMX_OK);
+				}
+			}
+		}
+	}
+}
+
+static void process_om_read(struct aml_dmx *dmx)
+{
+	unsigned i;
+	unsigned short om_cmd_status_data_0 = 0;
+	unsigned short om_cmd_status_data_1 = 0;
+/*      unsigned short om_cmd_status_data_2 = 0;*/
+	unsigned short om_cmd_data_out = 0;
+
+	om_cmd_status_data_0 = DMX_READ_REG(dmx->id, OM_CMD_STATUS);
+	om_cmd_status_data_1 = DMX_READ_REG(dmx->id, OM_CMD_DATA);
+/*      om_cmd_status_data_2 = DMX_READ_REG(dmx->id, OM_CMD_DATA2);*/
+
+	if (om_cmd_status_data_0 & 1) {
+		DMX_WRITE_REG(dmx->id, OM_DATA_RD_ADDR,
+			(1 << 15) | ((om_cmd_status_data_1 & 0xff) << 2));
+		for (i = 0; i < (((om_cmd_status_data_1 >> 7) & 0x1fc) >> 1);
+		     i++) {
+			om_cmd_data_out = DMX_READ_REG(dmx->id, OM_DATA_RD);
+		}
+
+		om_cmd_data_out = DMX_READ_REG(dmx->id, OM_DATA_RD_ADDR);
+		DMX_WRITE_REG(dmx->id, OM_DATA_RD_ADDR, 0);
+		DMX_WRITE_REG(dmx->id, OM_CMD_STATUS, 1);
+	}
+}
+
+static void dmx_irq_bh_handler(unsigned long arg)
+{
+	struct aml_dmx *dmx = (struct aml_dmx *)arg;
+	pr_dbg_irq("demux %d irq dmx:%p\n", dmx->id, dmx);
+	process_smallsection(dmx);
+	return;
+}
+
+static irqreturn_t dmx_irq_handler(int irq_number, void *para)
+{
+	struct aml_dmx *dmx = (struct aml_dmx *)para;
+	struct aml_dvb *dvb = aml_get_dvb_device();
+	u32 status, pdts_status;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	status = DMX_READ_REG(dmx->id, STB_INT_STATUS);
+	if (!status)
+		goto irq_handled;
+
+	pr_dbg_irq("demux %d irq:%d status: 0x%08x\n", dmx->id, irq_number, status);
+
+	if (status & (1 << SECTION_BUFFER_READY)) {
+		process_section(dmx);
+	}
+	if (status & (1 << TS_ERROR_PACKAGE)) {
+	DMX_WRITE_REG(dmx->id, STB_INT_STATUS, status);
+		goto irq_handled;
+	}
+	if (status & (1 << SUB_PES_READY)) {
+		/*If the subtitle is set by tsdemux,
+		do not parser in demux driver. */
+		if (dmx->sub_chan == -1)
+			process_sub(dmx);
+	}
+	if (status & (1 << OTHER_PES_READY))  {
+		process_pes(dmx);
+	}
+	if (status & (1 << OM_CMD_READ_PENDING))
+		process_om_read(dmx);
+	if (status & (1 << DUPLICATED_PACKET)) {
+	}
+	if (status & (1 << DIS_CONTINUITY_PACKET)) {
+	}
+	if (status & (1 << VIDEO_SPLICING_POINT)) {
+	}
+	if (status & (1 << AUDIO_SPLICING_POINT)) {
+	}
+	if (status & (1 << TS_ERROR_PIN)) {
+		pr_error("TS_ERROR_PIN\n");
+	}
+	if (status & (1 << NEW_PDTS_READY)) {
+		pdts_status = DMX_READ_REG(dmx->id, STB_PTS_DTS_STATUS);
+
+		if (pdts_status & (1 << VIDEO_PTS_READY)) {
+			video_pts = DMX_READ_REG(dmx->id, VIDEO_PTS_DEMUX);
+			if (!first_video_pts
+			    || 0 > (int)(video_pts - first_video_pts))
+				first_video_pts = video_pts;
+		}
+
+		if (pdts_status & (1 << AUDIO_PTS_READY)) {
+			audio_pts = DMX_READ_REG(dmx->id, AUDIO_PTS_DEMUX);
+			if (!first_audio_pts
+			    || 0 > (int)(audio_pts - first_audio_pts))
+				first_audio_pts = audio_pts;
+		}
+	}
+
+	if (dmx->irq_handler)
+		dmx->irq_handler(dmx->dmx_irq, (void *)(long)dmx->id);
+
+	DMX_WRITE_REG(dmx->id, STB_INT_STATUS, status);
+
+	/*tasklet_schedule(&dmx->dmx_tasklet);*/
+
+	{
+		if (!dmx->int_check_time) {
+			dmx->int_check_time = jiffies;
+			dmx->int_check_count = 0;
+		}
+
+		if (jiffies_to_msecs(jiffies - dmx->int_check_time) >= 100
+		    || dmx->int_check_count > 1000) {
+			if (dmx->int_check_count > 1000) {
+				struct aml_dvb *dvb =
+				    (struct aml_dvb *)dmx->demux.priv;
+				pr_error("Too many interrupts "
+					"(%d interrupts in %d ms)!\n",
+					dmx->int_check_count,
+					jiffies_to_msecs(jiffies -
+						      dmx->int_check_time));
+				if (dmx->fe && !dmx->in_tune) {
+					DMX_WRITE_REG(dmx->id, STB_INT_MASK, 0);
+/*					dvb_frontend_resume(dmx->fe);
+					printk(">>> dvb_frontend_retune <<<\n"); */
+				}
+				dmx_reset_hw_ex(dvb, 0);
+			}
+			dmx->int_check_time = 0;
+		}
+
+		dmx->int_check_count++;
+
+		if (dmx->in_tune) {
+			dmx->error_check++;
+			if (dmx->error_check > 200)
+				DMX_WRITE_REG(dmx->id, STB_INT_MASK, 0);
+		}
+	}
+
+irq_handled:
+	spin_unlock_irqrestore(&dvb->slock, flags);
+	return IRQ_HANDLED;
+}
+
+static inline int dmx_get_order(unsigned long size)
+{
+	int order;
+
+	order = -1;
+	do {
+		size >>= 1;
+		order++;
+	} while (size);
+
+	return order;
+}
+
+static void dvr_process_channel(struct aml_asyncfifo *afifo,
+				struct aml_channel *channel,
+				u32 total, u32 size,
+				struct aml_swfilter *sf)
+{
+	int cnt;
+	int ret = 0;
+	pr_dbg_irq_dvr("buf_read:%d buf_toggle:%d\n", afifo->buf_read, afifo->buf_toggle);
+
+	if (afifo->buf_read > afifo->buf_toggle) {
+		cnt = total - afifo->buf_read;
+		dma_sync_single_for_cpu(asyncfifo_get_dev(afifo),
+				afifo->pages_map+afifo->buf_read*size,
+				cnt*size,
+				DMA_FROM_DEVICE);
+		pr_dbg_irq_dvr("DMA_sync_single_for_cpu cnt:%d size:%d\n", cnt, size);
+		if (sf)
+			ret = _rbuf_write(&sf->rbuf,
+					(u8 *)afifo->pages+afifo->buf_read*size,
+					cnt*size);
+		else
+			channel->dvr_feed->cb.ts(
+					(u8 *)afifo->pages+afifo->buf_read*size,
+					cnt*size, NULL, 0,
+					&channel->dvr_feed->feed.ts, DMX_OK);
+		afifo->buf_read = 0;
+	}
+
+	if (afifo->buf_toggle > afifo->buf_read) {
+		cnt = afifo->buf_toggle - afifo->buf_read;
+		dma_sync_single_for_cpu(asyncfifo_get_dev(afifo),
+				afifo->pages_map+afifo->buf_read*size,
+				cnt*size,
+				DMA_FROM_DEVICE);
+		pr_dbg_irq_dvr("dma_sync_single_for_cpu cnt:%d size:%d\n", cnt, size);
+		if (sf) {
+			if (ret >= 0)
+				ret = _rbuf_write(&sf->rbuf,
+					(u8 *)afifo->pages+afifo->buf_read*size,
+					cnt*size);
+		} else
+			channel->dvr_feed->cb.ts(
+					(u8 *)afifo->pages+afifo->buf_read*size,
+					cnt*size, NULL, 0,
+					&channel->dvr_feed->feed.ts, DMX_OK);
+		afifo->buf_read = afifo->buf_toggle;
+	}
+
+	if (sf && ret > 0) {
+		_rbuf_filter_pkts(&sf->rbuf, sf->wrapbuf,
+				dvb_dmx_swfilter_packets,
+				channel->dvr_feed->demux);
+	} else if (sf && ret <= 0)
+		pr_error("sf rbuf write error[%d]\n", ret);
+	else
+		pr_dbg_irq_dvr("write data to dvr\n");
+}
+
+static void dvr_irq_bh_handler(unsigned long arg)
+{
+	struct aml_asyncfifo *afifo = (struct aml_asyncfifo *)arg;
+	struct aml_dvb *dvb = afifo->dvb;
+	struct aml_dmx *dmx;
+	u32 size, total;
+	int i, factor;
+	unsigned long flags;
+
+	pr_dbg_irq_dvr("async fifo %d irq:%d, %d source:%d\n", afifo->id, afifo->asyncfifo_irq, afifo->buf_toggle, afifo->source);
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	if (dvb && afifo->source >= AM_DMX_0 && afifo->source < AM_DMX_MAX) {
+		dmx = &dvb->dmx[afifo->source];
+		if (dmx->init && dmx->record) {
+			struct aml_swfilter *sf = &dvb->swfilter;
+			int issf = 0;
+
+			total = afifo->buf_len / afifo->flush_size;
+			factor = dmx_get_order(total);
+			size = afifo->buf_len >> factor;
+
+			if (sf->user && (sf->afifo == afifo))
+				issf = 1;
+
+			for (i = 0; i < CHANNEL_COUNT; i++) {
+				if (dmx->channel[i].used && dmx->channel[i].dvr_feed) {
+					dvr_process_channel(afifo,
+							&dmx->channel[i],
+							total,
+							size,
+							issf?sf:NULL);
+				    break;
+				}
+			}
+
+		}
+	}
+	spin_unlock_irqrestore(&dvb->slock, flags);
+	return;
+}
+
+static irqreturn_t dvr_irq_handler(int irq_number, void *para)
+{
+	struct aml_asyncfifo *afifo = (struct aml_asyncfifo *)para;
+	int factor = dmx_get_order(afifo->buf_len / afifo->flush_size);
+
+	afifo->buf_toggle++;
+	afifo->buf_toggle %= (1 << factor);
+	tasklet_schedule(&afifo->asyncfifo_tasklet);
+	return IRQ_HANDLED;
+}
+
+/*Enable the STB*/
+static void stb_enable(struct aml_dvb *dvb)
+{
+	int out_src, des_in = 0, en_des = 0, fec_clk, hiu, dec_clk_en = 0;
+	int src, tso_src, i;
+	u32 fec_s0, fec_s1;
+	u32 invert0, invert1;
+
+	u32 data;
+	switch (dvb->stb_source) {
+	case AM_TS_SRC_DMX0:
+		src = dvb->dmx[0].source;
+		break;
+	case AM_TS_SRC_DMX1:
+		src = dvb->dmx[1].source;
+		break;
+	case AM_TS_SRC_DMX2:
+		src = dvb->dmx[2].source;
+		break;
+	default:
+		src = dvb->stb_source;
+		break;
+	}
+
+	switch (src) {
+	case AM_TS_SRC_TS0:
+		fec_clk = tsfile_clkdiv;
+		hiu = 0;
+		break;
+	case AM_TS_SRC_TS1:
+		fec_clk = tsfile_clkdiv;
+		hiu = 0;
+		break;
+	case AM_TS_SRC_TS2:
+		fec_clk = tsfile_clkdiv;
+		hiu = 0;
+		break;
+	case AM_TS_SRC_S_TS0:
+		fec_clk = tsfile_clkdiv;
+		hiu = 0;
+		break;
+	case AM_TS_SRC_S_TS1:
+		fec_clk = tsfile_clkdiv;
+		hiu = 0;
+		break;
+	case AM_TS_SRC_S_TS2:
+		fec_clk = tsfile_clkdiv;
+		hiu = 0;
+		break;
+	case AM_TS_SRC_HIU:
+		fec_clk = tsfile_clkdiv;
+		hiu = 1;
+		break;
+	default:
+		fec_clk = 0;
+		hiu = 0;
+		break;
+	}
+
+	switch (dvb->tso_source) {
+	case AM_TS_SRC_DMX0:
+		tso_src = dvb->dmx[0].source;
+		break;
+	case AM_TS_SRC_DMX1:
+		tso_src = dvb->dmx[1].source;
+		break;
+	case AM_TS_SRC_DMX2:
+		tso_src = dvb->dmx[2].source;
+		break;
+	default:
+		tso_src = dvb->tso_source;
+		break;
+	}
+
+	switch (tso_src) {
+	case AM_TS_SRC_TS0:
+		out_src = 0;
+		break;
+	case AM_TS_SRC_TS1:
+		out_src = 1;
+		break;
+	case AM_TS_SRC_TS2:
+		out_src = 2;
+		break;
+	case AM_TS_SRC_S_TS0:
+		out_src = 6;
+		break;
+	case AM_TS_SRC_S_TS1:
+	case AM_TS_SRC_S_TS2:
+		out_src = 5;
+		break;
+	case AM_TS_SRC_HIU:
+		out_src = 7;
+		break;
+	default:
+		out_src = 0;
+		break;
+	}
+
+	pr_dbg("[stb]src:%d tso:%d out_src:%d\n", src, tso_src, out_src);
+
+	fec_s0 = 0;
+	fec_s1 = 0;
+	invert0 = 0;
+	invert1 = 0;
+
+	for (i = 0; i < TS_IN_COUNT; i++) {
+		if (dvb->ts[i].s2p_id == 0)
+			fec_s0 = i;
+		else if (dvb->ts[i].s2p_id == 1)
+			fec_s1 = i;
+	}
+
+	invert0 = dvb->s2p[0].invert;
+	invert1 = dvb->s2p[1].invert;
+	pr_dbg("fec_s0:%d, invert0:%d fec_s1:%d invert1:%d en_des:%d\n", fec_s0, invert0, fec_s1, invert1, en_des);
+
+	WRITE_MPEG_REG(STB_TOP_CONFIG,
+		       (invert1 << INVERT_S2P1_FEC_CLK) |
+		       (fec_s1 << S2P1_FEC_SERIAL_SEL) |
+		       (out_src << TS_OUTPUT_SOURCE) |
+		       (des_in << DES_INPUT_SEL) |
+		       (en_des << ENABLE_DES_PL) |
+		       (dec_clk_en << ENABLE_DES_PL_CLK) |
+		       (invert0 << INVERT_S2P0_FEC_CLK) |
+		       (fec_s0 << S2P0_FEC_SERIAL_SEL));
+
+	if (dvb->reset_flag)
+		hiu = 0;
+	/* invert ts out clk,add ci model need add this
+	if (dvb->ts_out_invert) {
+		printk("ts out invert ---\r\n");
+		data = READ_MPEG_REG(TS_TOP_CONFIG);
+		data |= 1 << TS_OUT_CLK_INVERT;
+		WRITE_MPEG_REG(TS_TOP_CONFIG, data);
+	}
+	invert ts out clk  end */
+	WRITE_MPEG_REG(TS_FILE_CONFIG,
+		       (demux_skipbyte << 16) |
+		       (6 << DES_OUT_DLY) |
+		       (3 << TRANSPORT_SCRAMBLING_CONTROL_ODD) |
+		       (3 << TRANSPORT_SCRAMBLING_CONTROL_ODD_2) |
+		       (hiu << TS_HIU_ENABLE) | (fec_clk << FEC_FILE_CLK_DIV));
+}
+
+int dsc_set_pid(struct aml_dsc *ch, int pid)
+{
+	struct aml_dsc *dsc = ch;
+	int is_dsc2 = (dsc->id == 1) ? 1 : 0;
+	u32 data;
+
+	WRITE_MPEG_REG(TS_PL_PID_INDEX,
+			((ch->id & 0x0f) >> 1)+(is_dsc2 ? 4 : 0));
+	data = READ_MPEG_REG(TS_PL_PID_DATA);
+	if (ch->id & 1) {
+		data &= 0xFFFF0000;
+		data |= pid & 0x1fff;
+		if (!ch->used)
+			data |= 1 << PID_MATCH_DISABLE_LOW;
+	} else {
+		data &= 0xFFFF;
+		data |= (pid & 0x1fff) << 16;
+		if (!ch->used)
+			data |= 1 << PID_MATCH_DISABLE_HIGH;
+	}
+	WRITE_MPEG_REG(TS_PL_PID_INDEX,
+			((ch->id & 0x0f) >> 1)+(is_dsc2 ? 4 : 0));
+	WRITE_MPEG_REG(TS_PL_PID_DATA, data);
+	WRITE_MPEG_REG(TS_PL_PID_INDEX, 0);
+
+	if (ch->used)
+		pr_dbg("set DSC %d ch %d PID %d\n", dsc->id, ch->id, pid);
+	else
+		pr_dbg("disable DSC %d ch %d\n", dsc->id, ch->id);
+	return 0;
+}
+
+int dsc_set_key(struct aml_dsc *ch, int type, u8 *key)
+{
+	struct aml_dsc *dsc = ch;
+	int is_dsc2 = (dsc->id == 1) ? 1 : 0;
+	u16 k0, k1, k2, k3;
+	u32 key0, key1;
+
+	k0 = (key[0] << 8) | key[1];
+	k1 = (key[2] << 8) | key[3];
+	k2 = (key[4] << 8) | key[5];
+	k3 = (key[6] << 8) | key[7];
+
+	key0 = (k0 << 16) | k1;
+	key1 = (k2 << 16) | k3;
+	WRITE_MPEG_REG(COMM_DESC_KEY0, key0);
+	WRITE_MPEG_REG(COMM_DESC_KEY1, key1);
+	WRITE_MPEG_REG(COMM_DESC_KEY_RW,
+			(ch->id + type * DSC_COUNT)+(is_dsc2 ? 16 : 0));
+
+	pr_dbg("set DSC %d ch %d type %d key %04x %04x %04x %04x\n",
+		dsc->id, ch->id, type, k0, k1, k2, k3);
+	return 0;
+}
+
+int dsc_enable(struct aml_dsc *dsc, int enable)
+{
+	if (dsc->id == 0) {
+		WRITE_MPEG_REG(STB_TOP_CONFIG,
+			READ_MPEG_REG(STB_TOP_CONFIG) &
+				~((0x11 << DES_INPUT_SEL)|
+				(1 << ENABLE_DES_PL)|
+				(1 << ENABLE_DES_PL_CLK)));
+	} else if (dsc->id == 1) {
+		WRITE_MPEG_REG(COMM_DESC_2_CTL,	0);
+	}
+	return 0;
+}
+
+/*Set section buffer*/
+static int dmx_alloc_sec_buffer(struct aml_dmx *dmx)
+{
+	unsigned long base;
+	unsigned long grp_addr[SEC_BUF_GRP_COUNT];
+	int grp_len[SEC_BUF_GRP_COUNT];
+	int i;
+
+	if (dmx->sec_pages)
+		return 0;
+
+	grp_len[0] = (1 << SEC_GRP_LEN_0) * 8;
+	grp_len[1] = (1 << SEC_GRP_LEN_1) * 8;
+	grp_len[2] = (1 << SEC_GRP_LEN_2) * 8;
+	grp_len[3] = (1 << SEC_GRP_LEN_3) * 8;
+
+	dmx->sec_total_len = grp_len[0] + grp_len[1] + grp_len[2] + grp_len[3];
+	dmx->sec_pages =
+	    __get_free_pages(GFP_KERNEL, get_order(dmx->sec_total_len));
+	if (!dmx->sec_pages) {
+		pr_error("cannot allocate section buffer %d bytes %d order\n",
+			 dmx->sec_total_len, get_order(dmx->sec_total_len));
+		return -1;
+	}
+	dmx->sec_pages_map =
+	    dma_map_single(dmx_get_dev(dmx), (void *)dmx->sec_pages,
+					 dmx->sec_total_len, DMA_FROM_DEVICE);
+
+	grp_addr[0] = dmx->sec_pages_map;
+
+	grp_addr[1] = grp_addr[0] + grp_len[0];
+	grp_addr[2] = grp_addr[1] + grp_len[1];
+	grp_addr[3] = grp_addr[2] + grp_len[2];
+
+	dmx->sec_buf[0].addr = dmx->sec_pages;
+	dmx->sec_buf[0].len = grp_len[0] / 8;
+
+	for (i = 1; i < SEC_BUF_COUNT; i++) {
+		dmx->sec_buf[i].addr =
+		    dmx->sec_buf[i - 1].addr + dmx->sec_buf[i - 1].len;
+		dmx->sec_buf[i].len = grp_len[i / 8] / 8;
+	}
+
+	base = grp_addr[0] & 0xFFFF0000;
+	DMX_WRITE_REG(dmx->id, SEC_BUFF_BASE, base >> 16);
+	DMX_WRITE_REG(dmx->id, SEC_BUFF_01_START,
+		      (((grp_addr[0] - base) >> 8) << 16) |
+		       ((grp_addr[1] - base) >> 8));
+	DMX_WRITE_REG(dmx->id, SEC_BUFF_23_START,
+		      (((grp_addr[2] - base) >> 8) << 16) |
+		       ((grp_addr[3] - base) >> 8));
+	DMX_WRITE_REG(dmx->id, SEC_BUFF_SIZE,
+			SEC_GRP_LEN_0 |
+			(SEC_GRP_LEN_1 << 4) |
+			(SEC_GRP_LEN_2 << 8) |
+			(SEC_GRP_LEN_3 << 12));
+
+	return 0;
+}
+
+/*Set subtitle buffer*/
+static int dmx_alloc_sub_buffer(struct aml_dmx *dmx)
+{
+	unsigned long addr;
+
+	if (dmx->sub_pages)
+		return 0;
+
+	dmx->sub_buf_len = 64 * 1024;
+	dmx->sub_pages =
+	    __get_free_pages(GFP_KERNEL, get_order(dmx->sub_buf_len));
+	if (!dmx->sub_pages) {
+		pr_error("cannot allocate subtitle buffer\n");
+		return -1;
+	}
+	dmx->sub_pages_map =
+	    dma_map_single(dmx_get_dev(dmx), (void *)dmx->sub_pages,
+					dmx->sub_buf_len, DMA_FROM_DEVICE);
+
+	addr = virt_to_phys((void *)dmx->sub_pages);
+	DMX_WRITE_REG(dmx->id, SB_START, addr >> 12);
+	DMX_WRITE_REG(dmx->id, SB_LAST_ADDR, (dmx->sub_buf_len >> 3) - 1);
+	return 0;
+}
+
+/*Set PES buffer*/
+static int dmx_alloc_pes_buffer(struct aml_dmx *dmx)
+{
+	unsigned long addr;
+
+	if (dmx->pes_pages)
+		return 0;
+
+	dmx->pes_buf_len = 64 * 1024;
+	dmx->pes_pages =
+	    __get_free_pages(GFP_KERNEL, get_order(dmx->pes_buf_len));
+	if (!dmx->pes_pages) {
+		pr_error("cannot allocate pes buffer\n");
+		return -1;
+	}
+	dmx->pes_pages_map =
+	    dma_map_single(dmx_get_dev(dmx), (void *)dmx->pes_pages,
+					dmx->pes_buf_len, DMA_FROM_DEVICE);
+
+	addr = virt_to_phys((void *)dmx->pes_pages);
+	DMX_WRITE_REG(dmx->id, OB_START, addr >> 12);
+	DMX_WRITE_REG(dmx->id, OB_LAST_ADDR, (dmx->pes_buf_len >> 3) - 1);
+	return 0;
+}
+int dsc_release(struct aml_dsc *dsc)
+{
+	return 0;
+}
+
+/*Allocate ASYNC FIFO Buffer*/
+static unsigned long asyncfifo_alloc_buffer(int len)
+{
+	unsigned long pages = __get_free_pages(GFP_KERNEL, get_order(len));
+	if (!pages) {
+		pr_error("cannot allocate async fifo buffer\n");
+		return 0;
+	}
+	return pages;
+}
+static void asyncfifo_free_buffer(unsigned long buf, int len)
+{
+	free_pages(buf, get_order(len));
+}
+
+static int asyncfifo_set_buffer(struct aml_asyncfifo *afifo,
+					int len, unsigned long buf)
+{
+	if (afifo->pages)
+		return -1;
+
+	afifo->buf_toggle = 0;
+	afifo->buf_read   = 0;
+	afifo->buf_len = len;
+
+	if (afifo->flush_size <= 0)
+		afifo->flush_size = afifo->buf_len>>1;
+
+	pr_dbg("async fifo %d buf size %d, flush size %d\n",
+			afifo->id, afifo->buf_len, afifo->flush_size);
+
+	afifo->pages = buf;
+	if (!afifo->pages)
+		return -1;
+
+	afifo->pages_map = dma_map_single(asyncfifo_get_dev(afifo),
+			(void *)afifo->pages, afifo->buf_len, DMA_FROM_DEVICE);
+
+	return 0;
+}
+static void asyncfifo_put_buffer(struct aml_asyncfifo *afifo)
+{
+	if (afifo->pages) {
+		dma_unmap_single(asyncfifo_get_dev(afifo),
+			afifo->pages_map, afifo->buf_len, DMA_FROM_DEVICE);
+		asyncfifo_free_buffer(afifo->pages, afifo->buf_len);
+		afifo->pages_map = 0;
+		afifo->pages = 0;
+	}
+}
+
+int async_fifo_init(struct aml_asyncfifo *afifo, int initirq,
+			int buf_len, unsigned long buf)
+{
+	pr_dbg("%s\n",__func__);
+	       
+	int ret = 0;
+	int irq;
+
+	if (afifo->init)
+		return -1;
+
+	afifo->source  = AM_DMX_MAX;
+	afifo->pages = 0;
+	afifo->buf_toggle = 0;
+	afifo->buf_read = 0;
+	afifo->buf_len = 0;
+
+	if (afifo->asyncfifo_irq == -1) {
+		pr_error("no irq for ASYNC_FIFO%d\n", afifo->id);
+		/*Do not return error*/
+		return -1;
+	}
+
+	tasklet_init(&afifo->asyncfifo_tasklet,
+			dvr_irq_bh_handler, (unsigned long)afifo);
+	if (initirq)
+		irq = request_irq(afifo->asyncfifo_irq,	dvr_irq_handler,
+				IRQF_SHARED|IRQF_TRIGGER_RISING,
+				"dvr irq", afifo);
+	else
+		enable_irq(afifo->asyncfifo_irq);
+
+	/*alloc buffer*/
+	ret = asyncfifo_set_buffer(afifo, buf_len, buf);
+
+	afifo->init = 1;
+
+	return ret;
+}
+
+int async_fifo_deinit(struct aml_asyncfifo *afifo, int freeirq)
+{
+	pr_dbg("%s\n",__func__);
+	
+	if (!afifo->init)
+		return 0;
+
+	CLEAR_ASYNC_FIFO_REG_MASK(afifo->id, REG1, 1 << ASYNC_FIFO_FLUSH_EN);
+	CLEAR_ASYNC_FIFO_REG_MASK(afifo->id, REG2, 1 << ASYNC_FIFO_FILL_EN);
+
+	asyncfifo_put_buffer(afifo);
+
+	afifo->source  = AM_DMX_MAX;
+	afifo->buf_toggle = 0;
+	afifo->buf_read = 0;
+	afifo->buf_len = 0;
+
+	if (afifo->asyncfifo_irq != -1) {
+		if (freeirq)
+			free_irq(afifo->asyncfifo_irq, afifo);
+		else
+			disable_irq(afifo->asyncfifo_irq);
+	}
+	tasklet_kill(&afifo->asyncfifo_tasklet);
+
+	afifo->init = 0;
+
+	return 0;
+}
+
+static int _dmx_smallsec_enable(struct aml_smallsec *ss, int bufsize)
+{
+	if (!ss->buf) {
+
+		ss->buf = __get_free_pages(GFP_KERNEL,
+					get_order(bufsize));
+		if (!ss->buf) {
+			pr_error("cannot allocate smallsec buffer\n"
+				"%d bytes %d order\n",
+				 bufsize, get_order(bufsize));
+			return -1;
+		}
+		ss->buf_map = dma_map_single(dmx_get_dev(ss->dmx),
+						(void *)ss->buf,
+						 bufsize, DMA_FROM_DEVICE);
+	}
+
+	DMX_WRITE_REG(ss->dmx->id, DEMUX_SMALL_SEC_ADDR,
+				ss->buf_map);
+	DMX_WRITE_REG(ss->dmx->id, DEMUX_SMALL_SEC_CTL,
+				((((bufsize>>8)-1)&0xff)<<24) |
+				(1<<1) |/*enable reset the wr ptr*/
+				(1<<0));
+
+	ss->bufsize = bufsize;
+	ss->enable = 1;
+
+	pr_inf("demux%d smallsec buf start: %lx, size: %d\n",
+		ss->dmx->id, ss->buf, ss->bufsize);
+	return 0;
+}
+
+static int _dmx_smallsec_disable(struct aml_smallsec *ss)
+{
+	DMX_WRITE_REG(ss->dmx->id, DEMUX_SMALL_SEC_CTL, 0);
+	if (ss->buf) {
+		dma_unmap_single(dmx_get_dev(ss->dmx), ss->buf_map,
+				ss->bufsize, DMA_FROM_DEVICE);
+		free_pages(ss->buf, get_order(ss->bufsize));
+		ss->buf = 0;
+		ss->buf_map = 0;
+	}
+	ss->enable = 0;
+	pr_inf("demux%d smallsec buf disable\n", ss->dmx->id);
+	return 0;
+}
+
+static int dmx_smallsec_set(struct aml_smallsec *ss, int enable, int bufsize,
+				int force)
+{
+	if (!enable) {/*disable*/
+
+		if (ss->enable || force)
+			_dmx_smallsec_disable(ss);
+
+	} else {/*enable*/
+
+		if (bufsize < 0)
+			bufsize = SS_BUFSIZE_DEF;
+		else if (!bufsize)
+			bufsize = ss->bufsize;
+		else {
+			/*unit:FF max:FF00*/
+			bufsize &= ~0xFF;
+			bufsize &= 0x1FF00;
+		}
+
+		if ((ss->enable && (bufsize != ss->bufsize)) || force)
+			_dmx_smallsec_disable(ss);
+
+		if (!ss->enable)
+			_dmx_smallsec_enable(ss, bufsize);
+	}
+
+	return 0;
+}
+
+static int _dmx_timeout_enable(struct aml_dmxtimeout *dto, int timeout,
+						int ch_dis, int match)
+{
+
+	DMX_WRITE_REG(dto->dmx->id, DEMUX_INPUT_TIMEOUT_C, ch_dis);
+	DMX_WRITE_REG(dto->dmx->id, DEMUX_INPUT_TIMEOUT,
+				((!!match)<<31) |
+				(timeout&0x7fffffff));
+
+	dto->ch_disable = ch_dis;
+	dto->match = match;
+	dto->timeout = timeout;
+	dto->trigger = 0;
+	dto->enable = 1;
+
+	pr_inf("demux%d timeout enable:timeout(%d),ch(0x%x),match(%d)\n",
+		dto->dmx->id, dto->timeout, dto->ch_disable, dto->match);
+
+	return 0;
+}
+static int _dmx_timeout_disable(struct aml_dmxtimeout *dto)
+{
+
+	DMX_WRITE_REG(dto->dmx->id, DEMUX_INPUT_TIMEOUT, 0);
+	dto->enable = 0;
+	dto->trigger = 0;
+	pr_inf("demux%d timeout disable\n", dto->dmx->id);
+
+	return 0;
+}
+
+static int dmx_timeout_set(struct aml_dmxtimeout *dto, int enable,
+				int timeout, int ch_dis, int match,
+				int force)
+{
+
+	if (!enable) {/*disable*/
+
+		if (dto->enable || force)
+			_dmx_timeout_disable(dto);
+
+	} else {/*enable*/
+
+		if (timeout < 0) {
+			timeout = DTO_TIMEOUT_DEF;
+			ch_dis = DTO_CHDIS_VAS;
+			match = dto->match;
+		} else if (!timeout) {
+			timeout = dto->timeout;
+			ch_dis = dto->ch_disable;
+			match = dto->match;
+		}
+
+		if ((dto->enable && (timeout != dto->timeout))
+			|| force)
+			_dmx_timeout_disable(dto);
+
+		if (!dto->enable)
+			_dmx_timeout_enable(dto, timeout, ch_dis, match);
+	}
+
+	return 0;
+}
+
+/*Initalize the registers*/
+static int dmx_init(struct aml_dmx *dmx)
+{
+	struct aml_dvb *dvb = (struct aml_dvb *)dmx->demux.priv;
+	int irq;
+
+	if (dmx->init) {
+		return 0;
+	}
+
+	/*Register irq handlers */
+	if (dmx->dmx_irq != -1) {
+		tasklet_init(&dmx->dmx_tasklet,
+				dmx_irq_bh_handler,
+				(unsigned long)dmx);
+		irq = request_irq(dmx->dmx_irq,	dmx_irq_handler,
+				IRQF_SHARED|IRQF_TRIGGER_RISING,
+				"dmx irq", dmx);
+		pr_dbg("request_irq:%d\n", dmx->dmx_irq);
+	}
+
+	/*Allocate buffer */
+	if (dmx_alloc_sec_buffer(dmx) < 0)
+		return -1;
+
+	if (dmx_alloc_sub_buffer(dmx) < 0)
+		return -1;
+
+	if (dmx_alloc_pes_buffer(dmx) < 0)
+		return -1;
+
+	/*Reset the hardware */
+	if (!dvb->dmx_init) {
+		init_timer(&dvb->watchdog_timer);
+		dvb->watchdog_timer.function = section_buffer_watchdog_func;
+		dvb->watchdog_timer.expires =
+		    jiffies + msecs_to_jiffies(WATCHDOG_TIMER);
+		dvb->watchdog_timer.data = (unsigned long)dvb;
+#ifdef ENABLE_SEC_BUFF_WATCHDOG
+		add_timer(&dvb->watchdog_timer);
+#endif
+		dmx_reset_hw(dvb);
+	}
+
+	dvb->dmx_init++;
+
+	memset(dmx->sec_buf_watchdog_count, 0,
+	       sizeof(dmx->sec_buf_watchdog_count));
+
+	dmx->init = 1;
+
+	return 0;
+}
+
+/*Release the resource*/
+static int dmx_deinit(struct aml_dmx *dmx)
+{
+	struct aml_dvb *dvb = (struct aml_dvb *)dmx->demux.priv;
+
+	if (!dmx->init)
+		return 0;
+
+	DMX_WRITE_REG(dmx->id, DEMUX_CONTROL, 0);
+
+	dvb->dmx_init--;
+
+	/*Reset the hardware */
+	if (!dvb->dmx_init) {
+		dmx_reset_hw(dvb);
+#ifdef ENABLE_SEC_BUFF_WATCHDOG
+		del_timer_sync(&dvb->watchdog_timer);
+#endif
+	}
+
+	if (dmx->sec_pages) {
+		dma_unmap_single(dmx_get_dev(dmx), dmx->sec_pages_map,
+				dmx->sec_total_len, DMA_FROM_DEVICE);
+		free_pages(dmx->sec_pages, get_order(dmx->sec_total_len));
+		dmx->sec_pages = 0;
+		dmx->sec_pages_map = 0;
+	}
+	if (dmx->sub_pages) {
+		dma_unmap_single(dmx_get_dev(dmx), dmx->sub_pages_map,
+				dmx->sub_buf_len, DMA_FROM_DEVICE);
+		free_pages(dmx->sub_pages, get_order(dmx->sub_buf_len));
+		dmx->sub_pages = 0;
+	}
+	if (dmx->pes_pages) {
+		dma_unmap_single(dmx_get_dev(dmx), dmx->pes_pages_map,
+				dmx->pes_buf_len, DMA_FROM_DEVICE);
+		free_pages(dmx->pes_pages, get_order(dmx->pes_buf_len));
+		dmx->pes_pages = 0;
+	}
+
+	if (dmx->dmx_irq != -1) {
+		free_irq(dmx->dmx_irq, dmx);
+		tasklet_kill(&dmx->dmx_tasklet);
+	}
+
+	dmx->init = 0;
+
+	return 0;
+}
+
+/*Check the record flag*/
+static int dmx_get_record_flag(struct aml_dmx *dmx)
+{
+	int i, linked = 0, record_flag = 0;
+	struct aml_dvb *dvb = (struct aml_dvb *)dmx->demux.priv;
+
+	/*Check whether a async fifo connected to this dmx */
+	for (i = 0; i < ASYNCFIFO_COUNT; i++) {
+		if (!dvb->asyncfifo[i].init)
+			continue;
+		if ((dvb->asyncfifo[i].source == dmx->id)
+		    /*&& !(dvb->swfilter.user && (i==SF_AFIFO_ID)) */
+		    /*sf mode reserved */
+		    ) {
+			linked = 1;
+			break;
+		}
+	}
+
+	for (i = 0; i < CHANNEL_COUNT; i++) {
+		if (dmx->channel[i].used && dmx->channel[i].dvr_feed) {
+			if (!dmx->record) {
+				dmx->record = 1;
+
+				if (linked) {
+					/*A new record will start,
+					   must reset the async fifos for
+					 linking the right demux */
+					reset_async_fifos(dvb);
+				}
+			}
+			if (linked)
+				record_flag = 1;
+			goto find_done;
+		}
+	}
+
+	if (dmx->record) {
+		dmx->record = 0;
+		if (linked) {
+			/*A record will stop, reset the async fifos
+			for linking the right demux */
+			reset_async_fifos(dvb);
+		}
+	}
+
+find_done:
+	pr_dbg("channel:%d record_flag:%d linked:%d\n", i, record_flag, linked);
+	return record_flag;
+}
+
+/*Enable the demux device*/
+static int dmx_enable(struct aml_dmx *dmx)
+{
+	struct aml_dvb *dvb = (struct aml_dvb *)dmx->demux.priv;// 	x20 
+	int fec_sel, hi_bsf, fec_ctrl, record;			//	w21, w22, w23, w25, w24
+	enum aml_ts_source_t dsc_source;
+	int fec_core_sel = 0;
+	int set_stb = 0, fec_s = 0;
+	int s2p_id;
+	u32 invert0 = 0, invert1 = 0, fec_s0 = 0, fec_s1 = 0;
+
+	record = dmx_get_record_flag(dmx);
+
+	switch (dmx->source) {
+	case AM_TS_SRC_TS0:
+		fec_sel = 0;
+		fec_ctrl = dvb->ts[0].control;
+		record = record ? 1 : 0;
+		break;
+	case AM_TS_SRC_TS1:
+		fec_sel = 1;
+		fec_ctrl = dvb->ts[1].control;
+		record = record ? 1 : 0;
+		break;
+	case AM_TS_SRC_TS2:
+		fec_sel = 2;
+		fec_ctrl = dvb->ts[2].control;
+		record = record ? 1 : 0;
+		break;
+	case AM_TS_SRC_S_TS0:
+	case AM_TS_SRC_S_TS1:
+	case AM_TS_SRC_S_TS2:
+		s2p_id = 0;
+		fec_ctrl = 0;
+		if (dmx->source == AM_TS_SRC_S_TS0) {
+			s2p_id = dvb->ts[0].s2p_id;
+			fec_ctrl = dvb->ts[0].control;
+		} else if (dmx->source == AM_TS_SRC_S_TS1) {
+			s2p_id = dvb->ts[1].s2p_id;
+			fec_ctrl = dvb->ts[1].control;
+		} else if (dmx->source == AM_TS_SRC_S_TS2) {
+			s2p_id = dvb->ts[2].s2p_id;
+			fec_ctrl = dvb->ts[2].control;
+		}
+		fec_sel = (s2p_id == 1) ? 5 : 6;
+		record = record ? 1 : 0;
+		set_stb = 1;
+		fec_s = dmx->source - AM_TS_SRC_S_TS0;
+		break;
+	case AM_TS_SRC_HIU:
+		fec_sel = 7;
+		fec_ctrl = 0;
+		record = 0;
+		break;
+	default:
+		fec_sel = 0;
+		fec_ctrl = 0;
+		record = 0;
+		break;
+	}
+
+	if (dmx->channel[0].used || dmx->channel[1].used)
+		hi_bsf = 1;
+	else
+		hi_bsf = 0;
+
+	dsc_source = dvb->dsc_source;
+
+//	if ((dvb->dsc_source!=-1)
+//		&& ((dvb->dsc_source-AM_TS_SRC_DMX0)== dmx->id))
+//		fec_core_sel = 1;
+
+	pr_dbg("dmx->source:%d fec_sel:%d fec_core_sel:%d record:%d hi_bsf:%d dmx->dump_ts_select:%d\n",
+		dmx->source, fec_sel, fec_core_sel, record, hi_bsf, dmx->dump_ts_select);
+
+	if (dmx->chan_count) {
+	    if (set_stb) {
+		u32 v = READ_MPEG_REG(STB_TOP_CONFIG);
+		int i;
+		u32 v0 = v;
+
+		for (i = 0; i < TS_IN_COUNT; i++) {
+		    if (dvb->ts[i].s2p_id == 0)
+			fec_s0 = i;
+		    else if (dvb->ts[i].s2p_id == 1)
+			fec_s1 = i;
+		}
+		if (dsc_source == 1) {
+		    invert0 = dvb->s2p[0].invert;
+		    invert1 = dvb->s2p[1].invert;
+		}
+		v &= ~((0x3 << S2P0_FEC_SERIAL_SEL) |
+		       (0x1f << INVERT_S2P0_FEC_CLK) |
+		       (0x3 << S2P1_FEC_SERIAL_SEL) |
+		       (0x1f << INVERT_S2P1_FEC_CLK));
+
+		v |= (fec_s0 << S2P0_FEC_SERIAL_SEL) |
+		     (invert0 << INVERT_S2P0_FEC_CLK) |
+		     (fec_s1 << S2P1_FEC_SERIAL_SEL) |
+		     (invert1 << INVERT_S2P1_FEC_CLK);
+		WRITE_MPEG_REG(STB_TOP_CONFIG, v);
+		pr_dbg("cfg0:%x cfg:%x fec_s0:%x invert0:%x fec_s1:%x invert1:%x\n",
+			v0, v, fec_s0, invert0, fec_s1, invert1);
+	    }
+
+	    /*Initialize the registers */
+	    DMX_WRITE_REG(dmx->id, STB_INT_MASK, DEMUX_INT_MASK);
+	    DMX_WRITE_REG(dmx->id, DEMUX_MEM_REQ_EN,
+			  (1 << SECTION_AHB_DMA_EN) |
+			  (0 << SUB_AHB_DMA_EN) |
+			  (1 << OTHER_PES_AHB_DMA_EN) |
+			  (1 << SECTION_PACKET) |
+			  (1 << VIDEO_PACKET) |
+			  (1 << AUDIO_PACKET) |
+			  (1 << SUB_PACKET) |
+			  (1 << SCR_ONLY_PACKET) |
+			  (1 << OTHER_PES_PACKET));
+	    DMX_WRITE_REG(dmx->id, PES_STRONG_SYNC, 0x1234);
+
+		DMX_WRITE_REG(dmx->id, DEMUX_ENDIAN,
+			      (1<<SEPERATE_ENDIAN) |
+			      (0<<OTHER_PES_ENDIAN) |
+			      (7<<SCR_ENDIAN) |
+			      (7<<SUB_ENDIAN) |
+			      (7<<AUDIO_ENDIAN) |
+			      (7<<VIDEO_ENDIAN) |
+			      (7 << OTHER_ENDIAN) |
+			      (7 << BYPASS_ENDIAN) | (0 << SECTION_ENDIAN));
+
+	    DMX_WRITE_REG(dmx->id, TS_HIU_CTL,
+		          (0 << LAST_BURST_THRESHOLD) |
+			  (hi_bsf << USE_HI_BSF_INTERFACE));
+
+	    DMX_WRITE_REG(dmx->id, FEC_INPUT_CONTROL,
+			      (fec_core_sel << FEC_CORE_SEL) |
+			      (fec_sel << FEC_SEL) | (fec_ctrl << 0));
+	    DMX_WRITE_REG(dmx->id, STB_OM_CTL,
+			      (0x40 << MAX_OM_DMA_COUNT) |
+			      (0x7f << LAST_OM_ADDR));
+	    DMX_WRITE_REG(dmx->id, DEMUX_CONTROL,
+			      (0 << BYPASS_USE_RECODER_PATH) |
+			      (0 << INSERT_AUDIO_PES_STRONG_SYNC) |
+			      (0 << INSERT_VIDEO_PES_STRONG_SYNC) |
+			      (0 << OTHER_INT_AT_PES_BEGINING) |
+			      (0 << DISCARD_AV_PACKAGE) |
+			      ((!!dmx->dump_ts_select) << TS_RECORDER_SELECT) |
+			      (record << TS_RECORDER_ENABLE) |
+			      (1 << KEEP_DUPLICATE_PACKAGE) |
+			      (1 << SECTION_END_WITH_TABLE_ID) |
+			      (1 << ENABLE_FREE_CLK_FEC_DATA_VALID) |
+			      (1 << ENABLE_FREE_CLK_STB_REG) |
+			      (1 << STB_DEMUX_ENABLE) |
+			      (1 << NOT_USE_OF_SOP_INPUT));
+	} else {
+		DMX_WRITE_REG(dmx->id, STB_INT_MASK, 0);
+		DMX_WRITE_REG(dmx->id, FEC_INPUT_CONTROL, 0);
+		DMX_WRITE_REG(dmx->id, DEMUX_CONTROL, 0);
+	}
+
+	return 0;
+}
+
+static int dmx_set_misc(struct aml_dmx *dmx, int hi_bsf, int en_dsc)
+{
+	if (hi_bsf >= 0) {
+		DMX_WRITE_REG(dmx->id, TS_HIU_CTL,
+					hi_bsf ?
+					(DMX_READ_REG(dmx->id, TS_HIU_CTL) |
+					(1 << USE_HI_BSF_INTERFACE))
+					:
+					(DMX_READ_REG(dmx->id, TS_HIU_CTL) &
+					(~(1 << USE_HI_BSF_INTERFACE))));
+	}
+
+	if (en_dsc >= 0) {
+		DMX_WRITE_REG(dmx->id, FEC_INPUT_CONTROL,
+				en_dsc ?
+				(DMX_READ_REG(dmx->id, FEC_INPUT_CONTROL) |
+				(1 << FEC_CORE_SEL))
+				:
+				(DMX_READ_REG(dmx->id, FEC_INPUT_CONTROL) &
+				(~(1 << FEC_CORE_SEL))));
+	}
+
+	return 0;
+}
+
+static int dmx_set_misc_id(struct aml_dvb *dvb, int id, int hi_bsf, int en_dsc)
+{
+	return dmx_set_misc(&dvb->dmx[id], hi_bsf, en_dsc);
+}
+
+/*Get the channel's ID by its PID*/
+static int dmx_get_chan(struct aml_dmx *dmx, int pid)
+{
+	int id;
+
+	for (id = 0; id < CHANNEL_COUNT; id++) {
+		if (dmx->channel[id].used && dmx->channel[id].pid == pid)
+			return id;
+	}
+
+	return -1;
+}
+
+/*Get the channel's target*/
+static u32 dmx_get_chan_target(struct aml_dmx *dmx, int cid)
+{
+	u32 type;
+
+	if (!dmx->channel[cid].used)
+		return 0xFFFF;
+
+	if (dmx->channel[cid].type == DMX_TYPE_SEC) {
+		type = SECTION_PACKET;
+	} else {
+		switch (dmx->channel[cid].pes_type) {
+		case DMX_PES_AUDIO:
+			type = AUDIO_PACKET;
+			break;
+		case DMX_PES_VIDEO:
+			type = VIDEO_PACKET;
+			break;
+		case DMX_PES_SUBTITLE:
+		case DMX_PES_TELETEXT:
+			type = SUB_PACKET;
+			break;
+		case DMX_PES_PCR:
+			type = SCR_ONLY_PACKET;
+			break;
+		default:
+			type = OTHER_PES_PACKET;
+			break;
+		}
+	}
+
+	return (type << PID_TYPE) | dmx->channel[cid].pid;
+}
+
+/*Get the advance value of the channel*/
+static inline u32 dmx_get_chan_advance(struct aml_dmx *dmx, int cid)
+{
+	return 0;
+}
+
+/*Set the channel registers*/
+static int dmx_set_chan_regs(struct aml_dmx *dmx, int cid)
+{
+	u32 data, addr, advance, max;
+
+	while (DMX_READ_REG(dmx->id, FM_WR_ADDR) & 0x8000)
+		udelay(1);
+
+	if (cid & 1) {
+		data =
+		    (dmx_get_chan_target(dmx, cid - 1) << 16) |
+		    dmx_get_chan_target(dmx, cid);
+		advance =
+		    (dmx_get_chan_advance(dmx, cid) << 8) |
+		    dmx_get_chan_advance(dmx, cid - 1);
+	} else {
+		data =
+		    (dmx_get_chan_target(dmx, cid) << 16) |
+		    dmx_get_chan_target(dmx, cid + 1);
+		advance =
+		    (dmx_get_chan_advance(dmx, cid + 1) << 8) |
+		    dmx_get_chan_advance(dmx, cid);
+	}
+	addr = cid >> 1;
+	DMX_WRITE_REG(dmx->id, FM_WR_DATA, data);
+	DMX_WRITE_REG(dmx->id, FM_WR_ADDR, (advance << 16) | 0x8000 | addr);
+
+	for (max = CHANNEL_COUNT - 1; max > 0; max--) {
+		if (dmx->channel[max].used)
+			break;
+	}
+
+	data = DMX_READ_REG(dmx->id, MAX_FM_COMP_ADDR) & 0xF0;
+	DMX_WRITE_REG(dmx->id, MAX_FM_COMP_ADDR, data | (max >> 1));
+
+	if (DMX_READ_REG(dmx->id, OM_CMD_STATUS) & 0x8e00) {
+		pr_error("error send cmd %x\n",
+			 DMX_READ_REG(dmx->id, OM_CMD_STATUS));
+	}
+
+	if (cid == 0)
+		first_video_pts = 0;
+	else if (cid == 1)
+		first_audio_pts = 0;
+
+	return 0;
+}
+
+/*Get the filter target*/
+static int dmx_get_filter_target(struct aml_dmx *dmx, int fid, u32 *target,
+				 u8 *advance)
+{
+	struct dmx_section_filter *filter;
+	struct aml_filter *f;
+	int i, cid, neq_bytes;
+
+	fid = fid & 0xFFFF;
+	f = &dmx->filter[fid];
+
+	if (!f->used) {
+		target[0] = 0x1fff;
+		advance[0] = 0;
+		for (i = 1; i < FILTER_LEN; i++) {
+			target[i] = 0x9fff;
+			advance[i] = 0;
+		}
+		return 0;
+	}
+
+	cid = f->chan_id;
+	filter = f->filter;
+
+	neq_bytes = 0;
+	if (filter->filter_mode[0] != 0xFF) {
+		neq_bytes = 2;
+	} else {
+		for (i = 3; i < FILTER_LEN; i++) {
+			if (filter->filter_mode[i] != 0xFF)
+				neq_bytes++;
+		}
+	}
+
+	f->neq = 0;
+
+	for (i = 0; i < FILTER_LEN; i++) {
+		u8 value = filter->filter_value[i];
+		u8 mask = filter->filter_mask[i];
+		u8 mode = filter->filter_mode[i];
+		u8 mb, mb1, nb, v, t, adv = 0;
+
+		if (!i) {
+			mb = 1;
+			mb1 = 1;
+			v = 0;
+			if ((mode == 0xFF) && mask) {
+				t = mask & 0xF0;
+				if (t) {
+					mb1 = 0;
+					adv |= t^0xF0;
+				}
+				v |= (value & 0xF0) | adv;
+
+				t = mask & 0x0F;
+				if (t) {
+					mb  = 0;
+					adv |= t^0x0F;
+				}
+				v |= (value & 0x0F) | adv;
+			}
+
+			target[i] = (mb << SECTION_FIRSTBYTE_MASKLOW) |
+			    (mb1 << SECTION_FIRSTBYTE_MASKHIGH) |
+			    (0 << SECTION_FIRSTBYTE_DISABLE_PID_CHECK) |
+			    (cid << SECTION_FIRSTBYTE_PID_INDEX) | v;
+			advance[i] = adv;
+		} else {
+			if (i < 3) {
+				value = 0;
+				mask = 0;
+				mode = 0xff;
+			}
+			mb = 1;
+			nb = 0;
+			v = 0;
+
+			if ((i >= 3) && mask) {
+				if (mode == 0xFF) {
+					mb = 0;
+					nb = 0;
+					adv = mask ^ 0xFF;
+					v = value | adv;
+				} else {
+					if (neq_bytes == 1) {
+						mb = 0;
+						nb = 1;
+						adv = mask ^ 0xFF;
+						v = value & ~adv;
+					}
+				}
+			}
+			target[i] = (mb << SECTION_RESTBYTE_MASK) |
+			    (nb << SECTION_RESTBYTE_MASK_EQ) |
+			    (0 << SECTION_RESTBYTE_DISABLE_PID_CHECK) |
+			    (cid << SECTION_RESTBYTE_PID_INDEX) | v;
+			advance[i] = adv;
+		}
+
+		f->value[i] = value;
+		f->maskandmode[i] = mask & mode;
+		f->maskandnotmode[i] = mask & ~mode;
+
+		if (f->maskandnotmode[i])
+			f->neq = 1;
+	}
+
+	return 0;
+}
+
+/*Set the filter registers*/
+static int dmx_set_filter_regs(struct aml_dmx *dmx, int fid)
+{
+	u32 t1[FILTER_LEN], t2[FILTER_LEN];
+	u8 advance1[FILTER_LEN], advance2[FILTER_LEN];
+	u32 addr, data, max, adv;
+	int i;
+
+	pr_dbg("set filter (id:%d) registers %x\n", fid, MAX_FM_COMP_ADDR);
+
+	if (fid & 1) {
+		dmx_get_filter_target(dmx, fid - 1, t1, advance1);
+		dmx_get_filter_target(dmx, fid, t2, advance2);
+	} else {
+		dmx_get_filter_target(dmx, fid, t1, advance1);
+		dmx_get_filter_target(dmx, fid + 1, t2, advance2);
+	}
+
+	for (i = 0; i < FILTER_LEN; i++) {
+		while (DMX_READ_REG(dmx->id, FM_WR_ADDR) & 0x8000)
+			udelay(1);
+
+		data = (t1[i] << 16) | t2[i];
+		addr = (fid >> 1) | ((i + 1) << 4);
+		adv = (advance1[i] << 8) | advance2[i];
+
+		DMX_WRITE_REG(dmx->id, FM_WR_DATA, data);
+		DMX_WRITE_REG(dmx->id, FM_WR_ADDR, (adv << 16) | 0x8000 | addr);
+
+		pr_dbg("write fm %x:%x\n", (adv << 16) | 0x8000 | addr, data);
+	}
+
+	for (max = FILTER_COUNT - 1; max > 0; max--) {
+		if (dmx->filter[max].used)
+			break;
+	}
+
+	data = DMX_READ_REG(dmx->id, MAX_FM_COMP_ADDR) & 0xF;
+	DMX_WRITE_REG(dmx->id, MAX_FM_COMP_ADDR, data | ((max >> 1) << 4));
+
+	pr_dbg("write fm comp %x\n", data | ((max >> 1) << 4));
+
+	if (DMX_READ_REG(dmx->id, OM_CMD_STATUS) & 0x8e00) {
+		pr_error("error send cmd %x\n",
+			 DMX_READ_REG(dmx->id, OM_CMD_STATUS));
+	}
+
+	return 0;
+}
+
+/*Clear the filter's buffer*/
+static void dmx_clear_filter_buffer(struct aml_dmx *dmx, int fid)
+{
+	u32 section_busy32 = DMX_READ_REG(dmx->id, SEC_BUFF_READY);
+	u32 filter_number;
+	int i;
+
+	if (!section_busy32)
+		return;
+
+	for (i = 0; i < SEC_BUF_COUNT; i++) {
+		if (section_busy32 & (1 << i)) {
+			DMX_WRITE_REG(dmx->id, SEC_BUFF_NUMBER, i);
+			filter_number =
+			    (DMX_READ_REG(dmx->id, SEC_BUFF_NUMBER) >> 8);
+			if (filter_number != fid)
+				section_busy32 &= ~(1 << i);
+		}
+	}
+
+	if (section_busy32)
+		DMX_WRITE_REG(dmx->id, SEC_BUFF_READY, section_busy32);
+}
+
+static void async_fifo_set_regs(struct aml_asyncfifo *afifo, int source_val)
+{
+	u32 start_addr = virt_to_phys((void *)afifo->pages);
+	u32 size = afifo->buf_len;
+	u32 flush_size = afifo->flush_size;
+	int factor = dmx_get_order(size / flush_size);
+
+	pr_dbg("ASYNC FIFO id=%d, link to DMX%d, afifo->pages:%p start_addr 0x%08x, buf_size %d,"
+		"source value 0x%x, factor %d\n",
+		afifo->id, afifo->source, (void *)afifo->pages, start_addr, size, source_val, factor);
+	/* Destination address */
+	WRITE_ASYNC_FIFO_REG(afifo->id, REG0, start_addr);
+
+	/* Setup flush parameters */
+	WRITE_ASYNC_FIFO_REG(afifo->id, REG1,
+			(0 << ASYNC_FIFO_TO_HIU) |
+			(0 << ASYNC_FIFO_FLUSH) |
+			/* don't flush the path */
+			(1 << ASYNC_FIFO_RESET) |
+			/* reset the path */
+			(1 << ASYNC_FIFO_WRAP_EN) |
+			/* wrap enable */
+			(0 << ASYNC_FIFO_FLUSH_EN) |
+			/* disable the flush path */
+			/*(0x3 << ASYNC_FIFO_FLUSH_CNT_LSB);
+			// flush 3 x 32  32-bit words */
+			/*(0x7fff << ASYNC_FIFO_FLUSH_CNT_LSB);
+			// flush 4MBytes of data */
+			(((size >> 7) & 0x7fff) << ASYNC_FIFO_FLUSH_CNT_LSB));
+			/* number of 128-byte blocks to flush */
+
+	/* clear the reset signal */
+	WRITE_ASYNC_FIFO_REG(afifo->id, REG1,
+		     READ_ASYNC_FIFO_REG(afifo->id,
+					REG1) & ~(1 << ASYNC_FIFO_RESET));
+	/* Enable flush */
+	WRITE_ASYNC_FIFO_REG(afifo->id, REG1,
+		     READ_ASYNC_FIFO_REG(afifo->id,
+				REG1) | (1 << ASYNC_FIFO_FLUSH_EN));
+
+	/*Setup Fill parameters */
+	WRITE_ASYNC_FIFO_REG(afifo->id, REG2,
+			     (1 << ASYNC_FIFO_ENDIAN_LSB) |
+			     (0 << ASYNC_FIFO_FILL_EN) |
+			     /* disable fill path to reset fill path */
+			     /*(96 << ASYNC_FIFO_FILL_CNT_LSB);
+				// 3 x 32  32-bit words */
+			     (0 << ASYNC_FIFO_FILL_CNT_LSB));
+				/* forever FILL; */
+	WRITE_ASYNC_FIFO_REG(afifo->id, REG2,
+			READ_ASYNC_FIFO_REG(afifo->id, REG2) |
+				(1 << ASYNC_FIFO_FILL_EN));/*Enable fill path*/
+
+	/* generate flush interrupt */
+	WRITE_ASYNC_FIFO_REG(afifo->id, REG3,
+			(READ_ASYNC_FIFO_REG(afifo->id, REG3) & 0xffff0000) |
+				((((size >> (factor + 7)) - 1) & 0x7fff) <<
+					ASYNC_FLUSH_SIZE_IRQ_LSB));
+
+	/* Connect the STB DEMUX to ASYNC_FIFO */
+	WRITE_ASYNC_FIFO_REG(afifo->id, REG2,
+			READ_ASYNC_FIFO_REG(afifo->id, REG2) |
+			(source_val << ASYNC_FIFO_SOURCE_LSB));
+}
+
+/*Reset the ASYNC FIFOS when a ASYNC FIFO connect to a different DMX*/
+static void reset_async_fifos(struct aml_dvb *dvb)
+{
+	struct aml_asyncfifo *low_dmx_fifo = NULL;
+	struct aml_asyncfifo *high_dmx_fifo = NULL;
+	int i, j;
+	int record_enable;
+
+	pr_dbg("reset ASYNC FIFOs\n");
+	for (i = 0; i < ASYNCFIFO_COUNT; i++) {
+		if (!dvb->asyncfifo[i].init)
+			continue;
+		pr_dbg("Disable ASYNC FIFO id=%d\n", dvb->asyncfifo[i].id);
+		CLEAR_ASYNC_FIFO_REG_MASK(dvb->asyncfifo[i].id, REG1,
+					  1 << ASYNC_FIFO_FLUSH_EN);
+		CLEAR_ASYNC_FIFO_REG_MASK(dvb->asyncfifo[i].id, REG2,
+					  1 << ASYNC_FIFO_FILL_EN);
+		if (READ_ASYNC_FIFO_REG(dvb->asyncfifo[i].id, REG2) &
+				(1 << ASYNC_FIFO_FILL_EN) ||
+			READ_ASYNC_FIFO_REG(dvb->asyncfifo[i].id, REG1) &
+				(1 << ASYNC_FIFO_FLUSH_EN)) {
+			pr_dbg("Set reg failed\n");
+		} else
+			pr_dbg("Set reg ok\n");
+		dvb->asyncfifo[i].buf_toggle = 0;
+		dvb->asyncfifo[i].buf_read = 0;
+	}
+
+	if (dvb->ts[0].mode == AM_TS_SERIAL)
+		dvb->dmx[0].source = AM_TS_SRC_S_TS0;
+
+	if (dvb->ts[1].mode == AM_TS_SERIAL)
+		dvb->dmx[1].source = AM_TS_SRC_S_TS1;
+
+	for (j = 0; j < DMX_DEV_COUNT; j++) {
+		if (!dvb->dmx[j].init)
+			continue;
+		record_enable = 0;
+		for (i = 0; i < ASYNCFIFO_COUNT; i++) {
+			if (!dvb->asyncfifo[i].init)
+				continue;
+
+			if (dvb->dmx[j].record
+			    && dvb->dmx[j].id == dvb->asyncfifo[i].source) {
+				/*This dmx is linked to the async fifo,
+				Enable the TS_RECORDER_ENABLE */
+				record_enable = 1;
+				if (!low_dmx_fifo) {
+					low_dmx_fifo = &dvb->asyncfifo[i];
+				} else if (low_dmx_fifo->source >
+					   dvb->asyncfifo[i].source) {
+					high_dmx_fifo = low_dmx_fifo;
+					low_dmx_fifo = &dvb->asyncfifo[i];
+				} else if (low_dmx_fifo->source <
+					   dvb->asyncfifo[i].source) {
+					high_dmx_fifo = &dvb->asyncfifo[i];
+				}
+
+				break;
+			}
+		}
+		pr_dbg("Set DMX%d TS_RECORDER_ENABLE: %s mode:%d\n", dvb->dmx[j].id,
+		       record_enable ? "yes" : "no", dvb->ts[j].mode);
+		if (record_enable) {
+			/*DMX_SET_REG_MASK(dvb->dmx[j].id,
+			DEMUX_CONTROL, 1<<TS_RECORDER_ENABLE); */
+			DMX_WRITE_REG(dvb->dmx[j].id, DEMUX_CONTROL,
+				DMX_READ_REG(dvb->dmx[j].id, DEMUX_CONTROL) |
+				(1 << TS_RECORDER_ENABLE));
+		} else {
+			/*DMX_CLEAR_REG_MASK(dvb->dmx[j].id,
+			DEMUX_CONTROL, 1<<TS_ECORDER_ENABLE); */
+			DMX_WRITE_REG(dvb->dmx[j].id, DEMUX_CONTROL,
+				DMX_READ_REG(dvb->dmx[j].id, DEMUX_CONTROL) &
+				(~(1 <<	TS_RECORDER_ENABLE)));
+		}
+	}
+
+	/*Set the async fifo regs */
+	if (low_dmx_fifo) {
+		async_fifo_set_regs(low_dmx_fifo, 0x3);
+
+		if (high_dmx_fifo)
+			async_fifo_set_regs(high_dmx_fifo, 0x2);
+	}
+}
+
+/*Reset the demux device*/
+void dmx_reset_hw(struct aml_dvb *dvb)
+{
+	dmx_reset_hw_ex(dvb, 1);
+}
+
+/*Reset the demux device*/
+void dmx_reset_hw_ex(struct aml_dvb *dvb, int reset_irq)
+{
+	int id, times;
+
+	pr_dbg("demux reset begin\n");
+
+	for (id = 0; id < DMX_DEV_COUNT; id++) {
+		if (dvb->dmx[id].dmx_irq < 0 || !dvb->dmx[id].init)
+			continue;
+		if (reset_irq) {
+			if (dvb->dmx[id].dmx_irq != -1)
+				disable_irq(dvb->dmx[id].dmx_irq);
+			if (dvb->dmx[id].dvr_irq != -1)
+				disable_irq(dvb->dmx[id].dvr_irq);
+		}
+	}
+#ifdef ENABLE_SEC_BUFF_WATCHDOG
+	if (reset_irq)
+		del_timer_sync(&dvb->watchdog_timer);
+#endif
+
+	WRITE_MPEG_REG(RESET1_REGISTER, RESET_DEMUXSTB);
+
+	for (id = 0; id < DMX_DEV_COUNT; id++) {
+		times = 0;
+		
+		if (dvb->dmx[id].dmx_irq < 0)
+			continue;
+		
+		while (times++ < 1000000) {
+			if (!(DMX_READ_REG(id, OM_CMD_STATUS) & 0x01))
+				break;
+		}
+	}
+
+	WRITE_MPEG_REG(STB_TOP_CONFIG, 0);
+
+	for (id = 0; id < DMX_DEV_COUNT; id++) {
+		u32 version, data;
+
+		if (dvb->dmx[id].dmx_irq < 0 || !dvb->dmx[id].init)
+			continue;
+
+		if (reset_irq) {
+			if (dvb->dmx[id].dmx_irq != -1)
+				enable_irq(dvb->dmx[id].dmx_irq);
+			if (dvb->dmx[id].dvr_irq != -1)
+				enable_irq(dvb->dmx[id].dvr_irq);
+		}
+		DMX_WRITE_REG(id, DEMUX_CONTROL, 0x0000);
+		version = DMX_READ_REG(id, STB_VERSION);
+		DMX_WRITE_REG(id, STB_TEST_REG, version);
+		pr_dbg("STB %d hardware version : %d\n", id, version);
+		DMX_WRITE_REG(id, STB_TEST_REG, 0x5550);
+		data = DMX_READ_REG(id, STB_TEST_REG);
+		if (data != 0x5550)
+			pr_error("STB %d register access failed\n", id);
+		DMX_WRITE_REG(id, STB_TEST_REG, 0xaaa0);
+		data = DMX_READ_REG(id, STB_TEST_REG);
+		if (data != 0xaaa0)
+			pr_error("STB %d register access failed\n", id);
+		DMX_WRITE_REG(id, MAX_FM_COMP_ADDR, 0x0000);
+		DMX_WRITE_REG(id, STB_INT_MASK, 0);
+		DMX_WRITE_REG(id, STB_INT_STATUS, 0xffff);
+		DMX_WRITE_REG(id, FEC_INPUT_CONTROL, 0);
+	}
+
+	stb_enable(dvb);
+
+	for (id = 0; id < DMX_DEV_COUNT; id++) {
+		struct aml_dmx *dmx = &dvb->dmx[id];
+		int n;
+		unsigned long addr;
+		unsigned long base;
+		unsigned long grp_addr[SEC_BUF_GRP_COUNT];
+		int grp_len[SEC_BUF_GRP_COUNT];
+		if (dvb->dmx[id].dmx_irq < 0 || !dvb->dmx[id].init)
+			continue;
+
+		if (dmx->sec_pages) {
+			grp_len[0] = (1 << SEC_GRP_LEN_0) * 8;
+			grp_len[1] = (1 << SEC_GRP_LEN_1) * 8;
+			grp_len[2] = (1 << SEC_GRP_LEN_2) * 8;
+			grp_len[3] = (1 << SEC_GRP_LEN_3) * 8;
+
+			grp_addr[0] = virt_to_phys((void *)dmx->sec_pages);
+			grp_addr[1] = grp_addr[0] + grp_len[0];
+			grp_addr[2] = grp_addr[1] + grp_len[1];
+			grp_addr[3] = grp_addr[2] + grp_len[2];
+
+			base = grp_addr[0] & 0xFFFF0000;
+			DMX_WRITE_REG(dmx->id, SEC_BUFF_BASE, base >> 16);
+			DMX_WRITE_REG(dmx->id, SEC_BUFF_01_START,
+					(((grp_addr[0] - base) >> 8) << 16) |
+					 ((grp_addr[1] - base) >> 8));
+			DMX_WRITE_REG(dmx->id, SEC_BUFF_23_START,
+					(((grp_addr[2] - base) >> 8) << 16) |
+					 ((grp_addr[3] - base) >> 8));
+			DMX_WRITE_REG(dmx->id, SEC_BUFF_SIZE,
+					SEC_GRP_LEN_0 |
+					(SEC_GRP_LEN_1 << 4) |
+					(SEC_GRP_LEN_2 << 8) |
+					(SEC_GRP_LEN_3 << 12));
+		}
+
+		if (dmx->sub_pages) {
+			addr = virt_to_phys((void *)dmx->sub_pages);
+			DMX_WRITE_REG(dmx->id, SB_START, addr >> 12);
+			DMX_WRITE_REG(dmx->id, SB_LAST_ADDR,
+				      (dmx->sub_buf_len >> 3) - 1);
+		}
+
+		if (dmx->pes_pages) {
+			addr = virt_to_phys((void *)dmx->pes_pages);
+			DMX_WRITE_REG(dmx->id, OB_START, addr >> 12);
+			DMX_WRITE_REG(dmx->id, OB_LAST_ADDR,
+				      (dmx->pes_buf_len >> 3) - 1);
+		}
+
+		for (n = 0; n < CHANNEL_COUNT; n++) {
+			/*struct aml_channel *chan = &dmx->channel[n];*/
+
+			/*if (chan->used)*/
+			{
+				dmx_set_chan_regs(dmx, n);
+			}
+		}
+
+		for (n = 0; n < FILTER_COUNT; n++) {
+			struct aml_filter *filter = &dmx->filter[n];
+
+			if (filter->used)
+				dmx_set_filter_regs(dmx, n);
+		}
+
+		dmx_enable(&dvb->dmx[id]);
+
+		dmx_smallsec_set(&dmx->smallsec,
+				dmx->smallsec.enable,
+				dmx->smallsec.bufsize,
+				1);
+
+		dmx_timeout_set(&dmx->timeout,
+				dmx->timeout.enable,
+				dmx->timeout.timeout,
+				dmx->timeout.ch_disable,
+				dmx->timeout.match,
+				1);
+	}
+	for(id=0; id<DSC_COUNT; id++)
+	{
+		struct aml_dsc *dsc = &dvb->dsc[id];
+
+		if(dsc->used)
+		{
+			dsc_set_pid(dsc, dsc->pid);
+
+			if(dsc->set&1)
+				dsc_set_key(dsc, 0, dsc->even);
+			if(dsc->set&2)
+				dsc_set_key(dsc, 1, dsc->odd);
+		}
+	}
+
+#ifdef ENABLE_SEC_BUFF_WATCHDOG
+	if (reset_irq) {
+		mod_timer(&dvb->watchdog_timer,
+			  jiffies + msecs_to_jiffies(WATCHDOG_TIMER));
+	}
+#endif
+
+	pr_dbg("demux reset end\n");
+}
+
+/*Reset the individual demux*/
+void dmx_reset_dmx_hw_ex_unlock(struct aml_dvb *dvb, struct aml_dmx *dmx,
+				int reset_irq)
+{
+	if (dvb->dmx[dmx->id].dmx_irq < 0)
+		return;
+	{
+		if (!dmx->init)
+			return;
+		if (reset_irq) {
+			if (dmx->dmx_irq != -1)
+				disable_irq(dmx->dmx_irq);
+			if (dmx->dvr_irq != -1)
+				disable_irq(dmx->dvr_irq);
+		}
+	}
+#ifdef ENABLE_SEC_BUFF_WATCHDOG
+	if (reset_irq) {
+		/*del_timer_sync(&dvb->watchdog_timer); */
+		dvb->dmx_watchdog_disable[dmx->id] = 1;
+	}
+#endif
+
+	WRITE_MPEG_REG(RESET3_REGISTER,
+		       (dmx->id) ? ((dmx->id ==
+				     1) ? RESET_DEMUX1 : RESET_DEMUX2) :
+		       RESET_DEMUX0);
+	WRITE_MPEG_REG(RESET3_REGISTER, RESET_DES);
+	{
+		int times;
+
+		times = 0;
+		while (times++ < 1000000) {
+			if (!(DMX_READ_REG(dmx->id, OM_CMD_STATUS) & 0x01))
+				break;
+		}
+	}
+
+	/*WRITE_MPEG_REG(STB_TOP_CONFIG, 0); */
+
+	{
+		u32 version, data;
+
+		if (!dmx->init)
+			return;
+
+		if (reset_irq) {
+			if (dmx->dmx_irq != -1)
+				enable_irq(dmx->dmx_irq);
+			if (dmx->dvr_irq != -1)
+				enable_irq(dmx->dvr_irq);
+		}
+		DMX_WRITE_REG(dmx->id, DEMUX_CONTROL, 0x0000);
+		version = DMX_READ_REG(dmx->id, STB_VERSION);
+		DMX_WRITE_REG(dmx->id, STB_TEST_REG, version);
+		pr_dbg("STB %d hardware version : %d\n", dmx->id, version);
+		DMX_WRITE_REG(dmx->id, STB_TEST_REG, 0x5550);
+		data = DMX_READ_REG(dmx->id, STB_TEST_REG);
+		if (data != 0x5550)
+			pr_error("STB %d register access failed\n", dmx->id);
+		DMX_WRITE_REG(dmx->id, STB_TEST_REG, 0xaaa0);
+		data = DMX_READ_REG(dmx->id, STB_TEST_REG);
+		if (data != 0xaaa0)
+			pr_error("STB %d register access failed\n", dmx->id);
+		DMX_WRITE_REG(dmx->id, MAX_FM_COMP_ADDR, 0x0000);
+		DMX_WRITE_REG(dmx->id, STB_INT_MASK, 0);
+		DMX_WRITE_REG(dmx->id, STB_INT_STATUS, 0xffff);
+		DMX_WRITE_REG(dmx->id, FEC_INPUT_CONTROL, 0);
+	}
+
+	stb_enable(dvb);
+
+	{
+		int n;
+		unsigned long addr;
+		unsigned long base;
+		unsigned long grp_addr[SEC_BUF_GRP_COUNT];
+		int grp_len[SEC_BUF_GRP_COUNT];
+
+		if (!dmx->init)
+			return;
+
+		if (dmx->sec_pages) {
+			grp_len[0] = (1 << SEC_GRP_LEN_0) * 8;
+			grp_len[1] = (1 << SEC_GRP_LEN_1) * 8;
+			grp_len[2] = (1 << SEC_GRP_LEN_2) * 8;
+			grp_len[3] = (1 << SEC_GRP_LEN_3) * 8;
+
+			grp_addr[0] = virt_to_phys((void *)dmx->sec_pages);
+			grp_addr[1] = grp_addr[0] + grp_len[0];
+			grp_addr[2] = grp_addr[1] + grp_len[1];
+			grp_addr[3] = grp_addr[2] + grp_len[2];
+
+			base = grp_addr[0] & 0xFFFF0000;
+			DMX_WRITE_REG(dmx->id, SEC_BUFF_BASE, base >> 16);
+			DMX_WRITE_REG(dmx->id, SEC_BUFF_01_START,
+					(((grp_addr[0] - base) >> 8) << 16) |
+					 ((grp_addr[1] - base) >> 8));
+			DMX_WRITE_REG(dmx->id, SEC_BUFF_23_START,
+					(((grp_addr[2] - base) >> 8) << 16) |
+					 ((grp_addr[3] - base) >> 8));
+			DMX_WRITE_REG(dmx->id, SEC_BUFF_SIZE,
+					SEC_GRP_LEN_0 |
+					(SEC_GRP_LEN_1 << 4) |
+					(SEC_GRP_LEN_2 << 8) |
+					(SEC_GRP_LEN_3 << 12));
+		}
+
+		if (dmx->sub_pages) {
+			addr = virt_to_phys((void *)dmx->sub_pages);
+			DMX_WRITE_REG(dmx->id, SB_START, addr >> 12);
+			DMX_WRITE_REG(dmx->id, SB_LAST_ADDR,
+				      (dmx->sub_buf_len >> 3) - 1);
+		}
+
+		if (dmx->pes_pages) {
+			addr = virt_to_phys((void *)dmx->pes_pages);
+			DMX_WRITE_REG(dmx->id, OB_START, addr >> 12);
+			DMX_WRITE_REG(dmx->id, OB_LAST_ADDR,
+				      (dmx->pes_buf_len >> 3) - 1);
+		}
+
+		for (n = 0; n < CHANNEL_COUNT; n++) {
+			struct aml_channel *chan = &dmx->channel[n];
+
+			if (!chan->used)
+			   chan->pid = 0x1fff;
+
+			dmx_set_chan_regs(dmx, n);
+		}
+
+		for (n = 0; n < FILTER_COUNT; n++) {
+			struct aml_filter *filter = &dmx->filter[n];
+
+			if (filter->used)
+				dmx_set_filter_regs(dmx, n);
+		}
+
+		dmx_enable(dmx);
+
+		dmx_smallsec_set(&dmx->smallsec,
+				dmx->smallsec.enable,
+				dmx->smallsec.bufsize,
+				1);
+
+		dmx_timeout_set(&dmx->timeout,
+				dmx->timeout.enable,
+				dmx->timeout.timeout,
+				dmx->timeout.ch_disable,
+				dmx->timeout.match,
+				1);
+	}
+	{
+		int id;
+		for(id=0; id<DSC_COUNT; id++)
+		{
+			struct aml_dsc *dsc = &dvb->dsc[id];
+
+			//if(dsc->used)
+			{
+				dsc_set_pid(dsc, dsc->pid);
+
+				if(dsc->set&1)
+					dsc_set_key(dsc, 0, dsc->even);
+				if(dsc->set&2)
+					dsc_set_key(dsc, 1, dsc->odd);
+			}
+		}
+	}
+#ifdef ENABLE_SEC_BUFF_WATCHDOG
+	if (reset_irq) {
+		/*mod_timer(&dvb->watchdog_timer,
+		jiffies+msecs_to_jiffies(WATCHDOG_TIMER)); */
+		dvb->dmx_watchdog_disable[dmx->id] = 0;
+	}
+#endif
+}
+
+void dmx_reset_dmx_id_hw_ex_unlock(struct aml_dvb *dvb, int id, int reset_irq)
+{
+	dmx_reset_dmx_hw_ex_unlock(dvb, &dvb->dmx[id], reset_irq);
+}
+
+void dmx_reset_dmx_hw_ex(struct aml_dvb *dvb, struct aml_dmx *dmx,
+			 int reset_irq)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	dmx_reset_dmx_hw_ex_unlock(dvb, dmx, reset_irq);
+	spin_unlock_irqrestore(&dvb->slock, flags);
+}
+
+void dmx_reset_dmx_id_hw_ex(struct aml_dvb *dvb, int id, int reset_irq)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	dmx_reset_dmx_id_hw_ex_unlock(dvb, id, reset_irq);
+	spin_unlock_irqrestore(&dvb->slock, flags);
+}
+
+void dmx_reset_dmx_hw(struct aml_dvb *dvb, int id)
+{
+	dmx_reset_dmx_id_hw_ex(dvb, id, 1);
+}
+
+void dmx_reset_dmx_sw(void)
+{
+	struct aml_dvb *dvb = aml_get_dvb_device();
+	int i;
+
+	for (i = 0; i < DMX_DEV_COUNT; i++)
+		dmx_reset_dmx_id_hw_ex(dvb, i, 0);
+}
+//EXPORT_SYMBOL(dmx_reset_dmx_sw);
+
+/*Allocate subtitle pes buffer*/
+static int alloc_subtitle_pes_buffer(struct aml_dmx *dmx)
+{
+	int start_ptr = 0;
+	struct stream_buf_s *sbuff = 0;
+	u32 phy_addr;
+	start_ptr = READ_MPEG_REG(PARSER_SUB_START_PTR);
+	if (start_ptr) {
+		WRITE_MPEG_REG(PARSER_SUB_RP, start_ptr);
+		goto exit;
+	}
+//	sbuff = get_stream_buffer(BUF_TYPE_SUBTITLE);
+	if (sbuff) {
+		if (sbuff->flag & BUF_FLAG_IOMEM)
+			phy_addr = sbuff->buf_start;
+		else
+			phy_addr = virt_to_phys((void *)sbuff->buf_start);
+
+		WRITE_MPEG_REG(PARSER_SUB_RP, phy_addr);
+		WRITE_MPEG_REG(PARSER_SUB_START_PTR, phy_addr);
+		WRITE_MPEG_REG(PARSER_SUB_END_PTR,
+			       phy_addr + sbuff->buf_size - 8);
+
+		pr_dbg("pes buff=:%x %x\n", phy_addr, sbuff->buf_size);
+	} else
+		pr_dbg("Error stream buffer\n");
+exit:
+	return 0;
+}
+
+/*Allocate a new channel*/
+int dmx_alloc_chan(struct aml_dmx *dmx, int type, int pes_type, int pid)
+{
+	int id = -1;
+	int ret;
+
+	if (type == DMX_TYPE_TS) {
+		switch (pes_type) {
+		case DMX_PES_VIDEO:
+			if (!dmx->channel[0].used)
+				id = 0;
+			break;
+		case DMX_PES_AUDIO:
+			if (!dmx->channel[1].used)
+				id = 1;
+			break;
+		case DMX_PES_SUBTITLE:
+		case DMX_PES_TELETEXT:
+			if (!dmx->channel[2].used)
+				id = 2;
+			alloc_subtitle_pes_buffer(dmx);
+			break;
+		case DMX_PES_PCR:
+			if (!dmx->channel[3].used)
+				id = 3;
+			break;
+		case DMX_PES_OTHER:
+			{
+				int i;
+				for (i = SYS_CHAN_COUNT;
+						i < CHANNEL_COUNT; i++) {
+					if (!dmx->channel[i].used) {
+						id = i;
+						break;
+					}
+				}
+			}
+			break;
+		default:
+			break;
+		}
+	} else {
+		int i;
+		for (i = SYS_CHAN_COUNT; i < CHANNEL_COUNT; i++) {
+			if (!dmx->channel[i].used) {
+				id = i;
+				break;
+			}
+		}
+	}
+
+	if (id == -1) {
+		pr_error("too many channels\n");
+		return -1;
+	}
+
+	pr_dbg("allocate channel(id:%d PID:%d)\n", id, pid);
+
+	if (id <= 3) {
+		ret = dmx_get_chan(dmx, pid);
+		if (ret >= 0 && DVR_FEED(dmx->channel[ret].feed)) {
+			dmx_remove_feed(dmx, dmx->channel[ret].feed);
+			dmx->channel[id].dvr_feed = dmx->channel[ret].feed;
+			dmx->channel[id].dvr_feed->priv = (void *)(long)id;
+		} else {
+			dmx->channel[id].dvr_feed = NULL;
+		}
+	}
+
+	dmx->channel[id].type = type;
+	dmx->channel[id].pes_type = pes_type;
+	dmx->channel[id].pid = pid;
+	dmx->channel[id].used = 1;
+	dmx->channel[id].filter_count = 0;
+
+	dmx_set_chan_regs(dmx, id);
+
+	set_debug_dmx_chanpids(dmx->id, id, pid);
+
+	dmx->chan_count++;
+
+	dmx_enable(dmx);
+
+	return id;
+}
+
+/*Free a channel*/
+void dmx_free_chan(struct aml_dmx *dmx, int cid)
+{
+	pr_dbg("free channel(id:%d PID:0x%x)\n", cid, dmx->channel[cid].pid);
+	dmx->channel[cid].used = 0;
+	dmx->channel[cid].pid = 0x1fff;
+	dmx_set_chan_regs(dmx, cid);
+
+	if (cid == 2) {
+		u32 parser_sub_start_ptr;
+
+		parser_sub_start_ptr = READ_MPEG_REG(PARSER_SUB_START_PTR);
+		WRITE_MPEG_REG(PARSER_SUB_RP, parser_sub_start_ptr);
+		WRITE_MPEG_REG(PARSER_SUB_WP, parser_sub_start_ptr);
+	}
+
+	set_debug_dmx_chanpids(dmx->id, cid, -1);
+	dmx->chan_count--;
+
+	dmx_enable(dmx);
+
+	/*Special pes type channel, check its dvr feed */
+	if (cid <= 3 && dmx->channel[cid].dvr_feed) {
+		/*start the dvr feed */
+		dmx_add_feed(dmx, dmx->channel[cid].dvr_feed);
+	}
+}
+
+/*Add a section*/
+static int dmx_chan_add_filter(struct aml_dmx *dmx, int cid,
+			       struct dvb_demux_filter *filter)
+{
+	int id = -1;
+	int i;
+
+	for (i = 0; i < FILTER_COUNT; i++) {
+		if (!dmx->filter[i].used) {
+			id = i;
+			break;
+		}
+	}
+
+	if (id == -1) {
+		pr_error("too many filters\n");
+		return -1;
+	}
+
+	pr_dbg("channel(id:%d PID:0x%x) add filter(id:%d)\n", cid,
+	       filter->feed->pid, id);
+
+	dmx->filter[id].chan_id = cid;
+	dmx->filter[id].used = 1;
+	dmx->filter[id].filter = (struct dmx_section_filter *)filter;
+	dmx->channel[cid].filter_count++;
+
+	dmx_set_filter_regs(dmx, id);
+
+	return id;
+}
+
+static void dmx_remove_filter(struct aml_dmx *dmx, int cid, int fid)
+{
+	pr_dbg("channel(id:%d PID:0x%x) remove filter(id:%d)\n", cid,
+	       dmx->channel[cid].pid, fid);
+	dmx->filter[fid].used = 0;
+	dmx->channel[cid].filter_count--;
+
+	dmx_set_filter_regs(dmx, fid);
+	dmx_clear_filter_buffer(dmx, fid);
+}
+
+static int sf_add_feed(struct aml_dmx *src_dmx, struct dvb_demux_feed *feed)
+{
+	int ret = 0;
+
+	struct aml_dvb *dvb = (struct aml_dvb *)src_dmx->demux.priv;
+	struct aml_swfilter *sf = &dvb->swfilter;
+
+	pr_dbg_sf("sf add pid[%d]\n", feed->pid);
+
+	/*init sf */
+	if (!sf->user) {
+		void *mem;
+		mem = vmalloc(SF_BUFFER_SIZE);
+		if (!mem)
+			return -ENOMEM;
+		dvb_ringbuffer_init(&sf->rbuf, mem, SF_BUFFER_SIZE);
+
+		sf->dmx = &dvb->dmx[SF_DMX_ID];
+		sf->afifo = &dvb->asyncfifo[SF_AFIFO_ID];
+
+		sf->dmx->source = src_dmx->source;
+		sf->afifo->source = sf->dmx->id;
+		sf->track_dmx = src_dmx->id;
+		/*sf->afifo->flush_size = 188*10; */
+
+		pr_dbg_sf("init sf mode.\n");
+
+	} else if (sf->dmx->source != src_dmx->source) {
+		pr_error(" pid=%d[src:%d] already used with sfdmx%d[src:%d]\n",
+			 feed->pid, src_dmx->source, sf->dmx->id,
+			 sf->dmx->source);
+		return -EBUSY;
+	}
+
+	/*setup feed */
+	ret = dmx_get_chan(sf->dmx, feed->pid);
+	if (ret >= 0) {
+		pr_error(" pid=%d[dmx:%d] already used [dmx:%d].\n",
+			 feed->pid, src_dmx->id,
+			 ((struct aml_dmx *)sf->dmx->channel[ret].feed->
+			 demux)->id);
+		return -EBUSY;
+	}
+	ret =
+	     dmx_alloc_chan(sf->dmx, DMX_TYPE_TS, DMX_PES_OTHER,
+			    feed->pid);
+	if (ret < 0) {
+		pr_error(" %s: alloc chan error, ret=%d\n", __func__, ret);
+		return ret;
+	}
+	sf->dmx->channel[ret].feed = feed;
+	feed->priv = (void *)(long)ret;
+
+	sf->dmx->channel[ret].dvr_feed = feed;
+
+	sf->user++;
+	debug_sf_user = sf->user;
+
+	dmx_enable(sf->dmx);
+
+	return 0;
+}
+
+static int sf_remove_feed(struct aml_dmx *src_dmx, struct dvb_demux_feed *feed)
+{
+	int ret;
+
+	struct aml_dvb *dvb = (struct aml_dvb *)src_dmx->demux.priv;
+	struct aml_swfilter *sf = &dvb->swfilter;
+
+	if (!sf->user || (sf->dmx->source != src_dmx->source))
+		return 0;
+
+	ret = dmx_get_chan(sf->dmx, feed->pid);
+	if (ret < 0)
+		return 0;
+
+	pr_dbg_sf("sf remove pid[%d]\n", feed->pid);
+
+	dmx_free_chan(sf->dmx, (long)feed->priv);
+
+	sf->dmx->channel[ret].feed = NULL;
+	sf->dmx->channel[ret].dvr_feed = NULL;
+
+	sf->user--;
+	debug_sf_user = sf->user;
+
+	if (!sf->user) {
+		sf->dmx->source = -1;
+		sf->afifo->source = AM_DMX_MAX;
+		sf->track_dmx = -1;
+		/*sf->afifo->flush_size = sf->afifo->buf_len>>1; */
+
+		if (sf->rbuf.data) {
+			void *mem = sf->rbuf.data;
+			sf->rbuf.data = NULL;
+			vfree(mem);
+		}
+		pr_dbg_sf("exit sf mode.\n");
+	}
+
+	return 0;
+}
+
+static int sf_feed_sf(struct aml_dmx *dmx, struct dvb_demux_feed *feed,
+		      int add_not_remove)
+{
+	int sf = 0;
+
+	if (sf_dmx_sf(dmx)) {
+		pr_error("%s: demux %d is in sf mode\n", __func__, dmx->id);
+		return -EINVAL;
+	}
+
+	switch (feed->type) {
+	case DMX_TYPE_TS:{
+			struct dmxdev_filter *dmxdevfilter =
+							 feed->feed.ts.priv;
+	pr_dbg("[pid:%d] ts_type:%x %x, %x\n", feed->pid, feed->ts_type, dmxdevfilter->params.pes.flags, DMX_USE_SWFILTER);
+			if (!DVR_FEED(feed)) {
+				if (dmxdevfilter->params.pes.
+				    flags & DMX_USE_SWFILTER)
+					sf = 1;
+				if (force_pes_sf)
+					sf = 1;
+			}
+		}
+		break;
+
+	case DMX_TYPE_SEC:{
+			struct dvb_demux_filter *filter;
+			for (filter = feed->filter; filter;
+			     filter = filter->next) {
+				struct dmxdev_filter *dmxdevfilter =
+				    filter->filter.priv;
+				if (dmxdevfilter->params.sec.
+				    flags & DMX_USE_SWFILTER)
+					sf = 1;
+				if (add_not_remove)
+					filter->hw_handle = (u16)-1;
+			}
+			if (force_sec_sf)
+				sf = 1;
+		}
+		break;
+	}
+
+	return sf ? 0 : 1;
+}
+
+static int sf_check_feed(struct aml_dmx *dmx, struct dvb_demux_feed *feed,
+			 int add_not_remove)
+{
+	int ret = 0;
+
+	ret = sf_feed_sf(dmx, feed, add_not_remove);
+	if (ret)
+		return ret;
+
+	pr_dbg_sf("%s [pid:%d] %s\n",
+		  (feed->type == DMX_TYPE_TS) ? "DMX_TYPE_TS" : "DMX_TYPE_SEC",
+		  feed->pid, add_not_remove ? "-> sf mode" : "sf mode ->");
+
+	if (add_not_remove)
+		ret = sf_add_feed(dmx, feed);
+	else
+		ret = sf_remove_feed(dmx, feed);
+
+	if (ret < 0) {
+		pr_error("sf %s feed fail[%d]\n",
+			 add_not_remove ? "add" : "remove", ret);
+	}
+	return ret;
+}
+
+static int dmx_add_feed(struct aml_dmx *dmx, struct dvb_demux_feed *feed)
+{
+	int id, ret = 0;
+	struct dvb_demux_filter *filter;
+	struct dvb_demux_feed *dfeed = NULL;
+	int sf_ret = 0;		/*<0:error, =0:sf_on, >0:sf_off */
+
+	sf_ret = sf_check_feed(dmx, feed, 1/*SF_FEED_OP_ADD */);
+	if (sf_ret < 0)
+		return sf_ret;
+
+	switch (feed->type) {
+	case DMX_TYPE_TS:
+
+		ret = dmx_get_chan(dmx, feed->pid);
+		pr_dbg("DMX_TYPE_TS pid:%d pes:%d ret:%d sf_ret:%d\n", feed->pid, feed->pes_type, ret, sf_ret);
+		if (ret >= 0) {
+			if (DVR_FEED(dmx->channel[ret].feed)) {
+				if (DVR_FEED(feed)) {
+					/*dvr feed already work */
+					pr_error("PID %d already used(DVR)\n",
+						 feed->pid);
+					return -EBUSY;
+				}
+				if (sf_ret) {
+					/*if sf_on, we do not reset the
+					previous dvr feed, just load the pes
+					feed on the sf, a diffrent data path.*/
+					dfeed = dmx->channel[ret].feed;
+					dmx_remove_feed(dmx, dfeed);
+				}
+			} else {
+				if (DVR_FEED(feed)
+				    && (!dmx->channel[ret].dvr_feed)) {
+					/*just store the dvr_feed */
+					dmx->channel[ret].dvr_feed = feed;
+					feed->priv = (void *)(long)ret;
+					if (!dmx->record)
+						dmx_enable(dmx);
+					dmx_add_recchan(dmx->id, ret);
+					return 0;
+				} else {
+					pr_error("PID %d already used\n",
+						 feed->pid);
+					return -EBUSY;
+				}
+			}
+		}
+
+		if (sf_ret) {	/*not sf feed. */
+			ret =
+			     dmx_alloc_chan(dmx, feed->type,
+						feed->pes_type, feed->pid);
+//			pr_dbg("alloc chan=%d\n", ret);
+			if (ret < 0) {
+				pr_dbg("alloc chan error, ret=%d\n", ret);
+				return ret;
+			}
+			dmx->channel[ret].feed = feed;
+			feed->priv = (void *)(long)ret;
+			dmx->channel[ret].dvr_feed = NULL;
+		}
+		/*dvr */
+		if (DVR_FEED(feed)) {
+			dmx->channel[ret].dvr_feed = feed;
+			feed->priv = (void *)(long)ret;
+			if (!dmx->record)
+				dmx_enable(dmx);
+			dmx_add_recchan(dmx->id, ret);
+		} else if (dfeed && sf_ret) {
+			dmx->channel[ret].dvr_feed = dfeed;
+			dfeed->priv = (void *)(long)ret;
+			if (!dmx->record)
+				dmx_enable(dmx);
+			dmx_add_recchan(dmx->id, ret);
+		}
+
+		break;
+	case DMX_TYPE_SEC: 
+		ret = dmx_get_chan(dmx, feed->pid);
+		pr_dbg("%s: DMX_TYPE_SEC ret:%d sf_ret:%d\n", __func__, ret, sf_ret);
+		if (ret >= 0) {
+			if (DVR_FEED(dmx->channel[ret].feed)) {
+				if (sf_ret) {
+					/*if sf_on, we do not reset the
+					previous dvr feed, just load the pes
+					feed on the sf,a diffrent data path.*/
+					dfeed = dmx->channel[ret].feed;
+					dmx_remove_feed(dmx, dfeed);
+				}
+			} else {
+				pr_error("PID %d already used\n", feed->pid);
+				return -EBUSY;
+			}
+		}
+		if (sf_ret) {	/*not sf feed. */
+			id = dmx_alloc_chan(dmx, feed->type,
+				feed->pes_type, feed->pid);
+//			pr_dbg("alloc chan=%d\n", id);
+			if (id < 0) {
+				pr_dbg("alloc chan error, ret=%d\n", id);
+				return id;
+			}
+			for (filter = feed->filter; filter;
+				filter = filter->next) {
+				ret = dmx_chan_add_filter(dmx, id, filter);
+				if (ret >= 0)
+					filter->hw_handle = ret;
+				else
+					filter->hw_handle = (u16)-1;
+			}
+			dmx->channel[id].feed = feed;
+			feed->priv = (void *)(long)id;
+			dmx->channel[id].dvr_feed = NULL;
+
+			if (dfeed) {
+				dmx->channel[id].dvr_feed = dfeed;
+				dfeed->priv = (void *)(long)id;
+				if (!dmx->record)
+					dmx_enable(dmx);
+				dmx_add_recchan(dmx->id, id);
+			}
+		}
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+
+	dmx->feed_count++;
+
+	return 0;
+}
+
+static int dmx_remove_feed(struct aml_dmx *dmx, struct dvb_demux_feed *feed)
+{
+	struct dvb_demux_filter *filter;
+	struct dvb_demux_feed *dfeed = NULL;
+
+	int sf_ret = 0;		/*<0:error, =0:sf_on, >0:sf_off */
+
+	sf_ret = sf_check_feed(dmx, feed, 0/*SF_FEED_OP_RM */);
+	if (sf_ret <= 0)
+		return sf_ret;
+
+	switch (feed->type) {
+	case DMX_TYPE_TS:
+		if (dmx->channel[(long)feed->priv].feed ==
+		    dmx->channel[(long)feed->priv].dvr_feed) {
+			dmx_rm_recchan(dmx->id, (long)feed->priv);
+			dmx_free_chan(dmx, (long)feed->priv);
+		} else {
+			if (feed == dmx->channel[(long)feed->priv].feed) {
+				dfeed = dmx->channel[(long)feed->priv].dvr_feed;
+				dmx_rm_recchan(dmx->id, (long)feed->priv);
+				dmx_free_chan(dmx, (long)feed->priv);
+				if (dfeed) {
+					/*start the dvr feed */
+					dmx_add_feed(dmx, dfeed);
+				}
+			} else if (feed ==
+				   dmx->channel[(long)feed->priv].dvr_feed) {
+				/*just remove the dvr_feed */
+				dmx->channel[(long)feed->priv].dvr_feed = NULL;
+				dmx_rm_recchan(dmx->id,	(long)feed->priv);
+				if (dmx->record) {
+					dmx_enable(dmx);
+				}
+			} else {
+				/*This must never happen */
+				pr_error("%s: unknown feed\n", __func__);
+				return -EINVAL;
+			}
+		}
+
+		break;
+	case DMX_TYPE_SEC:
+		for (filter = feed->filter; filter; filter = filter->next) {
+			if (filter->hw_handle != (u16)-1)
+				dmx_remove_filter(dmx, (long)feed->priv,
+						  (int)filter->hw_handle);
+		}
+
+		dfeed = dmx->channel[(long)feed->priv].dvr_feed;
+		dmx_rm_recchan(dmx->id, (long)feed->priv);
+		dmx_free_chan(dmx, (long)feed->priv);
+		if (dfeed) {
+			/*start the dvr feed */
+			dmx_add_feed(dmx, dfeed);
+		}
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+
+	dmx->feed_count--;
+	return 0;
+}
+
+int aml_dmx_hw_init(struct aml_dmx *dmx)
+{
+	struct aml_dvb *dvb = (struct aml_dvb *)dmx->demux.priv;
+	unsigned long flags;
+	int ret;
+
+	/*Demux initialize */
+	spin_lock_irqsave(&dvb->slock, flags);
+	ret = dmx_init(dmx);
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return ret;
+}
+
+int aml_dmx_hw_deinit(struct aml_dmx *dmx)
+{
+	struct aml_dvb *dvb = (struct aml_dvb *)dmx->demux.priv;
+	unsigned long flags;
+	int ret;
+	spin_lock_irqsave(&dvb->slock, flags);
+	ret = dmx_deinit(dmx);
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return ret;
+}
+
+/*extern void afifo_reset(int v);*/
+
+int aml_asyncfifo_hw_init(struct aml_asyncfifo *afifo)
+{
+	struct aml_dvb *dvb = afifo->dvb;
+	unsigned long flags;
+	int ret;
+
+	int len = ASYNCFIFO_BUFFER_SIZE_DEFAULT;
+	unsigned long buf = asyncfifo_alloc_buffer(len);
+	if (!buf)
+		return -1;
+
+	/*Async FIFO initialize*/
+	spin_lock_irqsave(&dvb->slock, flags);
+
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+	CLK_GATE_ON(ASYNC_FIFO);
+#endif
+
+	WRITE_MPEG_REG(RESET6_REGISTER, (1<<11)|(1<<12));
+
+	ret = async_fifo_init(afifo, 1, len, buf);
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	if (ret < 0)
+		asyncfifo_free_buffer(buf, len);
+
+	return ret;
+}
+
+int aml_asyncfifo_hw_deinit(struct aml_asyncfifo *afifo)
+{
+	pr_dbg("%s\n",__func__);
+	struct aml_dvb *dvb = afifo->dvb;
+	unsigned long flags;
+	int ret;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	ret = async_fifo_deinit(afifo, 1);
+
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+	CLK_GATE_OFF(ASYNC_FIFO);
+#endif
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return ret;
+}
+
+int aml_asyncfifo_hw_reset(struct aml_asyncfifo *afifo)
+{
+	pr_dbg("%s\n",__func__);
+	struct aml_dvb *dvb = afifo->dvb;
+	unsigned long flags;
+	int ret, src = -1;
+
+	int len = ASYNCFIFO_BUFFER_SIZE_DEFAULT;
+	unsigned long buf = asyncfifo_alloc_buffer(len);
+	if (!buf)
+		return -1;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	if (afifo->init) {
+		src = afifo->source;
+		async_fifo_deinit(afifo, 0);
+	}
+	ret = async_fifo_init(afifo, 0, len, buf);
+	/* restore the source */
+	if (src != -1)
+		afifo->source = src;
+
+	if ((ret == 0) && afifo->dvb)
+		reset_async_fifos(afifo->dvb);
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	if (ret < 0)
+		asyncfifo_free_buffer(buf, len);
+
+	return ret;
+}
+
+int aml_dmx_hw_start_feed(struct dvb_demux_feed *dvbdmxfeed)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+	struct aml_dmx *dmx = (struct aml_dmx *)dvbdmxfeed->demux;
+	struct aml_dvb *dvb = (struct aml_dvb *)dmx->demux.priv;
+	unsigned long flags;
+	int ret = 0;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	ret = dmx_add_feed(dmx, dvbdmxfeed);
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return ret;
+}
+
+int aml_dmx_hw_stop_feed(struct dvb_demux_feed *dvbdmxfeed)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+	struct aml_dmx *dmx = (struct aml_dmx *)dvbdmxfeed->demux;
+	struct aml_dvb *dvb = (struct aml_dvb *)dmx->demux.priv;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	dmx_remove_feed(dmx, dvbdmxfeed);
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return 0;
+}
+
+int sf_dmx_track_source(struct aml_dmx *dmx)
+{
+	struct aml_dvb *dvb = (struct aml_dvb *)dmx->demux.priv;
+	struct aml_swfilter *sf = &dvb->swfilter;
+	if (sf->user && (dmx->id == sf->track_dmx)) {
+		pr_dbg_sf("tracking dmx src [%d -> %d]\n",
+			  sf->dmx->source, dmx->source);
+		sf->dmx->source = dmx->source;
+		dmx_reset_dmx_hw_ex_unlock(dvb, sf->dmx, 0);
+	}
+	return 0;
+}
+
+int aml_dmx_hw_set_source(struct dmx_demux *demux, dmx_source_t src)
+{
+	struct aml_dmx *dmx = (struct aml_dmx *)demux;
+	struct aml_dvb *dvb = (struct aml_dvb *)dmx->demux.priv;
+	int ret = 0;
+	int hw_src;
+	unsigned long flags;
+
+	if (sf_dmx_sf(dmx)) {
+		pr_error("%s: demux %d is in sf mode\n", __func__, dmx->id);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	hw_src = dmx->source;
+
+	switch (src) {
+	case DMX_SOURCE_FRONT0:
+		hw_src =
+		    (dvb->ts[0].mode ==
+		     AM_TS_SERIAL) ? AM_TS_SRC_S_TS0 : AM_TS_SRC_TS0;
+		break;
+	case DMX_SOURCE_FRONT1:
+		hw_src =
+		    (dvb->ts[1].mode ==
+		     AM_TS_SERIAL) ? AM_TS_SRC_S_TS1 : AM_TS_SRC_TS1;
+		break;
+	case DMX_SOURCE_FRONT2:
+		hw_src =
+		    (dvb->ts[2].mode ==
+		     AM_TS_SERIAL) ? AM_TS_SRC_S_TS2 : AM_TS_SRC_TS2;
+		break;
+	case DMX_SOURCE_DVR0:
+		hw_src = AM_TS_SRC_HIU;
+		break;
+	default:
+		pr_error("illegal demux source %d\n", src);
+		ret = -EINVAL;
+		break;
+	}
+	pr_dbg("src:%d hw_src:%d dmx->source:%d\n",
+						src, hw_src, dmx->source);
+
+	if (hw_src != dmx->source) {
+		dmx->source = hw_src;
+		dmx_reset_dmx_hw_ex_unlock(dvb, dmx, 0);
+		sf_dmx_track_source(dmx);
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return ret;
+}
+
+#define IS_SRC_DMX(_src) ((_src) >= AM_TS_SRC_DMX0 && (_src) <= AM_TS_SRC_DMX2)
+
+int aml_stb_hw_set_source(struct aml_dvb *dvb, dmx_source_t src)
+{
+	unsigned long flags;
+	int hw_src;
+	int ret;
+	ret = 0;
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	hw_src = dvb->stb_source;
+
+	switch (src) {
+	case DMX_SOURCE_FRONT0:
+		hw_src =
+		    (dvb->ts[0].mode ==
+		     AM_TS_SERIAL) ? AM_TS_SRC_S_TS0 : AM_TS_SRC_TS0;
+		break;
+	case DMX_SOURCE_FRONT1:
+		hw_src =
+		    (dvb->ts[1].mode ==
+		     AM_TS_SERIAL) ? AM_TS_SRC_S_TS1 : AM_TS_SRC_TS1;
+		break;
+	case DMX_SOURCE_FRONT2:
+		hw_src =
+		    (dvb->ts[2].mode ==
+		     AM_TS_SERIAL) ? AM_TS_SRC_S_TS2 : AM_TS_SRC_TS2;
+		break;
+	case DMX_SOURCE_DVR0:
+		hw_src = AM_TS_SRC_HIU;
+		break;
+	case DMX_SOURCE_FRONT0 + 100:
+		hw_src = AM_TS_SRC_DMX0;
+		break;
+	case DMX_SOURCE_FRONT1 + 100:
+		hw_src = AM_TS_SRC_DMX1;
+		break;
+	case DMX_SOURCE_FRONT2 + 100:
+		hw_src = AM_TS_SRC_DMX2;
+		break;
+	default:
+		pr_error("illegal demux source %d\n", src);
+		ret = -EINVAL;
+		break;
+	}
+	pr_dbg("src:%d hw_src:%d dvb->stb_source:%d\n",
+						src, hw_src, dvb->stb_source);
+
+	if (dvb->stb_source != hw_src) {
+		int old_source = dvb->stb_source;
+		dvb->stb_source = hw_src;
+
+		if (IS_SRC_DMX(old_source)) {
+			dmx_set_misc_id(dvb,
+				(old_source - AM_TS_SRC_DMX0), 0, -1);
+		} else {
+			/*which dmx for av-play is unknown,
+			can't avoid reset-all */
+			dmx_reset_hw_ex(dvb, 0);
+		}
+
+		if (IS_SRC_DMX(dvb->stb_source)) {
+			dmx_set_misc_id(dvb,
+				(dvb->stb_source - AM_TS_SRC_DMX0), 1, -1);
+			/*dmx_reset_dmx_id_hw_ex_unlock
+			   (dvb, (dvb->stb_source-AM_TS_SRC_DMX0), 0); */
+		} else {
+			/*which dmx for av-play is unknown,
+			can't avoid reset-all */
+			dmx_reset_hw_ex(dvb, 0);
+		}
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return ret;
+}
+
+int aml_dsc_hw_set_source(struct aml_dvb *dvb, dmx_source_t src)
+{
+	int ret = 0;
+	unsigned long flags;
+	int hw_src = -1; //, hw_dst = -1, org_src = -1, org_dst = -1;
+//	int src_reset = 0, dst_reset = 0;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	hw_src = dvb->dsc_source;
+
+	switch (src) {
+	case DMX_SOURCE_FRONT0 + 100:
+		hw_src = AM_TS_SRC_DMX0;
+		break;
+	case DMX_SOURCE_FRONT1 + 100:
+		hw_src = AM_TS_SRC_DMX1;
+		break;
+	case DMX_SOURCE_FRONT2 + 100:
+		hw_src = AM_TS_SRC_DMX2;
+		break;
+	default:
+		hw_src = -1;
+		break;
+	}
+	if(hw_src != dvb->dsc_source){
+		int old_source = dvb->dsc_source;
+		dvb->dsc_source = hw_src;
+		if(old_source != -1)
+			dmx_reset_dmx_id_hw_ex_unlock(dvb, (old_source-AM_TS_SRC_DMX0), 0);
+		if(hw_src != -1)
+			dmx_reset_dmx_id_hw_ex_unlock(dvb, (hw_src-AM_TS_SRC_DMX0), 0);
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return ret;
+}
+
+int aml_tso_hw_set_source(struct aml_dvb *dvb, dmx_source_t src)
+{
+	int ret = 0;
+	unsigned long flags;
+	int hw_src;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	hw_src = dvb->tso_source;
+
+	switch (src) {
+	case DMX_SOURCE_FRONT0:
+		hw_src = (dvb->ts[0].mode == AM_TS_SERIAL)
+		    ? AM_TS_SRC_S_TS0 : AM_TS_SRC_TS0;
+		break;
+	case DMX_SOURCE_FRONT1:
+		hw_src = (dvb->ts[1].mode == AM_TS_SERIAL)
+		    ? AM_TS_SRC_S_TS1 : AM_TS_SRC_TS1;
+		break;
+	case DMX_SOURCE_FRONT2:
+		hw_src = (dvb->ts[2].mode == AM_TS_SERIAL)
+		    ? AM_TS_SRC_S_TS2 : AM_TS_SRC_TS2;
+		break;
+	case DMX_SOURCE_DVR0:
+		hw_src = AM_TS_SRC_HIU;
+		break;
+	case DMX_SOURCE_FRONT0 + 100:
+		hw_src = AM_TS_SRC_DMX0;
+		break;
+	case DMX_SOURCE_FRONT1 + 100:
+		hw_src = AM_TS_SRC_DMX1;
+		break;
+	case DMX_SOURCE_FRONT2 + 100:
+		hw_src = AM_TS_SRC_DMX2;
+		break;
+	default:
+		hw_src = -1;
+		ret = -EINVAL;
+		break;
+	}
+	pr_dbg("src:%d hw_src:%d dvb->tso_source:%d\n",
+						src, hw_src, dvb->tso_source);
+
+	if (hw_src != dvb->tso_source) {
+		dvb->tso_source = hw_src;
+		stb_enable(dvb);
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return ret;
+}
+
+int aml_asyncfifo_hw_set_source(struct aml_asyncfifo *afifo,
+				enum aml_dmx_id_t src)
+{
+	struct aml_dvb *dvb = afifo->dvb;
+	int ret = -1;
+	unsigned long flags;
+
+	if (sf_afifo_sf(afifo)) {
+		pr_error("%s: afifo %d is in sf mode\n", __func__, afifo->id);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	switch (src) {
+	case AM_DMX_0:
+	case AM_DMX_1:
+	case AM_DMX_2:
+		if (afifo->source != src) {
+			afifo->source = src;
+			ret = 0;
+		}
+		break;
+	default:
+		pr_error("illegal async fifo source %d\n", src);
+		ret = -EINVAL;
+		break;
+	}
+	pr_dbg("asyncfifo %d set source %d->%d\n",
+						afifo->id, afifo->source, src);
+
+	if (ret == 0 && afifo->dvb)
+		reset_async_fifos(afifo->dvb);
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return ret;
+}
+
+int aml_dmx_hw_set_dump_ts_select(struct dmx_demux *demux, int dump_ts_select)
+{
+	struct aml_dmx *dmx = (struct aml_dmx *)demux;
+	struct aml_dvb *dvb = (struct aml_dvb *)dmx->demux.priv;
+	int ret = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	dump_ts_select = !!dump_ts_select;
+	if (dmx->dump_ts_select != dump_ts_select) {
+		dmx->dump_ts_select = dump_ts_select;
+		dmx_reset_dmx_hw_ex_unlock(dvb, dmx, 0);
+	}
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return ret;
+}
+
+u32 aml_dmx_get_video_pts(struct aml_dvb *dvb)
+{
+	unsigned long flags;
+	u32 pts;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	pts = video_pts;
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return pts;
+}
+
+u32 aml_dmx_get_audio_pts(struct aml_dvb *dvb)
+{
+	unsigned long flags;
+	u32 pts;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	pts = audio_pts;
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return pts;
+}
+
+u32 aml_dmx_get_first_video_pts(struct aml_dvb *dvb)
+{
+	unsigned long flags;
+	u32 pts;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	pts = first_video_pts;
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return pts;
+}
+
+u32 aml_dmx_get_first_audio_pts(struct aml_dvb *dvb)
+{
+	unsigned long flags;
+	u32 pts;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	pts = first_audio_pts;
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return pts;
+}
+
+int aml_dmx_set_skipbyte(struct aml_dvb *dvb, int skipbyte)
+{
+	if (demux_skipbyte != skipbyte) {
+		pr_dbg("set skip byte %d\n", skipbyte);
+		demux_skipbyte = skipbyte;
+		dmx_reset_hw_ex(dvb, 0);
+	}
+
+	return 0;
+}
+
+int aml_dmx_set_demux(struct aml_dvb *dvb, int id)
+{
+	aml_stb_hw_set_source(dvb, DMX_SOURCE_DVR0);
+	if (id < DMX_DEV_COUNT) {
+		struct aml_dmx *dmx = &dvb->dmx[id];
+		aml_dmx_hw_set_source((struct dmx_demux *)dmx,
+							DMX_SOURCE_DVR0);
+	}
+
+	return 0;
+}
+
+int _set_tsfile_clkdiv(struct aml_dvb *dvb, int clkdiv)
+{
+	if (tsfile_clkdiv != clkdiv) {
+		pr_dbg("set ts file clock div %d\n", clkdiv);
+		tsfile_clkdiv = clkdiv;
+		dmx_reset_hw(dvb);
+	}
+
+	return 0;
+}
+
+static ssize_t stb_set_tsfile_clkdiv(struct class *class,
+				     struct class_attribute *attr,
+				     const char *buf, size_t size)
+{
+	/*int div = (int)simple_strtol(buf, NULL, 10);*/
+	long div;
+	if (kstrtol(buf, 0, &div) == 0)
+		_set_tsfile_clkdiv(aml_get_dvb_device(), (int)div);
+	return size;
+}
+
+static ssize_t stb_get_tsfile_clkdiv(struct class *class,
+				     struct class_attribute *attr, char *buf)
+{
+	ssize_t ret;
+	ret = sprintf(buf, "%d\n", tsfile_clkdiv);
+	return ret;
+}
+
+
+static int dmx_id=0;
+
+static ssize_t dmx_smallsec_show(struct class *class,
+				     struct class_attribute *attr, char *buf)
+{
+	ssize_t ret;
+	struct aml_dvb *dvb = aml_get_dvb_device();
+	ret = sprintf(buf, "%d:%d\n", dvb->dmx[dmx_id].smallsec.enable,
+					dvb->dmx[dmx_id].smallsec.bufsize);
+	return ret;
+}
+static ssize_t dmx_smallsec_store(struct class *class,
+				     struct class_attribute *attr,
+				     const char *buf, size_t size)
+{
+	int i, e, s = 0, f = 0;
+	struct aml_dvb *dvb = aml_get_dvb_device();
+
+	i = sscanf(buf, "%d:%i:%d", &e, &s, &f);
+	if (i <= 0)
+		return size;
+
+	dmx_smallsec_set(&dvb->dmx[dmx_id].smallsec, e, s, f);
+	return size;
+}
+
+static ssize_t dmx_timeout_show(struct class *class,
+				     struct class_attribute *attr, char *buf)
+{
+	ssize_t ret;
+	struct aml_dvb *dvb = aml_get_dvb_device();
+	ret = sprintf(buf, "%d:%d:0x%x:%d:%d\n",
+				dvb->dmx[dmx_id].timeout.enable,
+				dvb->dmx[dmx_id].timeout.timeout,
+				dvb->dmx[dmx_id].timeout.ch_disable,
+				dvb->dmx[dmx_id].timeout.match,
+		(DMX_READ_REG(dmx_id, STB_INT_STATUS)&(1<<INPUT_TIME_OUT)) ?
+			1 : 0);
+	DMX_WRITE_REG(dmx_id, STB_INT_STATUS, (1<<INPUT_TIME_OUT));
+	return ret;
+}
+static ssize_t dmx_timeout_store(struct class *class,
+				     struct class_attribute *attr,
+				     const char *buf, size_t size)
+{
+	int i, e, t = 0, c = 0, m = 0, f = 0;
+	struct aml_dvb *dvb = aml_get_dvb_device();
+
+	i = sscanf(buf, "%d:%i:%i:%d:%d", &e, &t, &c, &m, &f);
+	if (i <= 0)
+		return size;
+
+	dmx_timeout_set(&dvb->dmx[dmx_id].timeout, e, t, c, m, f);
+	return size;
+}
+
+
+#define DEMUX_SCAMBLE_FUNC_DECL(i)  \
+static ssize_t dmx_reg_value_show_demux##i##_scramble(struct class *class,  \
+struct class_attribute *attr, char *buf)\
+{\
+	int data = 0;\
+	int aflag = 0;\
+	int vflag = 0;\
+	ssize_t ret = 0;\
+	data = DMX_READ_REG(i, DEMUX_SCRAMBLING_STATE);\
+	if ((data & 0x01) == 0x01) \
+		vflag = 1;\
+	if ((data & 0x02) == 0x02) \
+		aflag = 1;\
+	ret = sprintf(buf, "%d %d\n", vflag, aflag);\
+	return ret;\
+}
+
+#if DMX_DEV_COUNT > 0
+DEMUX_SCAMBLE_FUNC_DECL(0)
+#endif
+#if DMX_DEV_COUNT > 1
+DEMUX_SCAMBLE_FUNC_DECL(1)
+#endif
+#if DMX_DEV_COUNT > 2
+DEMUX_SCAMBLE_FUNC_DECL(2)
+#endif
+
+static ssize_t dmx_reg_addr_show_source(struct class *class, struct class_attribute *attr,char *buf);
+static ssize_t dmx_reg_addr_store_source(struct class *class,struct class_attribute *attr,
+                          const char *buf,
+                          size_t size);
+static ssize_t dmx_id_show_source(struct class *class, struct class_attribute *attr,char *buf);
+static ssize_t dmx_id_store_source(struct class *class,struct class_attribute *attr,
+                          const char *buf,
+                          size_t size);
+static ssize_t dmx_reg_value_show_source(struct class *class, struct class_attribute *attr,char *buf);
+static ssize_t dmx_reg_value_store_source(struct class *class,struct class_attribute *attr,
+                          const char *buf,
+                          size_t size);
+static int reg_addr;
+//static int dmx_id=0;
+static struct class_attribute aml_dmx_class_attrs[] = {
+	__ATTR(dmx_id, S_IRUGO | S_IWUSR, dmx_id_show_source,
+	       dmx_id_store_source),
+	__ATTR(register_addr, S_IRUGO | S_IWUSR, dmx_reg_addr_show_source,
+	       dmx_reg_addr_store_source),
+	__ATTR(register_value, S_IRUGO | S_IWUSR, dmx_reg_value_show_source,
+	       dmx_reg_value_store_source),
+	__ATTR(tsfile_clkdiv, S_IRUGO | S_IWUSR, stb_get_tsfile_clkdiv,
+	       stb_set_tsfile_clkdiv),
+
+#define DEMUX_SCAMBLE_ATTR_DECL(i)\
+		__ATTR(demux##i##_scramble,  S_IRUGO | S_IWUSR, \
+		dmx_reg_value_show_demux##i##_scramble, NULL)
+#if DMX_DEV_COUNT > 0
+	DEMUX_SCAMBLE_ATTR_DECL(0),
+#endif
+#if DMX_DEV_COUNT > 1
+	DEMUX_SCAMBLE_ATTR_DECL(1),
+#endif
+#if DMX_DEV_COUNT > 2
+	DEMUX_SCAMBLE_ATTR_DECL(2),
+#endif
+
+	__ATTR(dmx_smallsec,  S_IRUGO | S_IWUSR,
+			dmx_smallsec_show,
+			dmx_smallsec_store),
+	__ATTR(dmx_timeout,  S_IRUGO | S_IWUSR,
+			dmx_timeout_show,
+			dmx_timeout_store),
+
+	__ATTR_NULL
+};
+
+static struct class aml_dmx_class = {
+	.name = "dmx",
+	.class_attrs = aml_dmx_class_attrs,
+};
+
+static ssize_t dmx_id_show_source(struct class *class,
+				  struct class_attribute *attr, char *buf)
+{
+	int ret;
+	ret = sprintf(buf, "%d\n", dmx_id);
+	return ret;
+}
+
+static ssize_t dmx_id_store_source(struct class *class,
+				   struct class_attribute *attr,
+				   const char *buf, size_t size)
+{
+	int id = 0;
+	long value = 0;
+	if (kstrtol(buf, 0, &value) == 0)
+		id = (int)value;
+	/*id = simple_strtol(buf, 0, 16);*/
+
+	if (id < 0 || id > 2)
+		pr_dbg("dmx id must 0 ~2\n");
+	else
+		dmx_id = id;
+
+	return size;
+}
+
+static ssize_t dmx_reg_addr_show_source(struct class *class,
+					struct class_attribute *attr,
+					 char *buf)
+{
+	int ret;
+	ret = sprintf(buf, "%x\n", reg_addr);
+	return ret;
+}
+
+static ssize_t dmx_reg_addr_store_source(struct class *class,
+					 struct class_attribute *attr,
+					 const char *buf, size_t size)
+{
+	int addr = 0;
+	/*addr = simple_strtol(buf, 0, 16);*/
+	long value = 0;
+	if (kstrtol(buf, 0, &value) == 0)
+		addr = (int)value;
+	reg_addr = addr;
+	return size;
+}
+
+static ssize_t dmx_reg_value_show_source(struct class *class,
+					 struct class_attribute *attr,
+					 char *buf)
+{
+	int ret, value;
+	value = READ_MPEG_REG(reg_addr);
+	ret = sprintf(buf, "%x\n", value);
+	return ret;
+}
+
+static ssize_t dmx_reg_value_store_source(struct class *class,
+					  struct class_attribute *attr,
+					  const char *buf, size_t size)
+{
+	int value = 0;
+	/*value = simple_strtol(buf, 0, 16);*/
+	long val = 0;
+	if (kstrtol(buf, 0, &val) == 0)
+		value = (int)val;
+	WRITE_MPEG_REG(reg_addr, value);
+	return size;
+}
+
+int aml_regist_dmx_class(void)
+{
+
+	if (class_register(&aml_dmx_class) < 0)
+		pr_error("register class error\n");
+
+	return 0;
+}
+
+int aml_unregist_dmx_class(void)
+{
+
+	class_unregister(&aml_dmx_class);
+	return 0;
+}
+
+static struct aml_dmx *get_dmx_from_src(enum aml_ts_source_t src)
+{
+	int i;
+	struct aml_dvb *dvb = aml_get_dvb_device();
+	struct aml_dmx *dmx = NULL;
+
+	if (dvb) {
+		switch (src) {
+		case AM_TS_SRC_TS0:
+		case AM_TS_SRC_TS1:
+		case AM_TS_SRC_TS2:
+		case AM_TS_SRC_S_TS0:
+		case AM_TS_SRC_S_TS1:
+		case AM_TS_SRC_S_TS2:
+			for (i = 0; i < DMX_DEV_COUNT; i++) {
+				if (dvb->dmx[i].source == src) {
+					dmx = &dvb->dmx[i];
+					break;
+				}
+				break;
+		case AM_TS_SRC_DMX0:
+				/*if (0 > DMX_DEV_COUNT) */
+				/*dmx = &dvb->dmx[0]; */
+				break;
+		case AM_TS_SRC_DMX1:
+				/*if (1 > DMX_DEV_COUNT) */
+				/*dmx = &dvb->dmx[1]; */
+				break;
+		case AM_TS_SRC_DMX2:
+				/*if (2 > DMX_DEV_COUNT) */
+				/*dmx = &dvb->dmx[2]; */
+				break;
+		default:
+				break;
+			}
+		}
+	}
+	return dmx;
+
+}
+
+void aml_dmx_register_frontend(enum aml_ts_source_t src,
+			       struct dvb_frontend *fe)
+{
+	unsigned long flags;
+	struct aml_dvb *dvb = aml_get_dvb_device();
+	struct aml_dmx *dmx = get_dmx_from_src(src);
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	if (dmx)
+		dmx->fe = fe;
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+}
+
+void aml_dmx_before_retune(enum aml_ts_source_t src, struct dvb_frontend *fe)
+{
+	unsigned long flags;
+	struct aml_dvb *dvb = aml_get_dvb_device();
+	struct aml_dmx *dmx = get_dmx_from_src(src);
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	if (dmx) {
+		dmx->fe = fe;
+		dmx->in_tune = 1;
+		DMX_WRITE_REG(dmx->id, STB_INT_MASK, 0);
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+}
+
+void aml_dmx_after_retune(enum aml_ts_source_t src, struct dvb_frontend *fe)
+{
+	unsigned long flags;
+	struct aml_dvb *dvb = aml_get_dvb_device();
+	struct aml_dmx *dmx = get_dmx_from_src(src);
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	if (dmx) {
+		dmx->fe = fe;
+		dmx->in_tune = 0;
+		DMX_WRITE_REG(dmx->id, STB_INT_MASK, DEMUX_INT_MASK);
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+}
+
+void aml_dmx_start_error_check(enum aml_ts_source_t src,
+			       struct dvb_frontend *fe)
+{
+	unsigned long flags;
+	struct aml_dvb *dvb = aml_get_dvb_device();
+	struct aml_dmx *dmx = get_dmx_from_src(src);
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	if (dmx) {
+		dmx->fe = fe;
+		dmx->error_check = 0;
+		dmx->int_check_time = 0;
+		DMX_WRITE_REG(dmx->id, STB_INT_MASK, DEMUX_INT_MASK);
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+}
+
+int aml_dmx_stop_error_check(enum aml_ts_source_t src, struct dvb_frontend *fe)
+{
+	unsigned long flags;
+	int ret = 0;
+
+	struct aml_dvb *dvb = aml_get_dvb_device();
+	struct aml_dmx *dmx = get_dmx_from_src(src);
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	if (dmx) {
+		dmx->fe = fe;
+		ret = dmx->error_check;
+		DMX_WRITE_REG(dmx->id, STB_INT_MASK, DEMUX_INT_MASK);
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return ret;
+}
+//EXPORT_SYMBOL(aml_dmx_stop_error_check);
diff -Nur linux-95ba9d626c0fce672caa296f5911ab9190881642/drivers/amlogic/dvb-avl/aml_dvb.c linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/drivers/amlogic/dvb-avl/aml_dvb.c
--- linux-95ba9d626c0fce672caa296f5911ab9190881642/drivers/amlogic/dvb-avl/aml_dvb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/drivers/amlogic/dvb-avl/aml_dvb.c	2019-02-16 00:06:25.185126123 +0100
@@ -0,0 +1,1693 @@
+/*
+ * AMLOGIC DVB driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ */
+
+#define ENABLE_DEMUX_DRIVER
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/wait.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/spinlock.h>
+#include <linux/fcntl.h>
+#include <asm/irq.h>
+#include <linux/uaccess.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/amlogic/amports/amstream.h>
+#ifdef ARC_700
+#include <asm/arch/am_regs.h>
+#else
+#include <mach/am_regs.h>
+#include <mach/c_stb_define.h>
+#endif
+
+#include <mach/io.h>
+#include <plat/io.h>
+
+#include <mach/mod_gate.h>
+#include <linux/gpio.h>
+#include <linux/spinlock.h>
+#include <linux/amlogic/amdsc.h>
+#include <linux/string.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+
+#include <linux/reset.h>
+
+#include "aml_dvb.h"
+
+#define pr_dbg(fmt, args...)\
+	do {\
+		if (debug_dvb)\
+			printk("DVB: %s: " fmt, __func__, ## args);\
+	} while (0)
+#define pr_error(fmt, args...) printk("DVB: %s: " fmt, __func__, ## args)
+#define pr_inf(fmt, args...)   printk("DVB: %s: " fmt, __func__, ## args)
+
+MODULE_PARM_DESC(debug_dvb, "\n\t\t Enable dvb debug information");
+static int debug_dvb = 0;
+module_param(debug_dvb, int, 0644);
+
+#define CARD_NAME "amlogic-dvb"
+
+DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
+
+#define BUF_MAX_NUM         5
+
+#include "../amports/streambuf.h"
+
+static struct aml_dvb aml_dvb_device;
+#ifdef CONFIG_ARM64
+static struct reset_control *aml_dvb_demux_reset_ctl;
+static struct reset_control *aml_dvb_afifo_reset_ctl;
+static struct reset_control *aml_dvb_ahbarb0_reset_ctl;
+static struct reset_control *aml_dvb_uparsertop_reset_ctl;
+#endif
+extern void dmx_reset_dmx_sw(void);
+
+static int aml_tsdemux_reset(void);
+static int aml_tsdemux_set_reset_flag(void);
+static int aml_tsdemux_request_irq(irq_handler_t handler, void *data);
+static int aml_tsdemux_free_irq(void);
+static int aml_tsdemux_set_vid(int vpid);
+static int aml_tsdemux_set_aid(int apid);
+static int aml_tsdemux_set_sid(int spid);
+static int aml_tsdemux_set_pcrid(int pcrpid);
+static int aml_tsdemux_set_skipbyte(int skipbyte);
+static int aml_tsdemux_set_demux(int id);
+
+#if 1
+static struct tsdemux_ops aml_tsdemux_ops = {
+.reset          = aml_tsdemux_reset,
+.set_reset_flag = aml_tsdemux_set_reset_flag,
+.request_irq    = aml_tsdemux_request_irq,
+.free_irq       = aml_tsdemux_free_irq,
+.set_vid        = aml_tsdemux_set_vid,
+.set_aid        = aml_tsdemux_set_aid,
+.set_sid        = aml_tsdemux_set_sid,
+.set_pcrid      = aml_tsdemux_set_pcrid,
+.set_skipbyte   = aml_tsdemux_set_skipbyte,
+.set_demux      = aml_tsdemux_set_demux
+};
+#endif
+static struct class   aml_stb_class;
+
+static int control_ts_on_csi_port(int tsin, int enable)
+{
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+	unsigned int temp_data;
+	if(tsin==2 && enable) {
+		//TS2 is on CSI port.
+		//power on mipi csi phy
+		pr_error("power on mipi csi phy for TSIN2\n");
+		WRITE_CBUS_REG(HHI_CSI_PHY_CNTL0,0xfdc1ff81);
+		WRITE_CBUS_REG(HHI_CSI_PHY_CNTL1,0x3fffff);
+		temp_data = READ_CBUS_REG(HHI_CSI_PHY_CNTL2);
+		temp_data &= 0x7ff00000;
+		temp_data |= 0x80000fc0;
+		WRITE_CBUS_REG(HHI_CSI_PHY_CNTL2,temp_data);
+	}
+#endif
+	return 0;
+}
+
+static void aml_dvb_dmx_release(struct aml_dvb *advb, struct aml_dmx *dmx)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+	int i;
+
+	dvb_net_release(&dmx->dvb_net);
+	aml_dmx_hw_deinit(dmx);
+	dmx->demux.dmx.close(&dmx->demux.dmx);
+	dmx->demux.dmx.remove_frontend(&dmx->demux.dmx, &dmx->mem_fe);
+
+	for (i=0; i<DMX_DEV_COUNT; i++) {
+		dmx->demux.dmx.remove_frontend(&dmx->demux.dmx, &dmx->hw_fe[i]);
+	}
+
+	dvb_dmxdev_release(&dmx->dmxdev);
+	dvb_dmx_release(&dmx->demux);
+}
+
+static int aml_dvb_dmx_init(struct aml_dvb *advb, struct aml_dmx *dmx, int id)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+	int i, ret;
+#ifndef CONFIG_OF
+	struct resource *res;
+	char buf[32];
+#endif
+	switch(id){
+		case 0:
+			dmx->dmx_irq = INT_DEMUX;
+			break;
+		case 1:
+			dmx->dmx_irq = INT_DEMUX_1;
+			break;
+		case 2:
+			dmx->dmx_irq = INT_DEMUX_2;
+			break;
+	}
+
+#ifndef CONFIG_OF
+	snprintf(buf, sizeof(buf), "demux%d_irq", id);
+	res = platform_get_resource_byname(advb->pdev, IORESOURCE_IRQ, buf);
+	if (res) {
+		dmx->dmx_irq = res->start;
+	}
+#endif
+	pr_dbg("demux%d_irq: %d\n", id, dmx->dmx_irq);
+
+	dmx->source  = AM_TS_SRC_TS2;
+	dmx->dump_ts_select = 0;
+	dmx->dvr_irq = -1;
+
+	dmx->demux.dmx.capabilities 	= (DMX_TS_FILTERING | DMX_SECTION_FILTERING | DMX_MEMORY_BASED_FILTERING);
+	dmx->demux.filternum 		= dmx->demux.feednum = FILTER_COUNT;
+	dmx->demux.priv 		= advb;
+	dmx->demux.start_feed 		= aml_dmx_hw_start_feed;
+	dmx->demux.stop_feed 		= aml_dmx_hw_stop_feed;
+	dmx->demux.write_to_decoder 	= NULL;
+
+	if ((ret = dvb_dmx_init(&dmx->demux)) < 0) {
+		pr_error("dvb_dmx failed: error %d\n",ret);
+		goto error_dmx_init;
+	}
+
+	dmx->dmxdev.filternum = dmx->demux.feednum;
+	dmx->dmxdev.demux = &dmx->demux.dmx;
+	dmx->dmxdev.capabilities = 0;
+	if ((ret = dvb_dmxdev_init(&dmx->dmxdev, &advb->dvb_adapter)) < 0) {
+		pr_error("dvb_dmxdev_init failed: error %d\n",ret);
+		goto error_dmxdev_init;
+	}
+
+	for (i=0; i<DMX_DEV_COUNT; i++) {
+		int source = i+DMX_FRONTEND_0;
+		dmx->hw_fe[i].source = source;
+	pr_dbg("demux%d: source:%d\n", i, source);
+
+		if ((ret = dmx->demux.dmx.add_frontend(&dmx->demux.dmx, &dmx->hw_fe[i])) < 0) {
+			pr_error("adding hw_frontend to dmx failed: error %d",ret);
+			dmx->hw_fe[i].source = 0;
+			goto error_add_hw_fe;
+		}
+	}
+
+	dmx->mem_fe.source = DMX_MEMORY_FE;
+	if ((ret = dmx->demux.dmx.add_frontend(&dmx->demux.dmx, &dmx->mem_fe)) < 0) {
+		pr_error("adding mem_frontend to dmx failed: error %d",ret);
+		goto error_add_mem_fe;
+	}
+
+	if ((ret = dmx->demux.dmx.connect_frontend(&dmx->demux.dmx, &dmx->hw_fe[1])) < 0) {
+		pr_error("connect frontend failed: error %d",ret);
+		goto error_connect_fe;
+	}
+
+	dmx->id = id;
+	dmx->aud_chan = -1;
+	dmx->vid_chan = -1;
+	dmx->sub_chan = -1;
+	dmx->pcr_chan = -1;
+	dmx->smallsec.bufsize   = SS_BUFSIZE_DEF;
+	dmx->smallsec.enable    = 0;
+	dmx->smallsec.dmx       = dmx;
+	dmx->timeout.dmx        =  dmx;
+	dmx->timeout.enable     = 1;
+	dmx->timeout.timeout    = DTO_TIMEOUT_DEF;
+	dmx->timeout.ch_disable = DTO_CHDIS_VAS;
+	dmx->timeout.match      = 1;
+	dmx->timeout.trigger    = 0;
+
+	if ((ret = aml_dmx_hw_init(dmx)) <0) {
+		pr_error("demux hw init error %d", ret);
+		dmx->id = -1;
+		goto error_dmx_hw_init;
+	}
+        pr_dbg("demux%d \n", id);
+
+	dvb_net_init(&advb->dvb_adapter, &dmx->dvb_net, &dmx->demux.dmx);
+
+	return 0;
+error_dmx_hw_init:
+error_connect_fe:
+	dmx->demux.dmx.remove_frontend(&dmx->demux.dmx, &dmx->mem_fe);
+error_add_mem_fe:
+error_add_hw_fe:
+	for (i=0; i<DMX_DEV_COUNT; i++) {
+		if (dmx->hw_fe[i].source)
+			dmx->demux.dmx.remove_frontend(&dmx->demux.dmx, &dmx->hw_fe[i]);
+	}
+	dvb_dmxdev_release(&dmx->dmxdev);
+error_dmxdev_init:
+	dvb_dmx_release(&dmx->demux);
+error_dmx_init:
+	return ret;
+}
+struct aml_dvb* aml_get_dvb_device(void)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+	return &aml_dvb_device;
+}
+
+EXPORT_SYMBOL(aml_get_dvb_device);
+
+
+static int aml_dvb_asyncfifo_init(struct aml_dvb *advb, struct aml_asyncfifo *asyncfifo, int id)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+#ifndef CONFIG_OF
+	struct resource *res;
+	char buf[32];
+#endif
+
+	if(id == 0)
+		asyncfifo->asyncfifo_irq = INT_ASYNC_FIFO_FLUSH;
+	else
+		asyncfifo->asyncfifo_irq = INT_ASYNC_FIFO2_FLUSH;
+
+#ifndef CONFIG_OF
+	snprintf(buf, sizeof(buf), "dvr%d_irq", id);
+	res = platform_get_resource_byname(advb->pdev, IORESOURCE_IRQ, buf);
+	if (res) {
+		asyncfifo->asyncfifo_irq = res->start;
+	}
+#endif
+pr_inf("af:%d irq:%d\n", id, asyncfifo->asyncfifo_irq);
+
+	asyncfifo->dvb = advb;
+	asyncfifo->id = id;
+	asyncfifo->init = 0;
+	asyncfifo->flush_size = 188*1024;
+
+	return aml_asyncfifo_hw_init(asyncfifo);
+}
+
+
+static void aml_dvb_asyncfifo_release(struct aml_dvb *advb, struct aml_asyncfifo *asyncfifo)
+{
+	pr_dbg("%s: start\n", __func__);
+	aml_asyncfifo_hw_deinit(asyncfifo);
+}
+
+
+/*Show the STB input source*/
+static ssize_t stb_show_source(struct class *class, struct class_attribute *attr,char *buf)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+	struct aml_dvb *dvb = &aml_dvb_device;
+	ssize_t ret = 0;
+	char *src;
+
+	switch(dvb->stb_source) {
+		case AM_TS_SRC_TS0:
+		case AM_TS_SRC_S_TS0:
+			src = "ts0";
+		break;
+		case AM_TS_SRC_TS1:
+		case AM_TS_SRC_S_TS1:
+			src = "ts1";
+		break;
+		case AM_TS_SRC_TS2:
+		case AM_TS_SRC_S_TS2:
+			src = "ts2";
+		break;
+		case AM_TS_SRC_HIU:
+			src = "hiu";
+		break;
+		case AM_TS_SRC_DMX0:
+			src = "dmx0";
+		break;
+		case AM_TS_SRC_DMX1:
+			src = "dmx1";
+		break;
+		case AM_TS_SRC_DMX2:
+			src = "dmx2";
+		break;
+		default:
+			src = "disable";
+		break;
+	}
+
+	pr_dbg("%s: src=%s\n", __func__, src);
+	
+	ret = sprintf(buf, "%s\n", src);
+	return ret;
+}
+
+
+
+/*Set the STB input source*/
+static ssize_t stb_store_source(struct class *class,struct class_attribute *attr, const char *buf, size_t size)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+    dmx_source_t src = -1;
+
+    pr_inf("inp:%s\n", buf);
+
+    if(!strncmp("ts0", buf, 3)) {
+    	src = DMX_SOURCE_FRONT0;
+    } else if(!strncmp("ts1", buf, 3)) {
+    	src = DMX_SOURCE_FRONT1;
+    } else if(!strncmp("ts2", buf, 3)) {
+    	src = DMX_SOURCE_FRONT2;
+    } else if(!strncmp("hiu", buf, 3)) {
+    	src = DMX_SOURCE_DVR0;
+    } else if(!strncmp("dmx0", buf, 4)) {
+        src = DMX_SOURCE_FRONT0+100;
+    } else if(!strncmp("dmx1", buf, 4)) {
+        src = DMX_SOURCE_FRONT1+100;
+    } else if(!strncmp("dmx2", buf, 4)) {
+        src = DMX_SOURCE_FRONT2+100;
+    }
+    if(src!=-1) {
+    	aml_stb_hw_set_source(&aml_dvb_device, src);
+    }
+    return size;
+}
+
+#ifndef CONFIG_AM_DISABLE_DSC
+/*Show the descrambler's input source*/
+static ssize_t dsc_show_source(struct class *class,struct class_attribute *attr, char *buf)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+	struct aml_dvb *dvb = &aml_dvb_device;
+	ssize_t ret = 0;
+	char *src;
+
+	switch(dvb->dsc_source+7) {
+		case AM_TS_SRC_DMX0:
+			src = "dmx0";
+		break;
+		case AM_TS_SRC_DMX1:
+			src = "dmx1";
+		break;
+		case AM_TS_SRC_DMX2:
+			src = "dmx2";
+		break;
+		default:
+			src = "bypass";
+		break;
+	}
+
+	pr_dbg("%s: src=%s\n", __func__, src);
+	
+	ret = sprintf(buf, "%s\n", src);
+	return ret;
+}
+
+
+
+/*Set the descrambler's input source*/
+static ssize_t dsc_store_source(struct class *class, struct class_attribute *attr,
+                          const char *buf,
+                          size_t size)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+	dmx_source_t src = -1;
+	pr_inf("inp:%s\n", buf);
+
+	if(!strncmp("dmx0", buf, 4)) {
+		src = DMX_SOURCE_FRONT0; 	//	src = DMX_SOURCE_FRONT0+100;
+	} else if(!strncmp("dmx1", buf, 4)) {
+		src = DMX_SOURCE_FRONT1;	//	src = DMX_SOURCE_FRONT1+100;
+	} else if(!strncmp("dmx2", buf, 4)) {
+		src = DMX_SOURCE_FRONT2;	//	src = DMX_SOURCE_FRONT2+100;
+	}
+	aml_dsc_hw_set_source(&aml_dvb_device, src);
+
+	return size;
+}
+
+
+/*Show free descramblers count*/
+static ssize_t dsc_show_free_dscs(struct class *class,
+				  struct class_attribute *attr,
+				  char *buf)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+	struct aml_dvb *dvb = &aml_dvb_device;
+	int fid, count;
+	ssize_t ret = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	count = 0;
+	for(fid = 0; fid < DSC_COUNT; fid++){
+		if(!dvb->dsc[fid].used)
+			count++;
+	}
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	ret = sprintf(buf, "%d\n", count);
+	return ret;
+}
+#endif // #ifndef CONFIG_AM_DISABLE_DSC
+
+/*Show the TS output source*/
+static ssize_t tso_show_source(struct class *class, struct class_attribute *attr,char *buf)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+	struct aml_dvb *dvb = &aml_dvb_device;
+	ssize_t ret = 0;
+	char *src;
+
+	switch(dvb->tso_source) {
+		case AM_TS_SRC_TS0:
+		case AM_TS_SRC_S_TS0:
+			src = "ts0";
+		break;
+		case AM_TS_SRC_TS1:
+		case AM_TS_SRC_S_TS1:
+			src = "ts1";
+		break;
+		case AM_TS_SRC_TS2:
+		case AM_TS_SRC_S_TS2:
+			src = "ts2";
+		break;
+		case AM_TS_SRC_HIU:
+			src = "hiu";
+		break;
+		case AM_TS_SRC_DMX0:
+			src = "dmx0";
+		break;
+		case AM_TS_SRC_DMX1:
+			src = "dmx1";
+		break;
+		case AM_TS_SRC_DMX2:
+			src = "dmx2";
+		break;
+		default:
+			src = "default";
+		break;
+	}
+	
+	pr_dbg("%s: src=%s\n", __func__, src);
+
+	ret = sprintf(buf, "%s\n", src);
+	return ret;
+}
+
+
+
+/*Set the TS output source*/
+static ssize_t tso_store_source(struct class *class,struct class_attribute *attr,
+                          const char *buf,
+                          size_t size)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+    dmx_source_t src = -1;
+pr_inf("inp:%s\n", buf);
+
+    if(!strncmp("ts0", buf, 3)) {
+    	src = DMX_SOURCE_FRONT0;
+    } else if(!strncmp("ts1", buf, 3)) {
+    	src = DMX_SOURCE_FRONT1;
+    } else if(!strncmp("ts2", buf, 3)) {
+    	src = DMX_SOURCE_FRONT2;
+    } else if(!strncmp("hiu", buf, 3)) {
+    	src = DMX_SOURCE_DVR0;
+    } else if(!strncmp("dmx0", buf, 4)) {
+        src = DMX_SOURCE_FRONT0+100;
+    } else if(!strncmp("dmx1", buf, 4)) {
+        src = DMX_SOURCE_FRONT1+100;
+    } else if(!strncmp("dmx2", buf, 4)) {
+        src = DMX_SOURCE_FRONT2+100;
+    }
+
+	aml_tso_hw_set_source(&aml_dvb_device, src);
+
+    return size;
+}
+
+/*Show PCR*/
+#define DEMUX_PCR_FUNC_DECL(i)  \
+static ssize_t demux##i##_show_pcr(struct class *class,  struct class_attribute *attr,char *buf)\
+{\
+	int f = 0;\
+	if(i == 0)\
+		f = READ_MPEG_REG(PCR_DEMUX);\
+	else if(i==1)\
+		f = READ_MPEG_REG(PCR_DEMUX_2);\
+	else if(i==2)\
+		f = READ_MPEG_REG(PCR_DEMUX_3);\
+	return sprintf(buf, "%08x\n", f);\
+}
+
+/*Show the STB input source*/
+#define DEMUX_SOURCE_FUNC_DECL(i)  \
+static ssize_t demux##i##_show_source(struct class *class,  struct class_attribute *attr,char *buf)\
+{\
+	struct aml_dvb *dvb = &aml_dvb_device;\
+	struct aml_dmx *dmx = &dvb->dmx[i];\
+	ssize_t ret = 0;\
+	char *src;\
+	switch(dmx->source) {\
+		case AM_TS_SRC_TS0:\
+		case AM_TS_SRC_S_TS0:\
+			src = "ts0";\
+		break;\
+		case AM_TS_SRC_TS1:\
+		case AM_TS_SRC_S_TS1:\
+			src = "ts1";\
+		break;\
+		case AM_TS_SRC_TS2:\
+		case AM_TS_SRC_S_TS2:\
+			src = "ts2";\
+		break;\
+		case AM_TS_SRC_HIU:\
+			src = "hiu";\
+		break;\
+		default:\
+			src = "";\
+		break;\
+	}\
+	ret = sprintf(buf, "%s\n", src);\
+	return ret;\
+}\
+static ssize_t demux##i##_store_source(struct class *class,  struct class_attribute *attr,const char *buf, size_t size)\
+{\
+    dmx_source_t src = -1;\
+pr_inf("inp:%s\n", buf);    \
+	if(!strncmp("ts0", buf, 3)) {\
+    	src = DMX_SOURCE_FRONT0;\
+    } else if(!strncmp("ts1", buf, 3)) {\
+    	src = DMX_SOURCE_FRONT1;\
+    } else if(!strncmp("ts2", buf, 3)) {\
+    	src = DMX_SOURCE_FRONT2;\
+    } else if(!strncmp("hiu", buf, 3)) {\
+    	src = DMX_SOURCE_DVR0;\
+    }\
+    if(src!=-1) {\
+    	aml_dmx_hw_set_source(aml_dvb_device.dmx[i].dmxdev.demux, src);\
+    }\
+    return size;\
+}
+
+/*Show free filters count*/
+#define DEMUX_FREE_FILTERS_FUNC_DECL(i)  \
+static ssize_t demux##i##_show_free_filters(struct class *class,  \
+				struct class_attribute *attr, char *buf)\
+{\
+	struct aml_dvb *dvb = &aml_dvb_device;\
+	struct dvb_demux *dmx = &dvb->dmx[i].demux;\
+	int fid, count;\
+	ssize_t ret = 0;\
+	if (mutex_lock_interruptible(&dmx->mutex)) \
+		return -ERESTARTSYS; \
+	count = 0;\
+	for (fid = 0; fid < dmx->filternum; fid++) {\
+		if (!dmx->filter[fid].state != DMX_STATE_FREE)\
+			count++;\
+	} \
+	mutex_unlock(&dmx->mutex);\
+	ret = sprintf(buf, "%d\n", count);\
+	return ret;\
+}
+
+/*Show filter users count*/
+#define DEMUX_FILTER_USERS_FUNC_DECL(i)  \
+static ssize_t demux##i##_show_filter_users(struct class *class,  struct class_attribute *attr,char *buf)\
+{\
+	struct aml_dvb *dvb = &aml_dvb_device;\
+	struct aml_dmx *dmx = &dvb->dmx[i];\
+	int dmxdevfid, count;\
+	ssize_t ret = 0;\
+	unsigned long flags;\
+	spin_lock_irqsave(&dvb->slock, flags);\
+	count = 0;\
+	for (dmxdevfid = 0; dmxdevfid < dmx->dmxdev.filternum; dmxdevfid++) {\
+		if (dmx->dmxdev.filter[dmxdevfid].state >= DMXDEV_STATE_ALLOCATED)\
+			count++;\
+	}\
+	if (count > dmx->demux_filter_user) {\
+		count = dmx->demux_filter_user;\
+	} else{\
+		dmx->demux_filter_user = count;\
+	}\
+	spin_unlock_irqrestore(&dvb->slock, flags);\
+	ret = sprintf(buf, "%d\n", count);\
+	return ret;\
+}\
+static ssize_t demux##i##_store_filter_used(struct class *class,  struct class_attribute *attr,const char *buf, size_t size)\
+{\
+	struct aml_dvb *dvb = &aml_dvb_device;\
+	struct aml_dmx *dmx = &dvb->dmx[i];\
+	unsigned long filter_used;\
+	unsigned long flags;/*char *endp;*/\
+	/*filter_used = simple_strtol(buf, &endp, 0);*/\
+	int ret = kstrtol(buf, 0, &filter_used);\
+	spin_lock_irqsave(&dvb->slock, flags);\
+	if (ret == 0 && filter_used) {\
+		if(dmx->demux_filter_user < FILTER_COUNT)\
+			dmx->demux_filter_user++;\
+	}else{\
+		if(dmx->demux_filter_user > 0)\
+			dmx->demux_filter_user--;\
+	}\
+	spin_unlock_irqrestore(&dvb->slock, flags);\
+	return size;\
+}
+
+
+/*Show ts header*/
+#define DEMUX_TS_HEADER_FUNC_DECL(i)  \
+static ssize_t demux##i##_show_ts_header(struct class *class,  struct class_attribute *attr,char *buf)\
+{\
+	int hdr = 0;\
+	if(i == 0)\
+		hdr = READ_MPEG_REG(TS_HEAD_1);\
+	else if(i==1)\
+		hdr = READ_MPEG_REG(TS_HEAD_1_2);\
+	else if(i==2)\
+		hdr = READ_MPEG_REG(TS_HEAD_1_3);\
+	return sprintf(buf, "%08x\n", hdr);\
+}
+
+/*Show channel activity*/
+#define DEMUX_CHANNEL_ACTIVITY_FUNC_DECL(i)  \
+static ssize_t demux##i##_show_channel_activity(struct class *class,  struct class_attribute *attr,char *buf)\
+{\
+	int f = 0;\
+	if(i == 0)\
+		f = READ_MPEG_REG(DEMUX_CHANNEL_ACTIVITY);\
+	else if(i==1)\
+		f = READ_MPEG_REG(DEMUX_CHANNEL_ACTIVITY_2);\
+	else if(i==2)\
+		f = READ_MPEG_REG(DEMUX_CHANNEL_ACTIVITY_3);\
+	return sprintf(buf, "%08x\n", f);\
+}
+
+/*DVR record mode*/
+#define DVR_MODE_FUNC_DECL(i)  \
+static ssize_t dvr##i##_show_mode(struct class *class,  struct class_attribute *attr,char *buf)\
+{\
+	struct aml_dvb *dvb = &aml_dvb_device;\
+	struct aml_dmx *dmx = &dvb->dmx[i];\
+	ssize_t ret = 0;\
+	char *mode;\
+	if(dmx->dump_ts_select) {\
+		mode = "ts";\
+	}else{\
+		mode = "pid";\
+	}\
+	ret = sprintf(buf, "%s\n", mode);\
+	return ret;\
+}\
+static ssize_t dvr##i##_store_mode(struct class *class,  struct class_attribute *attr,const char *buf, size_t size)\
+{\
+    struct aml_dvb *dvb = &aml_dvb_device;\
+    struct aml_dmx *dmx = &dvb->dmx[i];\
+    int dump_ts_select = -1;\
+    \
+    if(!strncmp("pid", buf, 3) && dmx->dump_ts_select) {\
+    	dump_ts_select = 0;\
+    } else if(!strncmp("ts", buf, 2) && !dmx->dump_ts_select) {\
+    	dump_ts_select = 1;\
+    }\
+    if(dump_ts_select!=-1) {\
+    	aml_dmx_hw_set_dump_ts_select(aml_dvb_device.dmx[i].dmxdev.demux, dump_ts_select);\
+    }\
+    return size;\
+}
+
+#if DMX_DEV_COUNT>0
+	DEMUX_PCR_FUNC_DECL(0)
+	DEMUX_SOURCE_FUNC_DECL(0)
+	DEMUX_FREE_FILTERS_FUNC_DECL(0)
+	DEMUX_FILTER_USERS_FUNC_DECL(0)
+	DVR_MODE_FUNC_DECL(0)
+	DEMUX_TS_HEADER_FUNC_DECL(0)
+	DEMUX_CHANNEL_ACTIVITY_FUNC_DECL(0)
+#endif
+#if DMX_DEV_COUNT>1
+	DEMUX_PCR_FUNC_DECL(1)
+	DEMUX_SOURCE_FUNC_DECL(1)
+	DEMUX_FREE_FILTERS_FUNC_DECL(1)
+	DEMUX_FILTER_USERS_FUNC_DECL(1)
+	DVR_MODE_FUNC_DECL(1)
+	DEMUX_TS_HEADER_FUNC_DECL(1)
+	DEMUX_CHANNEL_ACTIVITY_FUNC_DECL(1)
+#endif
+#if DMX_DEV_COUNT>2
+	DEMUX_PCR_FUNC_DECL(2)
+	DEMUX_SOURCE_FUNC_DECL(2)
+	DEMUX_FREE_FILTERS_FUNC_DECL(2)
+	DEMUX_FILTER_USERS_FUNC_DECL(2)
+	DVR_MODE_FUNC_DECL(2)
+	DEMUX_TS_HEADER_FUNC_DECL(2)
+	DEMUX_CHANNEL_ACTIVITY_FUNC_DECL(2)
+#endif
+
+/*Show the async fifo source*/
+#define ASYNCFIFO_SOURCE_FUNC_DECL(i)  \
+static ssize_t asyncfifo##i##_show_source(struct class *class,  struct class_attribute *attr,char *buf)\
+{\
+	struct aml_dvb *dvb = &aml_dvb_device;\
+	struct aml_asyncfifo *afifo = &dvb->asyncfifo[i];\
+	ssize_t ret = 0;\
+	char *src;\
+	switch(afifo->source) {\
+		case AM_DMX_0:\
+			src = "dmx0";\
+		break;\
+		case AM_DMX_1:\
+			src = "dmx1";\
+		break;\
+		case AM_DMX_2:\
+			src = "dmx2";\
+		break;\
+		default:\
+			src = "";\
+		break;\
+	}\
+	ret = sprintf(buf, "%s\n", src);\
+	return ret;\
+}\
+static ssize_t asyncfifo##i##_store_source(struct class *class,  struct class_attribute *attr,const char *buf, size_t size)\
+{\
+    enum aml_dmx_id_t src = -1;\
+pr_inf("inp:%s\n", buf);    \
+	if(!strncmp("dmx0", buf, 4)) {\
+    	src = AM_DMX_0;\
+    } else if(!strncmp("dmx1", buf, 4)) {\
+    	src = AM_DMX_1;\
+    } else if(!strncmp("dmx2", buf, 4)) {\
+    	src = AM_DMX_2;\
+    }\
+    if(src!=-1) {\
+    	aml_asyncfifo_hw_set_source(&aml_dvb_device.asyncfifo[i], src);\
+    }\
+    return size;\
+}
+
+#if ASYNCFIFO_COUNT>0
+	ASYNCFIFO_SOURCE_FUNC_DECL(0)
+#endif
+#if ASYNCFIFO_COUNT>1
+	ASYNCFIFO_SOURCE_FUNC_DECL(1)
+#endif
+
+/*Show the async fifo flush size*/
+#define ASYNCFIFO_FLUSHSIZE_FUNC_DECL(i)  \
+static ssize_t asyncfifo##i##_show_flush_size(struct class *class,  \
+				struct class_attribute *attr, char *buf)\
+{\
+	struct aml_dvb *dvb = &aml_dvb_device;\
+	struct aml_asyncfifo *afifo = &dvb->asyncfifo[i];\
+	ssize_t ret = 0;\
+	ret = sprintf(buf, "%d\n", afifo->flush_size);\
+	return ret;\
+} \
+static ssize_t asyncfifo##i##_store_flush_size(struct class *class,  \
+					struct class_attribute *attr, \
+					const char *buf, size_t size)\
+{\
+	struct aml_dvb *dvb = &aml_dvb_device;\
+	struct aml_asyncfifo *afifo = &dvb->asyncfifo[i];\
+	/*int fsize = simple_strtol(buf, NULL, 10);*/\
+	int fsize = 0;\
+	long value;\
+	int ret = kstrtol(buf, 0, &value);\
+	if (ret == 0)\
+		fsize = value;\
+	if (fsize != afifo->flush_size) {\
+		afifo->flush_size = fsize;\
+	aml_asyncfifo_hw_reset(&aml_dvb_device.asyncfifo[i]);\
+	} \
+	return size;\
+}
+
+#if ASYNCFIFO_COUNT > 0
+ASYNCFIFO_FLUSHSIZE_FUNC_DECL(0)
+#endif
+
+#if ASYNCFIFO_COUNT > 1
+	ASYNCFIFO_FLUSHSIZE_FUNC_DECL(1)
+#endif
+/*Reset the Demux*/
+static ssize_t demux_do_reset(struct class *class,struct class_attribute *attr,
+                          const char *buf,
+                          size_t size)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+	if(!strncmp("1", buf, 1)) {
+		struct aml_dvb *dvb = &aml_dvb_device;
+		unsigned long flags;
+
+		spin_lock_irqsave(&dvb->slock, flags);
+		pr_dbg("Reset demux, call dmx_reset_hw\n");
+		dmx_reset_hw_ex(dvb, 0);
+		spin_unlock_irqrestore(&dvb->slock, flags);
+	}
+
+	return size;
+}
+
+
+
+
+
+/*Show the Video PTS value*/
+static ssize_t demux_show_video_pts(struct class *class,  struct class_attribute *attr,char *buf)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+	struct aml_dvb *dvb = &aml_dvb_device;
+	ssize_t ret = 0;
+
+	ret = sprintf(buf, "%u\n", aml_dmx_get_video_pts(dvb));
+
+	return ret;
+}
+
+
+/*Show the Audio PTS value*/
+static ssize_t demux_show_audio_pts(struct class *class,  struct class_attribute *attr,char *buf)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+	struct aml_dvb *dvb = &aml_dvb_device;
+	ssize_t ret = 0;
+
+	ret = sprintf(buf, "%u\n", aml_dmx_get_audio_pts(dvb));
+
+	return ret;
+}
+
+
+
+/*Show the First Video PTS value*/
+static ssize_t demux_show_first_video_pts(struct class *class,  struct class_attribute *attr,char *buf)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+	struct aml_dvb *dvb = &aml_dvb_device;
+	ssize_t ret = 0;
+
+	ret = sprintf(buf, "%u\n", aml_dmx_get_first_video_pts(dvb));
+
+	return ret;
+}
+
+
+
+/*Show the First Audio PTS value*/
+static ssize_t demux_show_first_audio_pts(struct class *class,  struct class_attribute *attr,char *buf)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+	struct aml_dvb *dvb = &aml_dvb_device;
+	ssize_t ret = 0;
+
+	ret = sprintf(buf, "%u\n", aml_dmx_get_first_audio_pts(dvb));
+
+	return ret;
+}
+
+
+static ssize_t stb_show_hw_setting(struct class *class, struct class_attribute *attr, char *buf)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+	int r, total = 0;
+	int i;
+	struct aml_dvb *dvb = &aml_dvb_device;
+	int invert, ctrl;
+
+	for(i=0; i<TS_IN_COUNT; i++){
+		struct aml_ts_input *ts = &dvb->ts[i];
+
+		if(ts->s2p_id != -1){
+			invert = dvb->s2p[ts->s2p_id].invert;
+		}else{
+			invert = 0;
+		}
+
+		ctrl = ts->control;
+
+		r = sprintf(buf, "ts%d %s control: 0x%x invert: 0x%x\n", i,
+				ts->mode==AM_TS_DISABLE?"disable":(ts->mode==AM_TS_SERIAL?"serial":"parallel"),
+				ctrl, invert);
+		buf += r;
+		total += r;
+	}
+
+	return total;
+}
+
+
+
+static ssize_t stb_store_hw_setting(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+	int id, ctrl, invert, r, mode;
+	char mname[32];
+	char pname[32];
+	unsigned long flags;
+	struct aml_ts_input *ts;
+	struct aml_dvb *dvb = &aml_dvb_device;
+
+	r = sscanf(buf, "%d %s %x %x", &id, mname, &ctrl, &invert);
+	if(r != 4)
+		return -EINVAL;
+
+	if(id < 0 || id >= TS_IN_COUNT)
+		return -EINVAL;
+
+	if((mname[0] == 's') || (mname[0] == 'S')){
+		sprintf(pname, "s_ts%d", id);
+		mode = AM_TS_SERIAL;
+	}else if((mname[0] == 'p') || (mname[0] == 'P')){
+		sprintf(pname, "p_ts%d", id);
+		mode = AM_TS_PARALLEL;
+	}else{
+		mode = AM_TS_DISABLE;
+	}
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	ts = &dvb->ts[id];
+
+	if((mode == AM_TS_SERIAL) && (ts->mode != AM_TS_SERIAL)){
+		int i;
+		int scnt = 0;
+
+		for(i = 0; i < TS_IN_COUNT; i++){
+			if(dvb->ts[i].s2p_id != -1){
+				scnt++;
+			}
+		}
+
+		if(scnt >= S2P_COUNT){
+			pr_error("no free s2p\n");
+		}else{
+			ts->s2p_id = scnt;
+		}
+	}
+
+	if((mode != AM_TS_SERIAL) || (ts->s2p_id != -1)){
+		if(ts->pinctrl){
+			devm_pinctrl_put(ts->pinctrl);
+			ts->pinctrl = NULL;
+		}
+
+		ts->pinctrl  = devm_pinctrl_get_select(&dvb->pdev->dev, pname);
+		ts->mode     = mode;
+		ts->control  = ctrl;
+
+		if(mode == AM_TS_SERIAL){
+			dvb->s2p[ts->s2p_id].invert = invert;
+		}else{
+			ts->s2p_id = -1;
+		}
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return count;
+}
+
+#define DEMUX_RESET_FUNC_DECL(i)  \
+static ssize_t demux##i##_reset_store(struct class *class,  struct class_attribute *attr,const char *buf, size_t size)\
+{\
+	if(!strncmp("1", buf, 1)) { \
+		struct aml_dvb *dvb = &aml_dvb_device; \
+		pr_info("Reset demux["#i"], call dmx_reset_dmx_hw\n"); \
+		dmx_reset_dmx_id_hw_ex(dvb, i, 0); \
+	} \
+	return size; \
+}
+#if DMX_DEV_COUNT>0
+	DEMUX_RESET_FUNC_DECL(0)
+#endif
+#if DMX_DEV_COUNT>1
+	DEMUX_RESET_FUNC_DECL(1)
+#endif
+#if DMX_DEV_COUNT>2
+	DEMUX_RESET_FUNC_DECL(2)
+#endif
+
+static struct class_attribute aml_stb_class_attrs[] = {
+	__ATTR(hw_setting, S_IRUGO|S_IWUSR, stb_show_hw_setting, stb_store_hw_setting),
+	__ATTR(source,  S_IRUGO | S_IWUSR | S_IWGRP, stb_show_source, stb_store_source),
+#ifndef CONFIG_AM_DISABLE_DSC
+	__ATTR(dsc_source,  S_IRUGO | S_IWUSR, dsc_show_source, dsc_store_source),
+#endif // #ifndef CONFIG_AM_DISABLE_DSC
+	__ATTR(tso_source,  S_IRUGO | S_IWUSR, tso_show_source, tso_store_source),
+#define DEMUX_SOURCE_ATTR_PCR(i)\
+		__ATTR(demux##i##_pcr,  S_IRUGO | S_IWUSR, demux##i##_show_pcr, NULL)
+#define DEMUX_SOURCE_ATTR_DECL(i)\
+		__ATTR(demux##i##_source,  S_IRUGO | S_IWUSR | S_IWGRP, demux##i##_show_source, demux##i##_store_source)
+#define DEMUX_FREE_FILTERS_ATTR_DECL(i)\
+		__ATTR(demux##i##_free_filters,  S_IRUGO | S_IWUSR, demux##i##_show_free_filters, NULL)
+#define DEMUX_FILTER_USERS_ATTR_DECL(i)\
+		__ATTR(demux##i##_filter_users,  S_IRUGO | S_IWUSR, demux##i##_show_filter_users, demux##i##_store_filter_used)
+#define DVR_MODE_ATTR_DECL(i)\
+		__ATTR(dvr##i##_mode,  S_IRUGO | S_IWUSR, dvr##i##_show_mode, dvr##i##_store_mode)
+#define DEMUX_TS_HEADER_ATTR_DECL(i)\
+		__ATTR(demux##i##_ts_header,  S_IRUGO | S_IWUSR, demux##i##_show_ts_header, NULL)
+#define DEMUX_CHANNEL_ACTIVITY_ATTR_DECL(i)\
+		__ATTR(demux##i##_channel_activity,  S_IRUGO | S_IWUSR, demux##i##_show_channel_activity, NULL)
+#define DMX_RESET_ATTR_DECL(i)\
+		__ATTR(demux##i##_reset,  S_IRUGO | S_IWUSR, NULL, demux##i##_reset_store)
+#if DMX_DEV_COUNT>0
+	DEMUX_SOURCE_ATTR_PCR(0),
+	DEMUX_SOURCE_ATTR_DECL(0),
+	DEMUX_FREE_FILTERS_ATTR_DECL(0),
+	DEMUX_FILTER_USERS_ATTR_DECL(0),
+	DVR_MODE_ATTR_DECL(0),
+	DEMUX_TS_HEADER_ATTR_DECL(0),
+	DEMUX_CHANNEL_ACTIVITY_ATTR_DECL(0),
+	DMX_RESET_ATTR_DECL(0),
+#endif
+#if DMX_DEV_COUNT>1
+	DEMUX_SOURCE_ATTR_PCR(1),
+	DEMUX_SOURCE_ATTR_DECL(1),
+	DEMUX_FREE_FILTERS_ATTR_DECL(1),
+	DEMUX_FILTER_USERS_ATTR_DECL(1),
+	DVR_MODE_ATTR_DECL(1),
+	DEMUX_TS_HEADER_ATTR_DECL(1),
+	DEMUX_CHANNEL_ACTIVITY_ATTR_DECL(1),
+	DMX_RESET_ATTR_DECL(1),
+#endif
+#if DMX_DEV_COUNT>2
+	DEMUX_SOURCE_ATTR_PCR(2),
+	DEMUX_SOURCE_ATTR_DECL(2),
+	DEMUX_FREE_FILTERS_ATTR_DECL(2),
+	DEMUX_FILTER_USERS_ATTR_DECL(2),
+	DVR_MODE_ATTR_DECL(2),
+	DEMUX_TS_HEADER_ATTR_DECL(2),
+	DEMUX_CHANNEL_ACTIVITY_ATTR_DECL(2),
+	DMX_RESET_ATTR_DECL(2),
+#endif
+#define ASYNCFIFO_SOURCE_ATTR_DECL(i)\
+		__ATTR(asyncfifo##i##_source,  S_IRUGO | S_IWUSR | S_IWGRP, asyncfifo##i##_show_source, asyncfifo##i##_store_source)
+#define ASYNCFIFO_FLUSHSIZE_ATTR_DECL(i)\
+		__ATTR(asyncfifo##i##_flush_size,  S_IRUGO | S_IWUSR | S_IWGRP, asyncfifo##i##_show_flush_size, asyncfifo##i##_store_flush_size)
+#if ASYNCFIFO_COUNT>0
+	ASYNCFIFO_SOURCE_ATTR_DECL(0),
+	ASYNCFIFO_FLUSHSIZE_ATTR_DECL(0),
+#endif
+#if ASYNCFIFO_COUNT>1
+	ASYNCFIFO_SOURCE_ATTR_DECL(1),
+	ASYNCFIFO_FLUSHSIZE_ATTR_DECL(1),
+#endif
+	__ATTR(demux_reset,  S_IRUGO | S_IWUSR, NULL, demux_do_reset),
+	__ATTR(video_pts,  S_IRUGO | S_IWUSR | S_IWGRP, demux_show_video_pts, NULL),
+	__ATTR(audio_pts,  S_IRUGO | S_IWUSR | S_IWGRP, demux_show_audio_pts, NULL),
+	__ATTR(first_video_pts,  S_IRUGO | S_IWUSR, demux_show_first_video_pts, NULL),
+	__ATTR(first_audio_pts,  S_IRUGO | S_IWUSR, demux_show_first_audio_pts, NULL),
+#ifndef CONFIG_AM_DISABLE_DSC
+	__ATTR(free_dscs,  S_IRUGO | S_IWUSR, dsc_show_free_dscs, NULL),
+#endif // #ifndef CONFIG_AM_DISABLE_DSC
+	__ATTR_NULL
+};
+
+static struct class aml_stb_class = {
+	.name = "stb",
+	.class_attrs = aml_stb_class_attrs,
+};
+
+extern int aml_regist_dmx_class(void);
+extern int aml_unregist_dmx_class(void);
+
+static int aml_dvb_probe(struct platform_device *pdev)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+	struct aml_dvb *advb;
+	int i, ret = 0;
+	struct devio_aml_platform_data *pd_dvb;
+
+	pr_inf("probe amlogic dvb driver\n");
+#ifdef CONFIG_ARM64
+	/*switch_mod_gate_by_name("demux", 1); */
+
+	aml_dvb_demux_reset_ctl =
+		devm_reset_control_get(&pdev->dev, "demux");
+	pr_inf("dmx rst ctl = %p\n", aml_dvb_demux_reset_ctl);
+	reset_control_deassert(aml_dvb_demux_reset_ctl);
+
+	aml_dvb_afifo_reset_ctl =
+		devm_reset_control_get(&pdev->dev, "asyncfifo");
+	pr_inf("asyncfifo rst ctl = %p\n", aml_dvb_afifo_reset_ctl);
+	reset_control_deassert(aml_dvb_afifo_reset_ctl);
+
+	aml_dvb_ahbarb0_reset_ctl =
+		devm_reset_control_get(&pdev->dev, "ahbarb0");
+	pr_inf("ahbarb0 rst ctl = %p\n", aml_dvb_ahbarb0_reset_ctl);
+	reset_control_deassert(aml_dvb_ahbarb0_reset_ctl);
+
+	aml_dvb_uparsertop_reset_ctl =
+		devm_reset_control_get(&pdev->dev, "uparsertop");
+	pr_inf("uparsertop rst ctl = %p\n", aml_dvb_uparsertop_reset_ctl);
+	reset_control_deassert(aml_dvb_uparsertop_reset_ctl);
+#else
+	switch_mod_gate_by_name("demux", 1);
+#endif
+	advb = &aml_dvb_device;
+	memset(advb, 0, sizeof(aml_dvb_device));
+
+	spin_lock_init(&advb->slock);
+
+	advb->dev = &pdev->dev;
+	advb->pdev = pdev;
+#ifndef CONFIG_AM_DISABLE_DSC
+	advb->dsc_source = AM_TS_SRC_TS2; //AM_TS_SRC_S_TS0;
+#endif // #ifndef CONFIG_AM_DISABLE_DSC
+	advb->stb_source = -1;
+	advb->tso_source = -1;
+
+	for (i = 0; i < DMX_DEV_COUNT; i++) {
+		advb->dmx[i].dmx_irq = -1;
+		advb->dmx[i].dvr_irq = -1;
+	}
+
+#ifdef CONFIG_OF
+	if(pdev->dev.of_node){
+		int s2p_id = 0;
+
+		char buf[32];
+		const char *str;
+		u32 value;
+		for (i=0; i<TS_IN_COUNT; i++){
+
+			advb->ts[i].mode   = AM_TS_DISABLE;
+			advb->ts[i].s2p_id = -1;
+
+			snprintf(buf, sizeof(buf), "ts%d", i);
+			ret = of_property_read_string(pdev->dev.of_node, buf, &str);
+			if(!ret){
+				if(!strcmp(str, "serial")){
+					pr_dbg("%s: serial\n", buf);
+
+					if(s2p_id >= S2P_COUNT){
+						pr_error("no free s2p\n");
+					}else{
+						snprintf(buf, sizeof(buf), "s_ts%d", i);
+						advb->ts[i].mode    = AM_TS_SERIAL;
+						advb->ts[i].pinctrl = devm_pinctrl_get_select(&pdev->dev, buf);
+						advb->ts[i].s2p_id  = s2p_id;
+
+						s2p_id++;
+					}
+				}else if(!strcmp(str, "parallel")){
+					pr_dbg("%s: parallel\n", buf);
+					snprintf(buf, sizeof(buf), "p_ts%d", i);
+					advb->ts[i].mode    = AM_TS_PARALLEL;
+					advb->ts[i].pinctrl = devm_pinctrl_get_select(&pdev->dev, buf);
+				}else{
+					advb->ts[i].mode    = AM_TS_DISABLE;
+					advb->ts[i].pinctrl = NULL;
+				}
+
+		//		if(IS_ERR_VALUE(advb->ts[i].pinctrl))
+		//			advb->ts[i].pinctrl = NULL;
+
+				control_ts_on_csi_port(i, (advb->ts[i].mode == AM_TS_DISABLE)? 0 : 1);
+			}
+
+			snprintf(buf, sizeof(buf), "ts%d_control", i);
+			ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
+			if(!ret){
+				pr_dbg("%s: 0x%x\n", buf, value);
+				advb->ts[i].control = value;
+			}
+
+			if(advb->ts[i].s2p_id != -1){
+				snprintf(buf, sizeof(buf), "ts%d_invert", i);
+				ret = of_property_read_u32(pdev->dev.of_node, buf, &value);
+				if(!ret){
+					pr_dbg("%s: 0x%x\n", buf, value);
+					advb->s2p[advb->ts[i].s2p_id].invert = value;
+				}
+			}
+		}
+	}
+#endif
+	pd_dvb = (struct devio_aml_platform_data *)advb->dev->platform_data;
+
+	ret =
+	    dvb_register_adapter(&advb->dvb_adapter, CARD_NAME, THIS_MODULE,
+				 advb->dev, adapter_nr);
+	if (ret < 0)
+		return ret;
+	pr_inf("Registered adapter: %s\n", CARD_NAME);
+
+	for (i = 0; i < DMX_DEV_COUNT; i++)
+		advb->dmx[i].id = -1;
+
+	advb->dvb_adapter.priv = advb;
+	dev_set_drvdata(advb->dev, advb);
+
+	for (i = 0; i < DMX_DEV_COUNT; i++) {
+		ret = aml_dvb_dmx_init(advb, &advb->dmx[i], i);
+		if (ret < 0)
+			goto error;
+	}
+	/*Init the async fifos */
+	for (i = 0; i < ASYNCFIFO_COUNT; i++) {
+		ret = aml_dvb_asyncfifo_init(advb, &advb->asyncfifo[i], i);
+		if (ret < 0)
+			goto error;
+
+	}
+	aml_asyncfifo_hw_set_source(&advb->asyncfifo[0], AM_DMX_0);
+
+	aml_regist_dmx_class();
+
+	if (class_register(&aml_stb_class) < 0) {
+		pr_error("register class error\n");
+		goto error;
+	}
+
+	tsdemux_set_ops(&aml_tsdemux_ops);
+
+	dmx_reset_dmx_sw();
+	return ret;
+error:
+	for (i = 0; i < ASYNCFIFO_COUNT; i++) {
+		if (advb->asyncfifo[i].id != -1)
+			aml_dvb_asyncfifo_release(advb, &advb->asyncfifo[i]);
+	}
+
+	for (i = 0; i < DMX_DEV_COUNT; i++) {
+		if (advb->dmx[i].id != -1)
+			aml_dvb_dmx_release(advb, &advb->dmx[i]);
+	}
+
+	dvb_unregister_adapter(&advb->dvb_adapter);
+
+	return ret;
+}
+
+static int aml_dvb_remove(struct platform_device *pdev)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+	struct aml_dvb *advb = (struct aml_dvb *)dev_get_drvdata(&pdev->dev);
+	int i;
+
+	tsdemux_set_ops(NULL);
+
+	aml_unregist_dmx_class();
+	class_unregister(&aml_stb_class);
+
+
+	for (i = 0; i < DMX_DEV_COUNT; i++)
+		aml_dvb_dmx_release(advb, &advb->dmx[i]);
+
+	dvb_unregister_adapter(&advb->dvb_adapter);
+
+	for (i = 0; i < TS_IN_COUNT; i++) {
+		if (advb->ts[i].pinctrl)
+			devm_pinctrl_put(advb->ts[i].pinctrl);
+	}
+#ifdef CONFIG_ARM64
+	/*switch_mod_gate_by_name("demux", 0); */
+	reset_control_assert(aml_dvb_uparsertop_reset_ctl);
+	reset_control_assert(aml_dvb_ahbarb0_reset_ctl);
+	reset_control_assert(aml_dvb_afifo_reset_ctl);					
+	reset_control_assert(aml_dvb_demux_reset_ctl);
+#else
+	switch_mod_gate_by_name("demux", 0);
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id aml_dvb_dt_match[]={
+	{
+		.compatible = "amlogic,dvb",
+	},
+	{},
+};
+#endif /*CONFIG_OF*/
+
+static struct platform_driver aml_dvb_driver = {
+	.probe		= aml_dvb_probe,
+	.remove		= aml_dvb_remove,
+	.driver		= {
+		.name	= "amlogic-dvb",
+		.owner	= THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = aml_dvb_dt_match,
+#endif
+	}
+};
+
+int __init aml_dvb_init(void)
+{
+	pr_dbg("aml dvb init\n");
+	return platform_driver_register(&aml_dvb_driver);
+}
+
+void __exit aml_dvb_exit(void)
+{
+	pr_dbg("aml dvb exit\n");
+	platform_driver_unregister(&aml_dvb_driver);
+}
+
+/*Get the STB source demux*/
+static struct aml_dmx* get_stb_dmx(void)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+	struct aml_dvb *dvb = &aml_dvb_device;
+	struct aml_dmx *dmx = NULL;
+	int i;
+	
+	pr_dbg("%s: dvb->stb_source=%d\n", __func__, dvb->stb_source);
+
+	switch(dvb->stb_source){
+		case AM_TS_SRC_DMX0:
+			dmx = &dvb->dmx[0];
+		break;
+		case AM_TS_SRC_DMX1:
+			dmx = &dvb->dmx[1];
+		break;
+		case AM_TS_SRC_DMX2:
+			dmx = &dvb->dmx[2];
+		break;
+		default:
+			for(i=0; i<DMX_DEV_COUNT; i++) {
+				dmx = &dvb->dmx[i];
+				if(dmx->source==dvb->stb_source) {
+					return dmx;
+				}
+			}
+		break;
+	}
+
+	return dmx;
+}
+
+static int aml_tsdemux_reset(void)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+	struct aml_dvb *dvb = &aml_dvb_device;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	if(dvb->reset_flag) {
+		struct aml_dmx *dmx = get_stb_dmx();
+		dvb->reset_flag = 0;
+		if(dmx)
+			dmx_reset_dmx_hw_ex_unlock(dvb, dmx, 0);
+	}
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return 0;
+}
+
+static int aml_tsdemux_set_reset_flag(void)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+	struct aml_dvb *dvb = &aml_dvb_device;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	dvb->reset_flag = 1;
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return 0;
+
+}
+
+/*Add the amstream irq handler*/
+static int aml_tsdemux_request_irq(irq_handler_t handler, void *data)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+	struct aml_dvb *dvb = &aml_dvb_device;
+	struct aml_dmx *dmx;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	dmx = get_stb_dmx();
+	if(dmx) {
+		dmx->irq_handler = handler;
+		dmx->irq_data = data;
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return 0;
+}
+
+/*Free the amstream irq handler*/
+static int aml_tsdemux_free_irq(void)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+	struct aml_dvb *dvb = &aml_dvb_device;
+	struct aml_dmx *dmx;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	dmx = get_stb_dmx();
+	if(dmx) {
+		dmx->irq_handler = NULL;
+		dmx->irq_data = NULL;
+	}
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return 0;
+}
+
+/*Reset the video PID*/
+static int aml_tsdemux_set_vid(int vpid)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+	struct aml_dvb *dvb = &aml_dvb_device;
+	struct aml_dmx *dmx;
+	unsigned long flags;
+	int ret = 0;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	dmx = get_stb_dmx();
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	if(dmx) {
+		mutex_lock(&dmx->dmxdev.mutex);
+
+		spin_lock_irqsave(&dvb->slock, flags);
+
+		if(dmx->vid_chan!=-1) {
+			dmx_free_chan(dmx, dmx->vid_chan);
+			dmx->vid_chan = -1;
+		}
+
+		if((vpid>=0) && (vpid<0x1FFF)) {
+			dmx->vid_chan = dmx_alloc_chan(dmx, DMX_TYPE_TS, DMX_PES_VIDEO, vpid);
+			if(dmx->vid_chan==-1) {
+				ret = -1;
+			}
+		}
+
+		spin_unlock_irqrestore(&dvb->slock, flags);
+
+		mutex_unlock(&dmx->dmxdev.mutex);
+	}
+
+	return ret;
+}
+
+/*Reset the audio PID*/
+static int aml_tsdemux_set_aid(int apid)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+	struct aml_dvb *dvb = &aml_dvb_device;
+	struct aml_dmx *dmx;
+	unsigned long flags;
+	int ret = 0;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	dmx = get_stb_dmx();
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	if(dmx) {
+		mutex_lock(&dmx->dmxdev.mutex);
+
+		spin_lock_irqsave(&dvb->slock, flags);
+
+		if(dmx->aud_chan!=-1) {
+			dmx_free_chan(dmx, dmx->aud_chan);
+			dmx->aud_chan = -1;
+		}
+
+		if((apid>=0) && (apid<0x1FFF)) {
+			dmx->aud_chan = dmx_alloc_chan(dmx, DMX_TYPE_TS, DMX_PES_AUDIO, apid);
+			if(dmx->aud_chan==-1) {
+				ret = -1;
+			}
+		}
+
+		spin_unlock_irqrestore(&dvb->slock, flags);
+
+		mutex_unlock(&dmx->dmxdev.mutex);
+	}
+
+	return ret;
+}
+
+/*Reset the subtitle PID*/
+static int aml_tsdemux_set_sid(int spid)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+	struct aml_dvb *dvb = &aml_dvb_device;
+	struct aml_dmx *dmx;
+	unsigned long flags;
+	int ret = 0;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	dmx = get_stb_dmx();
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	if(dmx) {
+		mutex_lock(&dmx->dmxdev.mutex);
+
+		spin_lock_irqsave(&dvb->slock, flags);
+
+		if(dmx->sub_chan!=-1) {
+			dmx_free_chan(dmx, dmx->sub_chan);
+			dmx->sub_chan = -1;
+		}
+
+		if((spid>=0) && (spid<0x1FFF)) {
+			dmx->sub_chan = dmx_alloc_chan(dmx, DMX_TYPE_TS, DMX_PES_SUBTITLE, spid);
+			if(dmx->sub_chan==-1) {
+				ret = -1;
+			}
+		}
+
+		spin_unlock_irqrestore(&dvb->slock, flags);
+
+		mutex_unlock(&dmx->dmxdev.mutex);
+	}
+
+	return ret;
+}
+
+static int aml_tsdemux_set_pcrid(int pcrpid)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+	struct aml_dvb *dvb = &aml_dvb_device;
+	struct aml_dmx *dmx;
+	unsigned long flags;
+	int ret = 0;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+
+	dmx = get_stb_dmx();
+
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	if(dmx) {
+		mutex_lock(&dmx->dmxdev.mutex);
+
+		spin_lock_irqsave(&dvb->slock, flags);
+
+		if(dmx->pcr_chan!=-1) {
+			dmx_free_chan(dmx, dmx->pcr_chan);
+			dmx->pcr_chan = -1;
+		}
+
+		if((pcrpid>=0) && (pcrpid<0x1FFF)) {
+			dmx->pcr_chan = dmx_alloc_chan(dmx, DMX_TYPE_TS, DMX_PES_PCR, pcrpid);
+			if(dmx->pcr_chan==-1) {
+				ret = -1;
+			}
+		}
+
+		spin_unlock_irqrestore(&dvb->slock, flags);
+
+		mutex_unlock(&dmx->dmxdev.mutex);
+	}
+
+	return ret;
+}
+
+static int aml_tsdemux_set_skipbyte(int skipbyte)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+	struct aml_dvb *dvb = &aml_dvb_device;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dvb->slock, flags);
+	aml_dmx_set_skipbyte(dvb, skipbyte);
+	spin_unlock_irqrestore(&dvb->slock, flags);
+
+	return 0;
+}
+
+static int aml_tsdemux_set_demux(int id)
+{
+	pr_dbg("%s: start\n", __func__);
+	
+	struct aml_dvb *dvb = &aml_dvb_device;
+
+	aml_dmx_set_demux(dvb, id);
+	return 0;
+}
+
+module_init(aml_dvb_init);
+module_exit(aml_dvb_exit);
+
+MODULE_DESCRIPTION("driver for the AMLogic DVB card");
+MODULE_AUTHOR("AMLOGIC");
+MODULE_LICENSE("GPL");
diff -Nur linux-95ba9d626c0fce672caa296f5911ab9190881642/drivers/amlogic/dvb-avl/aml_dvb.h linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/drivers/amlogic/dvb-avl/aml_dvb.h
--- linux-95ba9d626c0fce672caa296f5911ab9190881642/drivers/amlogic/dvb-avl/aml_dvb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/drivers/amlogic/dvb-avl/aml_dvb.h	2019-02-11 22:25:03.000000000 +0100
@@ -0,0 +1,330 @@
+#ifndef _AML_DVB_H_
+#define _AML_DVB_H_
+
+#include <linux/interrupt.h>
+#include <linux/socket.h>
+#include <linux/netdevice.h>
+#include <linux/i2c.h>
+
+#include <linux/dvb/video.h>
+#include <linux/dvb/audio.h>
+#include <linux/dvb/dmx.h>
+#include <linux/dvb/ca.h>
+#include <linux/dvb/osd.h>
+#include <linux/dvb/net.h>
+#include <linux/dvb/frontend.h>
+
+#include <linux/mutex.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+
+#include "dvbdev.h"
+#include "demux.h"
+#include "dvb_demux.h"
+#include "dmxdev.h"
+#include "dvb_filter.h"
+#include "dvb_net.h"
+#include "dvb_ringbuffer.h"
+#include "dvb_frontend.h"
+
+#include <linux/of.h>
+#include <linux/pinctrl/consumer.h>
+
+#define TS_IN_COUNT       3
+#define S2P_COUNT         2
+
+#define DMX_DEV_COUNT     3
+#define FE_DEV_COUNT      2
+#define CHANNEL_COUNT     31
+#define FILTER_COUNT      31
+#define FILTER_LEN        15
+#define DSC_DEV_COUNT     1
+#define DSC_COUNT         8
+#define SEC_BUF_GRP_COUNT 4
+#define SEC_BUF_BUSY_SIZE 4
+#define SEC_BUF_COUNT     (SEC_BUF_GRP_COUNT*8)
+#define ASYNCFIFO_COUNT   2
+
+
+enum aml_dmx_id_t {
+	AM_DMX_0 = 0,
+	AM_DMX_1,
+	AM_DMX_2,
+	AM_DMX_MAX,
+};
+
+enum aml_ts_source_t {
+	AM_TS_SRC_TS0,
+	AM_TS_SRC_TS1,
+	AM_TS_SRC_TS2,
+	AM_TS_SRC_S_TS0,
+	AM_TS_SRC_S_TS1,
+	AM_TS_SRC_S_TS2,
+	AM_TS_SRC_HIU,
+	AM_TS_SRC_DMX0,
+	AM_TS_SRC_DMX1,
+	AM_TS_SRC_DMX2
+};
+
+struct aml_sec_buf {
+	unsigned long        addr;
+	int                  len;
+};
+
+struct aml_channel {
+	int                  type;
+	enum dmx_ts_pes	pes_type;
+	int                  pid;
+	int                  used;
+	int                  filter_count;
+	struct dvb_demux_feed     *feed;
+	struct dvb_demux_feed     *dvr_feed;
+};
+
+struct aml_filter {
+	int                  chan_id;
+	int                  used;
+	struct dmx_section_filter *filter;
+	u8                   value[FILTER_LEN];
+	u8                   maskandmode[FILTER_LEN];
+	u8                   maskandnotmode[FILTER_LEN];
+	u8                   neq;
+};
+
+struct aml_dsc {
+	int                  pid;
+	u8                   even[8];
+	u8                   odd[8];
+	int                  used;
+	int                  set;
+	int                  id;
+	struct aml_dvb      *dvb;
+};
+
+struct aml_smallsec {
+	struct aml_dmx *dmx;
+
+	int	enable;
+	int	bufsize;
+#define SS_BUFSIZE_DEF (16*4*256) /*16KB*/
+	long	buf;
+	long	buf_map;
+};
+
+struct aml_dmxtimeout {
+	struct aml_dmx *dmx;
+
+	int	enable;
+
+	int	timeout;
+#define DTO_TIMEOUT_DEF (9000)       /*0.5s*/
+	u32	ch_disable;
+#define DTO_CHDIS_VAS   (0xfffffff8) /*v/a/s only*/
+	int	match;
+
+	int     trigger;
+};
+
+struct aml_dmx {
+	struct dvb_demux     demux;
+	struct dmxdev        dmxdev;
+	int                  id;
+	int                  feed_count;
+	int                  chan_count;
+	enum aml_ts_source_t      source;
+	int                  init;
+	int                  record;
+	struct dmx_frontend  hw_fe[DMX_DEV_COUNT];
+	struct dmx_frontend  mem_fe;
+	struct dvb_net       dvb_net;
+	int                  dmx_irq;
+	int                  dvr_irq;
+	struct tasklet_struct     dmx_tasklet;
+	struct tasklet_struct     dvr_tasklet;
+	unsigned long        sec_pages;
+	unsigned long        sec_pages_map;
+	int                  sec_total_len;
+	struct aml_sec_buf   sec_buf[SEC_BUF_COUNT];
+	unsigned long        pes_pages;
+	unsigned long        pes_pages_map;
+	int                  pes_buf_len;
+	unsigned long        sub_pages;
+	unsigned long        sub_pages_map;
+	int                  sub_buf_len;
+	struct aml_channel   channel[CHANNEL_COUNT];
+	struct aml_filter    filter[FILTER_COUNT];
+	irq_handler_t        irq_handler;
+	void                *irq_data;
+	int                  aud_chan;
+	int                  vid_chan;
+	int                  sub_chan;
+	int                  pcr_chan;
+	u32                  section_busy[SEC_BUF_BUSY_SIZE];
+	struct dvb_frontend *fe;
+	int                  int_check_count;
+	u32                  int_check_time;
+	int                  in_tune;
+	int                  error_check;
+	int                  dump_ts_select;
+	int                  sec_buf_watchdog_count[SEC_BUF_COUNT];
+
+	struct aml_smallsec  smallsec;
+	struct aml_dmxtimeout timeout;
+
+	int                  demux_filter_user;
+};
+
+struct aml_asyncfifo {
+	int	id;
+	int	init;
+	int	asyncfifo_irq;
+	enum aml_dmx_id_t	source;
+	unsigned long	pages;
+	unsigned long   pages_map;
+	int	buf_len;
+	int	buf_toggle;
+	int buf_read;
+	int flush_size;
+	struct tasklet_struct     asyncfifo_tasklet;
+	struct aml_dvb *dvb;
+};
+
+enum{
+	AM_TS_DISABLE,
+	AM_TS_PARALLEL,
+	AM_TS_SERIAL
+};
+
+struct aml_ts_input {
+	int                  mode;
+	struct pinctrl      *pinctrl;
+	int                  control;
+	int                  s2p_id;
+};
+
+struct aml_s2p {
+	int    invert;
+};
+
+struct aml_swfilter {
+	int    user;
+	struct aml_dmx *dmx;
+	struct aml_asyncfifo *afifo;
+
+	struct dvb_ringbuffer rbuf;
+#define SF_BUFFER_SIZE (10*188*1024)
+
+	u8     wrapbuf[188];
+	int    track_dmx;
+};
+
+struct aml_dvb {
+	struct dvb_device    dvb_dev;
+	struct aml_ts_input  ts[TS_IN_COUNT];
+	struct aml_s2p       s2p[S2P_COUNT];
+	struct aml_dmx       dmx[DMX_DEV_COUNT];
+	struct aml_dsc       dsc[DSC_COUNT];
+	struct aml_asyncfifo asyncfifo[ASYNCFIFO_COUNT];
+	struct dvb_device   *dsc_dev;
+	struct dvb_adapter   dvb_adapter;
+	struct device       *dev;
+	struct platform_device *pdev;
+	enum aml_ts_source_t      stb_source;
+	enum aml_ts_source_t      dsc_source;
+	enum aml_ts_source_t      tso_source;
+	int                  dmx_init;
+	int                  reset_flag;
+	spinlock_t           slock;
+	struct timer_list    watchdog_timer;
+	int                  dmx_watchdog_disable[DMX_DEV_COUNT];
+	struct aml_swfilter  swfilter;
+};
+
+
+/*AMLogic demux interface*/
+extern int aml_dmx_hw_init(struct aml_dmx *dmx);
+extern int aml_dmx_hw_deinit(struct aml_dmx *dmx);
+extern int aml_dmx_hw_start_feed(struct dvb_demux_feed *dvbdmxfeed);
+extern int aml_dmx_hw_stop_feed(struct dvb_demux_feed *dvbdmxfeed);
+extern int aml_dmx_hw_set_source(struct dmx_demux *demux, dmx_source_t src);
+extern int aml_stb_hw_set_source(struct aml_dvb *dvb, dmx_source_t src);
+extern int aml_dsc_hw_set_source(struct aml_dvb *dvb, dmx_source_t src);
+extern int aml_tso_hw_set_source(struct aml_dvb *dvb, dmx_source_t src);
+
+extern int aml_dmx_set_skipbyte(struct aml_dvb *dvb, int skipbyte);
+extern int aml_dmx_set_demux(struct aml_dvb *dvb, int id);
+extern int aml_dmx_hw_set_dump_ts_select
+		(struct dmx_demux *demux, int dump_ts_select);
+
+extern int  dmx_alloc_chan(struct aml_dmx *dmx, int type,
+				int pes_type, int pid);
+extern void dmx_free_chan(struct aml_dmx *dmx, int cid);
+
+extern int dmx_get_ts_serial(enum aml_ts_source_t src);
+
+
+/*AMLogic dsc interface*/
+extern int dsc_set_pid(struct aml_dsc *dsc, int pid);
+extern int dsc_set_key(struct aml_dsc *dsc, int type, u8 *key);
+extern int dsc_release(struct aml_dsc *dsc);
+
+/*AMLogic ASYNC FIFO interface*/
+extern int aml_asyncfifo_hw_init(struct aml_asyncfifo *afifo);
+extern int aml_asyncfifo_hw_deinit(struct aml_asyncfifo *afifo);
+extern int aml_asyncfifo_hw_set_source(struct aml_asyncfifo *afifo,
+					enum aml_dmx_id_t src);
+extern int aml_asyncfifo_hw_reset(struct aml_asyncfifo *afifo);
+
+/*Get the Audio & Video PTS*/
+extern u32 aml_dmx_get_video_pts(struct aml_dvb *dvb);
+extern u32 aml_dmx_get_audio_pts(struct aml_dvb *dvb);
+extern u32 aml_dmx_get_first_video_pts(struct aml_dvb *dvb);
+extern u32 aml_dmx_get_first_audio_pts(struct aml_dvb *dvb);
+
+/*Get the DVB device*/
+extern struct aml_dvb *aml_get_dvb_device(void);
+
+/*Demod interface*/
+extern void aml_dmx_register_frontend(enum aml_ts_source_t src,
+					struct dvb_frontend *fe);
+extern void aml_dmx_before_retune(enum aml_ts_source_t src,
+					struct dvb_frontend *fe);
+extern void aml_dmx_after_retune(enum aml_ts_source_t src,
+					struct dvb_frontend *fe);
+extern void aml_dmx_start_error_check(enum aml_ts_source_t src,
+					struct dvb_frontend *fe);
+extern int  aml_dmx_stop_error_check(enum aml_ts_source_t src,
+					struct dvb_frontend *fe);
+extern int aml_regist_dmx_class(void);
+extern int aml_unregist_dmx_class(void);
+extern void dvb_frontend_retune(struct dvb_frontend *fe);
+
+struct devio_aml_platform_data {
+	int (*io_setup)(void *);
+	int (*io_cleanup)(void *);
+	int (*io_power)(void *, int enable);
+	int (*io_reset)(void *, int enable);
+};
+
+/*Reset the demux device*/
+void dmx_reset_hw(struct aml_dvb *dvb);
+void dmx_reset_hw_ex(struct aml_dvb *dvb, int reset_irq);
+
+/*Reset the individual demux*/
+void dmx_reset_dmx_hw(struct aml_dvb *dvb, int id);
+void dmx_reset_dmx_id_hw_ex(struct aml_dvb *dvb, int id, int reset_irq);
+void dmx_reset_dmx_id_hw_ex_unlock(struct aml_dvb *dvb, int id, int reset_irq);
+void dmx_reset_dmx_hw_ex(struct aml_dvb *dvb,
+				struct aml_dmx *dmx,
+				int reset_irq);
+void dmx_reset_dmx_hw_ex_unlock(struct aml_dvb *dvb,
+				struct aml_dmx *dmx,
+				int reset_irq);
+
+#endif
+
diff -Nur linux-95ba9d626c0fce672caa296f5911ab9190881642/drivers/amlogic/dvb-avl/aml_fe.c linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/drivers/amlogic/dvb-avl/aml_fe.c
--- linux-95ba9d626c0fce672caa296f5911ab9190881642/drivers/amlogic/dvb-avl/aml_fe.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/drivers/amlogic/dvb-avl/aml_fe.c	2019-02-16 00:08:43.065091240 +0100
@@ -0,0 +1,354 @@
+/*
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+*/
+
+#ifndef CONFIG_ARM64
+#include <mach/am_regs.h>
+#else
+#include <linux/reset.h>
+#endif
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/firmware.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/version.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+
+#include "aml_fe.h"
+#include "avl6211.h"
+#include "aml_dvb.h"
+
+
+#ifdef CONFIG_ARM64
+/* Drivers may not strictly depend on the GPIO support, so let them link. */
+static inline struct gpio_desc *of_get_named_gpiod_flags	(struct device_node *np,
+		const char *list_name, int index, enum of_gpio_flags *flags)
+{
+	return ERR_PTR(-ENOSYS);
+}
+
+static inline int desc_to_gpio(const struct gpio_desc *desc)
+{
+	/* GPIO can never have been requested */
+	WARN_ON(1);
+	return -EINVAL;
+}
+#endif
+
+#undef pr_err
+
+#define pr_dbg(fmt, args...) \
+	do {\
+		if (debug_fe)\
+			printk("DVB aml_fe: " fmt, ##args);\
+	} while (0)
+#define pr_err(fmt, args...) printk("DVB aml_fe: ERROR: " fmt, ## args)
+#define pr_inf(fmt, args...) printk("DVB aml_fe: " fmt, ## args)
+
+MODULE_PARM_DESC(debug_fe, "\n\t\t Enable frontend debug information");
+static int debug_fe = 0;
+module_param(debug_fe, int, 0644);
+
+#ifdef CONFIG_ARM64
+MODULE_PARM_DESC(frontend_power, "\n\t\t Power GPIO of frontend");
+static int frontend_power = -1;
+module_param(frontend_power, int, 0644);
+
+MODULE_PARM_DESC(frontend_reset, "\n\t\t Reset GPIO of frontend");
+static int frontend_reset = -1;
+module_param(frontend_reset, int, 0644);
+#endif
+
+static struct aml_fe avl6211_fe[FE_DEV_COUNT];
+
+static char *device_name = "avl6211";
+
+int set_external_vol_gpio(int *demod_id, int on)
+{
+	pr_inf("%s: demod_id=%d on=%d\n", __func__, demod_id, on);
+	
+	int ret = 0;
+	
+	if (on)
+		on = 1;
+#ifdef CONFIG_ARM64
+	ret = gpio_direction_output(frontend_power, on);
+#else	
+	ret = amlogic_gpio_direction_output(GPIOB_21, on, device_name);
+	pr_inf("%s: GPIOB_21 on=%d ret=%d\n", __func__, on, ret);
+	ret = amlogic_gpio_direction_output(GPIOB_23, on, device_name);
+	pr_inf("%s: GPIOB_23 on=%d ret=%d\n", __func__, on, ret);
+/*
+	ret = amlogic_gpio_direction_output(GPIOAO_10, on, device_name);
+	pr_inf("%s: GPIOAO_10 on=%d ret=%d\n", __func__, on, ret);
+	ret = amlogic_gpio_direction_output(GPIOAO_11, on, device_name);
+	pr_inf("%s: GPIOAO_11 on=%d ret=%d\n", __func__, on, ret);
+	
+	ret = amlogic_gpio_direction_output(GPIOD_6, on, device_name);
+	pr_inf("%s: GPIOD_6 on=%d ret=%d\n", __func__, on, ret);
+*/
+#endif
+	
+	return ret;
+}
+
+static struct avl6211_config avl6211_config = {
+#ifndef CONFIG_ARM64
+		.tuner_address = 0xC0, /*.tuner_address = 0xC2,*/
+#else		
+		.tuner_address = 0xC4,
+		
+#endif
+		.tuner_i2c_clock = 200,
+		.demod_address = 0x0C,
+		.mpeg_pol = 1,
+		.mpeg_mode = 0,
+		.mpeg_format = 0,
+		.demod_refclk = 9,
+		.mpeg_pin = 0,
+		.tuner_rfagc = 1,
+		.tuner_spectrum = 0,
+		.use_lnb_pin59 = 1,
+		.use_lnb_pin60 = 0,
+		.set_external_vol_gpio = set_external_vol_gpio,
+};
+
+int avl6211_Reset(void)
+{	
+	pr_dbg("avl6211_Reset!\n");
+	int ret = 0;
+	
+#ifdef CONFIG_ARM64
+	gpio_request(frontend_reset,device_name);
+	gpio_direction_output(frontend_reset, 0);
+	msleep(600);
+	gpio_request(frontend_reset,device_name);
+	gpio_direction_output(frontend_reset, 1);
+	msleep(600);
+#else
+	ret=amlogic_gpio_direction_output(GPIOD_8, 0, device_name);
+	pr_inf("%s: GPIOD_8 on=%d ret=%d\n", __func__, 0, ret);
+	msleep(600);
+	ret=amlogic_gpio_direction_output(GPIOD_8, 1, device_name);
+	pr_inf("%s: GPIOD_8 on=%d ret=%d\n", __func__, 1, ret);
+	
+	msleep(600);
+#endif
+	
+	return 0;
+}
+
+int avl6211_gpio(void)
+{
+	pr_dbg("avl6211_gpio!\n");
+#ifdef CONFIG_ARM64
+	gpio_request(frontend_power,device_name);
+	gpio_direction_output(frontend_power, 1);
+#else
+	/* FEC_RESET */
+	amlogic_gpio_request(GPIOD_8, device_name);
+	
+	/* INPUT1 POWER CTRL */
+	/* amlogic_gpio_request(GPIOAO_10, device_name); */
+	
+	/* INPUT2 POWER CTRL */
+	/* amlogic_gpio_request(GPIOAO_11, device_name); */
+	
+	amlogic_gpio_request(GPIOB_21, device_name);
+	amlogic_gpio_request(GPIOB_23, device_name);
+	
+	//amlogic_gpio_direction_output(GPIOAO_8, 0, device_name); //SWITCH OFF INPUT1 POWER
+	
+	//amlogic_gpio_direction_output(GPIOAO_9, 0, device_name); //SWITCH OFF INPUT2 POWER
+	
+	/* INPUT1 POWER CTRL */
+	/* amlogic_gpio_request(GPIOD_6, device_name); */
+	
+	//amlogic_gpio_direction_output(GPIOD_6, 0, device_name); //SWITCH OFF INPUT1 POWER
+	
+	amlogic_gpio_direction_output(GPIOB_21, 0, device_name); //SWITCH OFF INPUT1 POWER
+	amlogic_gpio_direction_output(GPIOB_23, 0, device_name); //SWITCH OFF INPUT1 POWER
+	
+#endif
+	return 0;
+}
+
+static int avl6211_fe_init(struct aml_dvb *advb, struct platform_device *pdev, struct aml_fe *fe, int id)
+{
+	struct dvb_frontend_ops *ops;
+	int ret, i2c_adap_id = 1;
+
+	struct i2c_adapter *i2c_handle;
+#ifdef CONFIG_ARM64
+	struct gpio_desc *desc;
+	int gpio_reset, gpio_power;
+#endif
+	pr_inf("Init AVL6211 frontend %d\n", id);
+	
+#ifdef CONFIG_OF
+	if (of_property_read_u32(pdev->dev.of_node, "dtv_demod0_i2c_adap_id", &i2c_adap_id)) {
+		ret = -ENOMEM;
+		goto err_resource;
+	}
+	pr_dbg("i2c_adap_id=%d\n", i2c_adap_id);
+#ifdef CONFIG_ARM64
+	desc = of_get_named_gpiod_flags(pdev->dev.of_node, "dtv_demod0_reset_gpio-gpios", 0, NULL);
+	gpio_reset = desc_to_gpio(desc);
+	pr_dbg("gpio_reset=%d\n", gpio_reset);
+	
+	desc = of_get_named_gpiod_flags(pdev->dev.of_node, "dtv_demod0_power_gpio-gpios", 0, NULL);
+	gpio_power = desc_to_gpio(desc);
+	pr_dbg("gpio_power=%d\n", gpio_power);
+
+	frontend_reset = gpio_reset;
+	frontend_power = gpio_power;
+#endif
+#endif /*CONFIG_OF*/
+	i2c_handle = i2c_get_adapter(i2c_adap_id);
+
+	if (!i2c_handle) {
+		pr_err("Cannot get i2c adapter for id:%d! \n", i2c_adap_id);
+		ret = -ENOMEM;
+		goto err_resource;
+	}
+	
+	avl6211_gpio();
+	int d;
+	d = 0;
+	set_external_vol_gpio(&d, 1);
+	avl6211_Reset();
+	
+	fe->fe = dvb_attach(avl6211_attach, &avl6211_config, i2c_handle);
+
+	if (!fe->fe) {
+		pr_err("avl6211_attach attach failed!!!\n");
+		ret = -ENOMEM;
+		goto err_resource;
+	}
+
+	pr_dbg("AVL6211 and AV2011 attached!\n");
+
+	if ((ret=dvb_register_frontend(&advb->dvb_adapter, fe->fe))) {
+		pr_err("Frontend avl6211 registration failed!!!\n");
+		ops = &fe->fe->ops;
+		if (ops->release != NULL)
+			ops->release(fe->fe);
+		fe->fe = NULL;
+		ret = -ENOMEM;
+		goto err_resource;
+	}
+	
+	pr_inf("Frontend AVL6211 registred!\n");
+	
+	return 0;
+
+err_resource:
+	return ret;
+}
+
+static int avl6211_fe_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	struct aml_dvb *dvb = aml_get_dvb_device();
+
+	if(avl6211_fe_init(dvb, pdev, &avl6211_fe[0], 0)<0)
+		return -ENXIO;
+
+	platform_set_drvdata(pdev, &avl6211_fe[0]);
+
+	return ret;
+}
+
+static void avl6211_fe_release(struct aml_dvb *advb, struct aml_fe *fe)
+{
+	if(fe && fe->fe) {
+		dvb_unregister_frontend(fe->fe);
+		dvb_frontend_detach(fe->fe);
+	}
+}
+
+static int avl6211_fe_remove(struct platform_device *pdev)
+{
+	struct aml_fe *drv_data = platform_get_drvdata(pdev);
+	struct aml_dvb *dvb = aml_get_dvb_device();
+
+	amlogic_gpio_free(GPIOD_8, device_name);
+	
+	amlogic_gpio_free(GPIOD_6, device_name);
+	amlogic_gpio_free(GPIOAO_10, device_name);
+	amlogic_gpio_free(GPIOAO_11, device_name);
+
+	platform_set_drvdata(pdev, NULL);
+	avl6211_fe_release(dvb, drv_data);
+
+	return 0;
+}
+
+static int avl6211_fe_resume(struct platform_device *pdev)
+{
+	pr_dbg("avl6211_fe_resume \n");
+	return 0;
+}
+
+static int avl6211_fe_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	pr_dbg("avl6211_fe_suspend \n");
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id aml_fe_dt_match[]={
+	{
+		.compatible = "amlogic,dvbfe",
+	},
+	{},
+};
+#endif /*CONFIG_OF*/
+
+static struct platform_driver aml_fe_driver = {
+	.probe = avl6211_fe_probe,
+	.remove = avl6211_fe_remove,
+	.resume = avl6211_fe_resume,
+	.suspend = avl6211_fe_suspend,
+	.driver = {
+	.name = "avl6211",
+	.owner = THIS_MODULE,
+#ifdef CONFIG_OF
+	.of_match_table = aml_fe_dt_match,
+#endif
+	}
+};
+
+static int __init avlfrontend_init(void) {
+	return platform_driver_register(&aml_fe_driver);
+}
+
+static void __exit avlfrontend_exit(void) {
+	platform_driver_unregister(&aml_fe_driver);
+}
+
+module_init(avlfrontend_init);
+module_exit(avlfrontend_exit);
+MODULE_AUTHOR("emanuel");
+MODULE_DESCRIPTION("AVL6211 DVB-Sx frontend driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-95ba9d626c0fce672caa296f5911ab9190881642/drivers/amlogic/dvb-avl/aml_fe.h linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/drivers/amlogic/dvb-avl/aml_fe.h
--- linux-95ba9d626c0fce672caa296f5911ab9190881642/drivers/amlogic/dvb-avl/aml_fe.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/drivers/amlogic/dvb-avl/aml_fe.h	2019-02-11 22:25:03.000000000 +0100
@@ -0,0 +1,223 @@
+/*
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+*/
+#ifndef _AML_FE_H_
+#define _AML_FE_H_
+
+
+#include <linux/interrupt.h>
+#include <linux/socket.h>
+#include <linux/netdevice.h>
+#include <linux/i2c.h>
+
+#include <linux/dvb/video.h>
+#include <linux/dvb/audio.h>
+#include <linux/dvb/dmx.h>
+#include <linux/dvb/ca.h>
+#include <linux/dvb/osd.h>
+#include <linux/dvb/net.h>
+#include <linux/mutex.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+#include "dvbdev.h"
+#include "demux.h"
+#include "dvb_demux.h"
+#include "dmxdev.h"
+#include "dvb_filter.h"
+#include "dvb_net.h"
+#include "dvb_ringbuffer.h"
+#include "dvb_frontend.h"
+#include "aml_dvb.h"
+#include "linux/videodev2.h"
+
+#include <linux/amlogic/aml_gpio_consumer.h>
+
+#include <linux/of.h>
+#include <linux/of_fdt.h>
+#include <linux/pinctrl/consumer.h>
+
+enum aml_fe_mode_t {
+	AM_FE_UNKNOWN = 0,
+	AM_FE_QPSK = 1,
+	AM_FE_QAM = 2,
+	AM_FE_OFDM = 4,
+	AM_FE_ATSC = 8,
+	AM_FE_ANALOG = 16,
+	AM_FE_DTMB = 32,
+	AM_FE_ISDBT = 64
+};
+
+#define AM_FE_DTV_MASK (AM_FE_QPSK | AM_FE_QAM | AM_FE_OFDM | \
+			AM_FE_ATSC | AM_FE_DTMB | AM_FE_ISDBT)
+
+enum aml_tuner_type_t {
+	AM_TUNER_SI2176 = 1,
+	AM_TUNER_SI2196 = 2,
+	AM_TUNER_FQ1216 = 3,
+	AM_TUNER_HTM = 4,
+	AM_TUNER_CTC703 = 5,
+	AM_TUNER_SI2177 = 6,
+	AM_TUNER_R840 = 7,
+	AM_TUNER_SI2157 = 8,
+	AM_TUNER_SI2151 = 9,
+	AM_TUNER_MXL661 = 10
+};
+
+enum aml_atv_demod_type_t {
+	AM_ATV_DEMOD_SI2176 = 1,
+	AM_ATV_DEMOD_SI2196 = 2,
+	AM_ATV_DEMOD_FQ1216 = 3,
+	AM_ATV_DEMOD_HTM = 4,
+	AM_ATV_DEMOD_CTC703 = 5,
+	AM_ATV_DEMOD_SI2177 = 6,
+	AM_ATV_DEMOD_AML = 7,
+	AM_ATV_DEMOD_R840 = 8
+};
+
+enum aml_dtv_demod_type_t {
+	AM_DTV_DEMOD_M1 = 0,
+	AM_DTV_DEMOD_SI2176 = 1,
+	AM_DTV_DEMOD_MXL101 = 2,
+	AM_DTV_DEMOD_SI2196 = 3,
+	AM_DTV_DEMOD_AVL6211 = 4,
+	AM_DTV_DEMOD_SI2168 = 5,
+	AM_DTV_DEMOD_ITE9133 = 6,
+	AM_DTV_DEMOD_ITE9173 = 7,
+	AM_DTV_DEMOD_DIB8096 = 8,
+	AM_DTV_DEMOD_ATBM8869 = 9,
+	AM_DTV_DEMOD_MXL241 = 10,
+	AM_DTV_DEMOD_AVL68xx = 11,
+	AM_DTV_DEMOD_MXL683 = 12
+};
+
+enum aml_fe_dev_type_t {
+	AM_DEV_TUNER,
+	AM_DEV_ATV_DEMOD,
+	AM_DEV_DTV_DEMOD
+};
+
+struct aml_fe_dev;
+struct aml_fe;
+struct aml_fe_drv {
+	struct module *owner;
+	struct aml_fe_drv *next;
+	enum aml_tuner_type_t	id;
+	char *name;
+	int			capability;
+	int (*init)(struct aml_fe_dev *dev);
+	int (*release)(struct aml_fe_dev *dev);
+	int (*resume)(struct aml_fe_dev *dev);
+	int (*suspend)(struct aml_fe_dev *dev);
+	int (*get_ops)(struct aml_fe_dev *dev, int mode,
+					   void *ops);
+	int (*enter_mode)(struct aml_fe *fe, int mode);
+	int (*leave_mode)(struct aml_fe *fe, int mode);
+	int			ref;
+};
+
+struct aml_fe_dev {
+	/*point to parent aml_fe */
+	struct aml_fe *fe;
+	int			i2c_adap_id;
+	int			i2c_addr;
+	struct i2c_adapter *i2c_adap;
+	int			reset_gpio;
+	int			reset_value;
+	struct aml_fe_drv *drv;
+	wait_queue_head_t	lock_wq;
+	void *priv_data;
+
+	/*for tuner power control */
+	int			tuner_power_gpio;
+	/*for dtv dvbsx lnb power control */
+	int			lnb_power_gpio;
+	/*for ant overload control, */
+	/*it possible in dtv dvbsx and depond on fe hw */
+	int			antoverload_gpio;
+
+	/*for mem reserved*/
+	int			mem_start;
+	int			mem_end;
+
+	/*for dtv spectrum*/
+	int			spectrum;
+};
+struct aml_demod_param {
+	/*for tuner video if to amlatvdemod*/
+	unsigned int	if_freq;  /*HZ*/
+	/*for tuner output*/
+	unsigned int	if_inv;
+};
+
+struct aml_fe {
+	struct dvb_frontend *fe;
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct early_suspend		es;
+#endif                          /*CONFIG_HAS_EARLYSUSPEND */
+	spinlock_t			slock;
+	int				init;
+	int				mode;
+	int				dev_id;
+	int				capability;
+	enum aml_ts_source_t		ts;
+	struct aml_demod_param		demod_param;
+	struct aml_fe_dev *tuner;
+	struct aml_fe_dev *atv_demod;
+	struct aml_fe_dev *dtv_demod;
+	/*struct dvb_frontend_parameters params;*/
+	struct dtv_frontend_properties	params;
+};
+
+struct aml_fe_man {
+	struct aml_fe		fe[FE_DEV_COUNT];
+	struct aml_fe_dev	tuner[FE_DEV_COUNT];
+	struct aml_fe_dev	atv_demod[FE_DEV_COUNT];
+	struct aml_fe_dev	dtv_demod[FE_DEV_COUNT];
+	struct dvb_frontend	dev[FE_DEV_COUNT];
+	struct pinctrl *pinctrl;
+	struct platform_device *pdev;
+};
+
+extern int aml_register_fe_drv(enum aml_fe_dev_type_t	type,
+			       struct aml_fe_drv *drv);
+extern int aml_unregister_fe_drv(enum aml_fe_dev_type_t type,
+				 struct aml_fe_drv *drv);
+
+extern struct dvb_frontend *get_si2177_tuner(void);
+extern const char *soundsys_to_str(unsigned short soundsys);
+extern const char *audmode_to_str(unsigned short soundsys);
+extern const char *v4l2_std_to_str(v4l2_std_id std);
+extern const char *fe_type_to_str(enum fe_type type);
+
+extern int amlogic_gpio_name_map_num(const char *name);
+extern int amlogic_gpio_direction_output(unsigned int pin, int value,
+					 const char *owner);
+extern int amlogic_gpio_request(unsigned int pin, const char *label);
+
+/* vdac ctrl,adc/dac ref signal,cvbs out signal
+ * module index: atv demod:0x01; dtv demod:0x02; tvafe:0x4; dac:0x8
+*/
+extern void vdac_enable(bool on, unsigned int module_sel);
+extern void set_aft_thread_enable(int enable);
+
+int set_external_vol_gpio(int *demod_id, int on);
+#endif /*_AML_FE_H_*/
diff -Nur linux-95ba9d626c0fce672caa296f5911ab9190881642/drivers/amlogic/dvb-avl/avl6211.c linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/drivers/amlogic/dvb-avl/avl6211.c
--- linux-95ba9d626c0fce672caa296f5911ab9190881642/drivers/amlogic/dvb-avl/avl6211.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/drivers/amlogic/dvb-avl/avl6211.c	2019-02-11 22:25:03.000000000 +0100
@@ -0,0 +1,1978 @@
+/*
+ * Driver for the Availink AVL6211+AV2011 DVB-S/S2 demod+tuner
+ *
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/firmware.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/version.h>
+
+#include "dvb_frontend.h"
+#include "avl6211_reg.h"
+#include "avl6211.h"
+
+
+const struct avl6211_pllconf pll_conf[] = {
+	/* The following set of PLL configuration at different reference clock frequencies refer to demod operation */
+	/* in standard performance mode. */
+	 { 503,  1, 7, 4, 2,  4000, 11200, 16800, 25200 } /* Reference clock 4 MHz,   Demod clock 112 MHz, FEC clock 168 MHz, MPEG clock 252 MHz */
+	,{ 447,  1, 7, 4, 2,  4500, 11200, 16800, 25200 } /* Reference clock 4.5 MHz, Demod clock 112 MHz, FEC clock 168 MHz, MPEG clock 252 MHz */
+	,{ 503,  4, 7, 4, 2, 10000, 11200, 16800, 25200 } /* Reference clock 10 MHz,  Demod clock 112 MHz, FEC clock 168 MHz, MPEG clock 252 MHz */
+	,{ 503,  7, 7, 4, 2, 16000, 11200, 16800, 25200 } /* Reference clock 16 MHz,  Demod clock 112 MHz, FEC clock 168 MHz, MPEG clock 252 MHz */
+	,{ 111,  2, 7, 4, 2, 27000, 11200, 16800, 25200 } /* Reference clock 27 MHz,  Demod clock 112 MHz, FEC clock 168 MHz, MPEG clock 252 MHz */
+	
+	/* The following set of PLL configuration at different reference clock frequencies refer to demod operation */
+	/* in high performance mode. */
+	,{ 566,  1, 7, 4, 2,  4000, 12600, 18900, 28350 } /* Reference clock 4 MHz,   Demod clock 126 MHz, FEC clock 189 MHz, MPEG clock 283.5 MHz */
+	,{ 503,  1, 7, 4, 2,  4500, 12600, 18900, 28350 } /* Reference clock 4.5 MHz, Demod clock 126 MHz, FEC clock 189 MHz, MPEG clock 283.5 MHz */
+	,{ 566,  4, 7, 4, 2, 10000, 12600, 18900, 28350 } /* Reference clock 10 MHz,  Demod clock 126 MHz, FEC clock 189 MHz, MPEG clock 283.5 MHz */
+	,{ 566,  7, 7, 4, 2, 16000, 12600, 18900, 28350 } /* Reference clock 16 MHz,  Demod clock 126 MHz, FEC clock 189 MHz, MPEG clock 283.5 MHz */
+	,{ 377,  8, 7, 4, 2, 27000, 12600, 18900, 28350 } /* Reference clock 27 MHz,  Demod clock 126 MHz, FEC clock 189 MHz, MPEG clock 283.5 MHz */
+};
+
+const unsigned short pll_array_size = sizeof(pll_conf) / sizeof(struct avl6211_pllconf);
+
+struct avl6211_state
+{
+	struct i2c_adapter* i2c;
+	struct avl6211_config* config;
+	struct dvb_frontend frontend;
+	
+	u8 diseqc_status;
+	u16 locked;
+	u32 frequency;
+	u32 symbol_rate;	
+	u32 flags;
+	
+	int demod_id;
+	
+	u16 tuner_lpf;
+	u16 demod_freq;	/* Demod clock in 10kHz units */
+	u16 fec_freq;	/* FEC clock in 10kHz units */
+	u16 mpeg_freq;	/* MPEG clock in 10kHz units */
+	
+	bool boot;
+	bool gpio_on;
+};
+struct avl6211_diseqc_tx_status
+{
+	u8 tx_done;		
+	u8 tx_fifo_cnt;
+};
+static u16 extract_16(const u8 * buf)
+{
+	u16 data;
+	data = buf[0];
+	data = (u16)(data << 8) + buf[1];
+	return data;
+}
+static u32 extract_32(const u8 * buf)
+{
+	unsigned int data;
+	data = buf[0];
+	data = (data << 8) + buf[1];
+	data = (data << 8) + buf[2];
+	data = (data << 8) + buf[3];
+	return data;
+}
+static int avl6211_i2c_writereg(struct avl6211_state *state, u8 *data, u16 *size)
+{
+	int ret;
+	struct i2c_msg msg[1] = {
+			{
+				.addr = state->config->demod_address, 
+				.flags = 0,
+				.buf = data,
+				.len = *size,
+			}
+	};
+	
+	ret = i2c_transfer(state->i2c, msg, 1);	
+	if (ret == 1) {
+		ret = 0;
+	} else {
+		dev_warn(&state->i2c->dev, "i2c wr failed=%d", ret);
+		ret = -EREMOTEIO;
+	}
+	
+	return ret;
+}
+static int avl6211_i2c_readreg(struct avl6211_state* state, u8 * data, u16 * size)
+{
+	int ret;
+	struct i2c_msg msg[1] = {
+			{
+					.addr = state->config->demod_address, 
+					.flags = I2C_M_RD,
+					.buf = data,
+					.len = *size,
+			}
+	};
+
+	ret = i2c_transfer(state->i2c, msg, 1);
+	
+	if (ret == 1) {
+		ret = 0;
+	} else {
+		dev_warn(&state->i2c->dev, "i2c rd failed=%d", ret);
+		ret = -EREMOTEIO;
+	}
+	
+	return ret;
+}
+static int avl6211_i2c_read(struct avl6211_state* state, u32 offset, u8 * buf, u16 buf_size)
+{
+	int ret;
+	u8 buf_tmp[3];
+	u16 x1 = 3, x2 = 0;
+	u16 size;
+
+	format_addr(offset, buf_tmp);
+	ret = avl6211_i2c_writereg(state, buf_tmp, &x1);  
+	if (ret)
+		goto err;
+
+	if (buf_size & 1)
+		size = buf_size - 1;
+	else
+		size = buf_size;
+
+	while (size > I2C_MAX_READ) {
+		x1 = I2C_MAX_READ;
+		ret = avl6211_i2c_readreg(state, buf + x2, &x1);
+		if (ret)
+			goto err;			
+		x2 += I2C_MAX_READ;
+		size -= I2C_MAX_READ;
+	}
+
+	if (size != 0) {
+		ret = avl6211_i2c_readreg(state, buf + x2, &size);
+		if (ret)
+			goto err;
+	}
+
+	if (buf_size & 1) {
+		x1 = 2;
+		ret = avl6211_i2c_readreg(state, buf_tmp, &x1);
+		if (ret)
+			goto err;
+		buf[buf_size-1] = buf_tmp[0];
+	}
+	
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_i2c_write(struct avl6211_state* state, u8 * buf, u16 buf_size)
+{
+	int ret;
+	u8 buf_tmp[5], *x3;
+	u16 x1, x2 = 0, tmp;
+	u16 size;
+	u32 addr;
+
+	if (WARN_ON(buf_size < 3))
+		return -EINVAL;	
+		
+	/* Actual data size */
+	buf_size -= 3;
+	/* Dump address */
+	addr = buf[0];
+	addr = addr << 8;
+	addr += buf[1];
+	addr = addr << 8;
+	addr += buf[2];
+	
+	if (buf_size & 1)
+		size = buf_size -1;
+	else
+		size = buf_size;
+	
+	tmp = (I2C_MAX_WRITE - 3) & 0xfffe; /* How many bytes data we can transfer every time */
+	
+	x2 = 0;
+	while( size > tmp ) {
+		x1 = tmp + 3;
+		/* Save the data */
+		buf_tmp[0] = buf[x2];
+		buf_tmp[1] = buf[x2 + 1];
+		buf_tmp[2] = buf[x2 + 2];
+		x3 = buf + x2;
+		format_addr(addr, x3);
+		ret = avl6211_i2c_writereg(state, buf + x2, &x1);
+		if (ret)
+			goto err;
+		/* Restore data */
+		buf[x2] = buf_tmp[0];
+		buf[x2 + 1] = buf_tmp[1];
+		buf[x2 + 2] = buf_tmp[2];
+		addr += tmp;
+		x2 += tmp;
+		size -= tmp;
+	}
+
+	x1 = size + 3;
+	/* Save the data */
+	buf_tmp[0] = buf[x2];
+	buf_tmp[1] = buf[x2 + 1];
+	buf_tmp[2] = buf[x2 + 2];
+	x3 = buf + x2;
+	format_addr(addr, x3);
+	ret = avl6211_i2c_writereg(state, buf + x2, &x1);
+	if (ret)
+		goto err;
+	/* Restore data */
+	buf[x2] = buf_tmp[0];
+	buf[x2 + 1] = buf_tmp[1];
+	buf[x2 + 2] = buf_tmp[2];
+	addr += size;
+	x2 += size;
+		
+	if (buf_size & 1) {
+		format_addr(addr, buf_tmp);
+		x1 = 3;
+		ret = avl6211_i2c_writereg(state, buf_tmp, &x1);
+		if (ret)
+			goto err;
+		x1 = 2;
+		ret = avl6211_i2c_readreg(state, buf_tmp + 3, &x1);
+			goto err;
+		buf_tmp[3] = buf[x2 + 3];
+		x1 = 5;
+		ret = avl6211_i2c_writereg(state, buf_tmp, &x1);
+		if (ret)
+			goto err;
+	}
+		
+	return 0;
+
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_i2c_read16(struct avl6211_state* state, u32 addr, u16 *data)
+{
+	int ret;
+	u8 buf[2];
+
+	ret = avl6211_i2c_read(state, addr, buf, 2);
+	if (ret)
+		goto err;
+		
+	*data = extract_16(buf);
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_i2c_read32(struct avl6211_state* state, u32 addr, u32 *data)
+{
+	int ret;
+	u8 buf[4];
+
+	ret = avl6211_i2c_read(state, addr, buf, 4);
+	if (ret)
+		goto err;
+		
+	*data = extract_32(buf);
+
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_i2c_write16(struct avl6211_state* state, u32 addr, u16 data)
+{
+	int ret;
+	u8 buf[5], *p;
+
+	format_addr(addr, buf);
+	p = buf + 3;
+	format_16(data, p);
+
+	ret = avl6211_i2c_write(state, buf, 5);
+	if (ret)
+		goto err;
+		
+	return 0;
+
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_i2c_write32(struct avl6211_state* state, u32 addr, u32 data)
+{
+	int ret;
+	u8 buf[7], *p;
+
+	format_addr(addr, buf);
+	p = buf + 3;
+	format_32(data, p);
+	ret = avl6211_i2c_write(state, buf, 7);
+	if (ret)
+		goto err;
+		
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_get_op_status(struct avl6211_state* state)
+{
+	int ret;
+	u8 buf[2];
+
+	ret = avl6211_i2c_read(state, rx_cmd_addr, buf, 2);
+	if (ret)
+		goto err;
+		
+	if (buf[1] != 0) {
+		ret = -EINVAL;
+		goto err;
+	}
+	
+	return 0;
+err:	
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_send_op(u8 ucOpCmd, struct avl6211_state* state)
+{
+	int ret;
+	u8 buf[2];
+	u16 x1;
+	int cnt = 20;
+
+	do {
+		ret = avl6211_get_op_status(state);
+		if (!ret)
+			break;
+	
+		msleep(10);
+		cnt--;
+	} while (cnt != 0);
+	
+	if (ret)
+		goto err;
+		
+	buf[0] = 0;
+	buf[1] = ucOpCmd;
+	x1 = extract_16(buf);
+	ret = avl6211_i2c_write16(state, rx_cmd_addr, x1);   
+	if (ret)
+		goto err;
+		
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_i2c_repeater_get_status(struct avl6211_state* state)
+{
+	int ret;
+	u8 buf[2];
+
+	ret = avl6211_i2c_read(state, i2cm_cmd_addr + I2CM_CMD_LENGTH - 2, buf, 2);
+	if (ret)
+		goto err;
+		
+	if (buf[1] != 0) {
+		ret = -EINVAL;
+		goto err;
+	}
+		
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int avl6211_i2c_repeater_exec(struct avl6211_state* state, u8 * buf, u8 size)
+{
+	int ret, i = 0;
+
+	do {
+		ret = avl6211_i2c_repeater_get_status(state);
+		if (ret && 60 < i++) 
+			goto err;
+			
+		msleep(5);
+	
+	} while (ret);
+	
+	ret = avl6211_i2c_write(state, buf, size);
+	if (ret)
+		goto err;
+		
+	return 0;
+
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_i2c_repeater_send(struct avl6211_state* state, u8 * buf, u16 size)
+{
+	int ret;
+	u8 tmp_buf[I2CM_CMD_LENGTH + 3];
+	u16 i, j;
+	u16 cmd_size;
+
+	if (WARN_ON(size > I2CM_CMD_LENGTH - 3))
+		return -EINVAL;
+
+	memset(tmp_buf, 0, sizeof(tmp_buf));
+	
+	cmd_size = ((size + 3) % 2) + 3 + size;
+	format_addr(i2cm_cmd_addr + I2CM_CMD_LENGTH - cmd_size, tmp_buf);
+
+	i = 3 + ((3 + size) % 2);	  /* skip one byte if the size +3 is odd */
+
+	for (j = 0; j < size; j++)
+		tmp_buf[i++] = buf[j];
+
+	tmp_buf[i++] = (u8)size;
+	tmp_buf[i++] = state->config->tuner_address;
+	tmp_buf[i++] = OP_I2CM_WRITE;
+
+			
+	ret = avl6211_i2c_repeater_exec(state, tmp_buf, (u8)(cmd_size + 3));
+	if (ret)
+		goto err;
+		
+	return 0;
+
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int avl6211_i2c_repeater_recv(struct avl6211_state* state, u8 * buf, u16 size)
+{
+	int ret, i = 0;
+	u8 tmp_buf[I2CM_RSP_LENGTH];
+
+	if (WARN_ON(size > I2CM_RSP_LENGTH))
+		return -EINVAL;
+
+	memset(tmp_buf, 0, sizeof(tmp_buf));
+	
+	format_addr(i2cm_cmd_addr + I2CM_CMD_LENGTH - 4, tmp_buf);
+	tmp_buf[3] = 0x0;
+	tmp_buf[4] = (u8)size;
+	tmp_buf[5] = state->config->tuner_address;
+	tmp_buf[6] = OP_I2CM_READ;
+
+	ret = avl6211_i2c_repeater_exec(state, tmp_buf, 7);
+	if (ret)
+		goto err;
+	
+	do {
+		ret = avl6211_i2c_repeater_get_status(state);
+		if (ret && 100 < i++) 
+			goto err;
+			
+		msleep(10);
+	
+	} while (ret);
+
+	ret = avl6211_i2c_read(state, i2cm_rsp_addr, buf, size);
+	if (ret)
+		goto err;
+		
+	return 0;
+
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_i2c_repeater_init(u16 bus_clk, struct avl6211_state* state)
+{
+	u8 buf[5];
+	int ret;
+
+	ret = avl6211_i2c_write16(state, rc_i2cm_speed_kHz_addr, bus_clk);
+	if (ret)
+		goto err;
+		
+	format_addr(i2cm_cmd_addr + I2CM_CMD_LENGTH - 2, buf);
+	buf[3] = 0x01;
+	buf[4] = OP_I2CM_INIT;
+	ret = avl6211_i2c_repeater_exec(state, buf, 5);
+	if (ret)
+		goto err;
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int AV2011_I2C_write(u8 reg_start, u8* buff, u8 len, struct avl6211_state* state)
+{
+	int ret, i = 0;
+	u8 ucTemp[50] = { 0 };
+	
+	msleep(5);
+	ucTemp[0] = reg_start;
+	ret = avl6211_i2c_repeater_get_status(state);
+	
+	do {
+		ret = avl6211_i2c_repeater_get_status(state);
+		if (ret && 100 < i++) 
+			goto err;
+			
+		msleep(1);
+	
+	} while (ret);
+		
+	for (i = 1; i < len + 1; i++)			
+		ucTemp[i] = *(buff + i - 1);
+			
+	ret = avl6211_i2c_repeater_send(state, ucTemp, len+1);
+	if (ret)
+		goto err;
+	
+	msleep(5);
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int av2011_tuner_lock_status(struct dvb_frontend* fe)
+{
+	struct avl6211_state *state = fe->demodulator_priv;	
+	int ret;
+	u8 lock = 0x0b;
+	u8 locked = 0;
+	ret = avl6211_i2c_repeater_send(state, &lock, 1);
+	if (ret)
+		goto err;
+		
+	ret = avl6211_i2c_repeater_recv(state, &locked, 1);
+	if (ret)
+		goto err;
+
+	if (!(locked & 0x01)) 
+		return -EINVAL;
+		
+	return 0;
+
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int av2011_lock(struct dvb_frontend* fe)
+{
+	int ret;
+	struct avl6211_state *state = fe->demodulator_priv;	
+	u8 reg[50];
+	u32 fracN;
+	u32 BW;
+	u32 BF;
+	u32 freq = state->frequency / 1000;
+	u32 LPF = state->tuner_lpf * 100;
+
+	memset(reg, 0, sizeof(reg));
+
+	msleep(50);
+	
+	fracN = (freq + 27/2) / 27;
+	if (fracN > 0xff)
+		fracN = 0xff;
+		
+	reg[0] = (char)(fracN & 0xff);
+	fracN = (freq << 17) / 27;
+	fracN = fracN & 0x1ffff;
+	reg[1] = (char)((fracN >> 9) & 0xff);
+	reg[2] = (char)((fracN >> 1) & 0xff);
+	reg[3] = (char)((fracN << 7) & 0x80) | 0x50;
+
+	BW = (LPF * 135) / 200;
+	if (LPF < 6500)
+		BW = BW + 6000;
+   	BW = BW + 2000;
+	BW = BW*108/100;
+
+	if (BW < 4000)
+		BW = 4000;
+	if ( BW > 40000)
+		BW = 40000;
+	BF = (BW * 127 + 21100/2) / 21100; 
+	
+	dev_dbg(&state->i2c->dev, "BF is %d,BW is %d\n", BF, BW);
+	
+	reg[5] = (u8)BF;
+
+	msleep(5);
+	ret = AV2011_I2C_write(0, reg, 4, state);
+	if (ret)
+		goto err;
+		
+	msleep(5);
+		
+	ret = AV2011_I2C_write(5, reg+5, 1, state);
+	if (ret)
+		goto err;
+		
+	msleep(5);
+			
+	reg[37] = 0x06;
+	ret = AV2011_I2C_write(37, reg+37, 1, state);
+	if (ret)
+		goto err;;
+		
+	msleep(5);
+		
+	reg[12] = 0x96 + (1 << 6);
+	ret = AV2011_I2C_write(12, reg+12, 1, state);
+	if (ret)
+		goto err;
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int av2011_tuner_reg_init(struct dvb_frontend* fe)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+    int ret;
+	
+	u8 reg[50] = { 
+		0x38, 0x00, 0x00, 0x50, 0x1f, 0xa3, 0xfd, 0x58, 0x0e,
+		0xc2, 0x88, 0xb4, 0xd6, 0x40, 0x94, 0x9a, 0x66, 0x40,
+		0x80, 0x2b, 0x6a, 0x50, 0x91, 0x27, 0x8f, 0xcc, 0x21,
+		0x10, 0x80, 0x02, 0xf5, 0x7f, 0x4a, 0x9b, 0xe0, 0xe0,
+		0x36, 0x00, 0xab, 0x97, 0xc5, 0xa8,
+	};
+	
+	ret = AV2011_I2C_write(0, reg, 12, state);
+	if (ret)
+		goto err;
+		
+	msleep(1);
+		
+	ret = AV2011_I2C_write(13, reg+13, 12, state);
+	if (ret)
+		goto err;
+		
+	ret = AV2011_I2C_write(25, reg+25, 11, state);
+	if (ret)
+		goto err;
+		
+	ret = AV2011_I2C_write(36, reg+36, 6, state);
+	if (ret)
+		goto err;
+		
+	msleep(1);
+		
+	ret = AV2011_I2C_write(12, reg+12, 1, state);
+	if (ret)
+		goto err;
+		
+	msleep(10);
+	
+	ret = AV2011_I2C_write(0, reg, 12, state);
+	if (ret)
+		goto err;
+			
+	msleep(1);
+					
+	ret = AV2011_I2C_write(13, reg+13 , 12, state);
+	if (ret)
+		goto err;
+			
+	ret = AV2011_I2C_write(25, reg+25 , 11, state);
+	if (ret)
+		goto err;
+			
+	ret = AV2011_I2C_write(36, reg+36, 6, state);
+	if (ret)
+		goto err;
+			
+	msleep(1);
+		
+	ret = AV2011_I2C_write(12, reg+12, 1, state);
+	if (ret)
+		goto err;
+		
+	msleep(5);
+	
+	return 0;
+
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int av2011_tuner_init(struct dvb_frontend* fe) 
+{
+    struct avl6211_state *state = fe->demodulator_priv;
+    int ret;
+	
+    ret = avl6211_i2c_write16(state, rc_tuner_slave_addr_addr, state->config->tuner_address);
+	if (ret)
+		goto err;
+	/* Use external control */
+	ret = avl6211_i2c_write16(state, rc_tuner_use_internal_control_addr, 0);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write16(state, rc_tuner_LPF_margin_100kHz_addr, 0);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write16(state, rc_tuner_max_LPF_100kHz_addr, 360 );
+	if (ret)
+		goto err;
+	
+    ret = avl6211_i2c_repeater_init(state->config->tuner_i2c_clock, state);
+	if (ret)
+		goto err;
+
+	ret = av2011_tuner_reg_init(fe);
+	if (ret)
+		goto err;
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+    return ret;
+}
+
+static int avl6211_diseqc_init(struct dvb_frontend* fe)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u32 x1;
+	
+	ret = avl6211_i2c_write32(state, diseqc_srst_addr, 1);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, diseqc_samp_frac_n_addr, 200);	/* 2M = 200 * 10kHz */
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, diseqc_samp_frac_d_addr, state->demod_freq);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, diseqc_tone_frac_n_addr, (22 << 1));
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, diseqc_tone_frac_d_addr, state->demod_freq * 10);
+	if (ret)
+		goto err;
+
+	/* Initialize the tx_control */
+	ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+	if (ret)
+		goto err;
+	x1 &= 0x00000300;
+	x1 |= 0x20;		/* Reset tx_fifo */
+	x1 |= (u32)(0 << 6);
+	x1 |= (u32)(0 << 4);
+	x1 |= (1 << 3);			/* Enable tx gap */
+	ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+	if (ret)
+		goto err;
+	x1 &= ~(0x20);	/* Release tx_fifo reset */
+	ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+	if (ret)
+		goto err;
+
+	/* Initialize the rx_control */
+	x1 = (u32)(0 << 2);
+	x1 |= (1 << 1);	/* Activate the receiver */
+	x1 |= (1 << 3);	/* Envelop high when tone present */
+	ret = avl6211_i2c_write32(state, diseqc_rx_cntrl_addr, x1);
+	if (ret)
+		goto err;
+	x1 = (u32)(0 >> 12);
+	ret = avl6211_i2c_write32(state, diseqc_rx_msg_tim_addr, x1);
+	if (ret)
+		goto err;
+
+	ret = avl6211_i2c_write32(state, diseqc_srst_addr, 0);
+	if (ret)
+		goto err;
+
+	
+	state->diseqc_status = DISEQC_STATUS_INIT;
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_diseqc_switch_mode(struct dvb_frontend* fe)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret = 0;
+	u32 x1;
+
+	switch (state->diseqc_status) {
+		case DISEQC_STATUS_MOD:
+		case DISEQC_STATUS_TONE:
+			ret = avl6211_i2c_read32(state, diseqc_tx_st_addr, &x1);
+			if (ret)
+				goto err;
+			if (((x1 & 0x00000040) >> 6) != 1)
+				ret = -EINVAL;
+			break;
+		case DISEQC_STATUS_CONTINUOUS:
+		case DISEQC_STATUS_INIT:
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+	}
+	if (ret)
+		goto err;
+	
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_diseqc_get_tx_status(struct dvb_frontend* fe, struct avl6211_diseqc_tx_status * pTxStatus)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u32 x1;
+
+	if ((state->diseqc_status == DISEQC_STATUS_MOD) || 
+		(state->diseqc_status == DISEQC_STATUS_TONE)) {
+		ret = avl6211_i2c_read32(state, diseqc_tx_st_addr, &x1);
+		if (ret)
+			goto err;
+			
+		pTxStatus->tx_done = (u8)((x1 & 0x00000040) >> 6);
+		pTxStatus->tx_fifo_cnt = (u8)((x1 & 0x0000003c) >> 2);
+	}
+	else
+		ret = -EINVAL;
+
+	if (ret)
+		goto err;
+	
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_diseqc_send_mod_data(struct dvb_frontend* fe, const u8 * buf, u8 size)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u32 x1, x2;
+	int cnt = 0;
+	u8 buf_tmp[8];
+	u8 Continuousflag = 0;
+
+
+	if (WARN_ON(size > 8))
+		return -EINVAL;		
+	else {
+		ret = avl6211_diseqc_switch_mode(fe);
+		if (ret)
+			goto err;
+		
+		if (state->diseqc_status == DISEQC_STATUS_CONTINUOUS) {
+			ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+			if (ret)
+				goto err;
+			if ((x1 >> 10) & 0x01) {
+				Continuousflag = 1;
+				x1 &= 0xfffff3ff;
+				ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+				if (ret)
+					goto err;
+				msleep(20);
+			}
+		}
+			/* Reset rx_fifo */
+		ret = avl6211_i2c_read32(state, diseqc_rx_cntrl_addr, &x2);
+		if (ret)
+			goto err;
+		ret = avl6211_i2c_write32(state, diseqc_rx_cntrl_addr, (x2 | 0x01));
+		if (ret)
+			goto err;
+		ret = avl6211_i2c_write32(state, diseqc_rx_cntrl_addr, (x2 & 0xfffffffe));
+		if (ret)
+			goto err;
+
+		ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+		if (ret)
+			goto err;
+		x1 &= 0xfffffff8;	//set to modulation mode and put it to FIFO load mode
+		ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+		if (ret)
+			goto err;
+			
+			/* Trunk address */
+		format_addr(diseqc_tx_fifo_map_addr, buf_tmp);
+		buf_tmp[3] = 0;
+		buf_tmp[4] = 0;
+		buf_tmp[5] = 0;
+		for (x2 = 0; x2 < size; x2++) {
+			buf_tmp[6] = buf[x2];
+			ret = avl6211_i2c_write(state, buf_tmp, 7);
+			if (ret)
+				goto err;
+		}
+
+		x1 |= (1 << 2);  //start fifo transmit.
+		ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+		if (ret)
+			goto err;
+		
+		state->diseqc_status = DISEQC_STATUS_MOD;
+		do 
+		{
+			msleep(1);
+			if (++cnt > 500) {
+				ret = -ETIME;
+				goto err;
+			}
+			ret = avl6211_i2c_read32(state, diseqc_tx_st_addr, &x1);
+			if (ret)
+				goto err;
+		} while ( 1 != ((x1 & 0x00000040) >> 6) );
+
+		msleep(20);
+		if (Continuousflag == 1)			//resume to send out wave
+		{
+			//No data in FIFO
+			ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+			if (ret)
+				goto err;
+			x1 &= 0xfffffff8; 
+			x1 |= 0x03;		//switch to continuous mode
+			ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+			if (ret)
+				goto err;
+
+			//start to send out wave
+			x1 |= (1<<10);  
+			ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+			if (ret)
+				goto err;
+			
+			state->diseqc_status = DISEQC_STATUS_CONTINUOUS;
+		}
+	}
+
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;;
+}
+
+static int avl6211_send_diseqc_msg(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd *d)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	struct avl6211_diseqc_tx_status tx_status;
+	int cnt = 100;
+	int ret;
+
+	if ((d->msg_len < 3) || (d->msg_len > 6))
+        	return -EINVAL;
+
+	ret = avl6211_diseqc_send_mod_data(fe, d->msg, d->msg_len);
+	if (ret)
+		goto err;
+	
+	msleep(55);		
+		
+	do {
+		ret = avl6211_diseqc_get_tx_status(fe, &tx_status);
+		if (ret)
+			goto err;
+			
+		if ( tx_status.tx_done == 1 )
+			break;
+
+		msleep(10);
+		cnt--;
+		if (!cnt) {
+			ret = -ETIME;
+			goto err;
+		}
+	} while (tx_status.tx_done != 1);
+
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int avl6211_diseqc_send_burst(struct dvb_frontend* fe, enum fe_sec_mini_cmd burst)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	struct avl6211_diseqc_tx_status tx_status;
+	int cnt = 100;
+	int tx_cnt = 0;
+	int ret;
+	u32 x1;
+	u8 buf[8];
+	u8 Continuousflag = 0;
+	
+	ret = avl6211_diseqc_switch_mode(fe);
+	if (ret)
+		goto err;
+
+	if (state->diseqc_status == DISEQC_STATUS_CONTINUOUS) {
+		ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+		if (ret)
+			goto err;
+		if ((x1 >> 10) & 0x01) {
+			Continuousflag = 1;
+			x1 &= 0xfffff3ff;
+			ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+			if (ret)
+				goto err;
+			msleep(20);
+		}
+	}
+	/* No data in the FIFO */
+	ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+	if (ret)
+		goto err;
+	x1 &= 0xfffffff8;  /* Put it into the FIFO load mode */
+	if (burst == SEC_MINI_A)
+		x1 |= 0x02;
+	else
+		x1 |= 0x01;
+	ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+	if (ret)
+		goto err;
+	/* Trunk address */
+	format_addr(diseqc_tx_fifo_map_addr, buf);
+	buf[3] = 0;
+	buf[4] = 0;
+	buf[5] = 0;
+	buf[6] = 1;
+
+	ret = avl6211_i2c_write(state, buf, 7);
+	if (ret)
+		goto err;
+
+	x1 |= (1<<2);  /* Start fifo transmit */
+	ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+	if (ret)
+		goto err;
+	
+	state->diseqc_status = DISEQC_STATUS_TONE;
+	
+	do 
+	{
+		msleep(1);
+		if (++tx_cnt > 500) {
+			ret = -ETIME;
+			goto err;
+		}
+		ret = avl6211_i2c_read32(state, diseqc_tx_st_addr, &x1);
+		if (ret)
+			goto err;
+	} while ( 1 != ((x1 & 0x00000040) >> 6) );
+
+	msleep(20);
+	
+	if (Continuousflag == 1)			//resume to send out wave
+	{
+		//No data in FIFO
+		ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+		if (ret)
+			goto err;
+		x1 &= 0xfffffff8; 
+		x1 |= 0x03;		//switch to continuous mode
+		ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+		if (ret)
+			goto err;
+
+		//start to send out wave
+		x1 |= (1<<10);  
+		ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+		if (ret)
+			goto err;
+		
+		state->diseqc_status = DISEQC_STATUS_CONTINUOUS;
+			
+	}	
+	do {
+		ret = avl6211_diseqc_get_tx_status(fe, &tx_status);
+		if ( tx_status.tx_done == 1 )
+			break;
+
+		msleep(10);
+		cnt--;
+		if (!cnt) {
+			ret = -ETIME;
+			goto err;
+		}
+	} while (tx_status.tx_done != 1);
+	
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int avl6211_set_tone(struct dvb_frontend* fe, enum fe_sec_tone_mode tone)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u32 x1;
+
+	if (tone == SEC_TONE_ON) {
+		
+		ret = avl6211_diseqc_switch_mode(fe);
+		if (ret)
+			goto err;
+
+		ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+		if (ret)
+			goto err;
+		x1 &= 0xfffffff8;
+		x1 |= 0x03;	
+		ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+		if (ret)
+			goto err;
+		x1 |= (1 << 10);
+		ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+		if (ret)
+			goto err;
+			
+		state->diseqc_status = DISEQC_STATUS_CONTINUOUS;
+	} else {
+	
+		if (state->diseqc_status == DISEQC_STATUS_CONTINUOUS) {
+			ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+			if (ret)
+				goto err;
+			x1 &= 0xfffff3ff;
+			ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+			if (ret)
+				goto err;
+		}
+	}
+	
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int avl6211_set_voltage(struct dvb_frontend *fe,
+	enum fe_sec_voltage voltage)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u32 x1;
+	
+	if (voltage == SEC_VOLTAGE_OFF) {
+	
+		if (state->config->set_external_vol_gpio)
+			state->config->set_external_vol_gpio(&state->demod_id, 0);
+		
+		state->gpio_on = false;
+		
+		return 0;
+	}
+	if (voltage == SEC_VOLTAGE_13) {
+		if (state->config->use_lnb_pin59) {
+			ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+			if (ret)
+				goto err;
+			x1 &= 0xfffffdff;		
+			ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+			if (ret)
+				goto err;
+			msleep(20);	//delay 20ms
+		}
+		
+		if (state->config->use_lnb_pin60) {
+					
+			ret = avl6211_i2c_read32(state, gpio_reg_enb, &x1);
+			if (ret)
+				goto err;
+			x1 &= ~(1<<1);
+			ret = avl6211_i2c_write32(state, gpio_reg_enb, x1);  
+			if (ret)
+				goto err;
+			ret = avl6211_i2c_read32(state, gpio_data_reg_out, &x1);	
+			if (ret)
+				goto err;
+			x1 &= ~(1<<1) ;			
+			ret = avl6211_i2c_write32(state, gpio_data_reg_out, x1);
+			if (ret)
+				goto err;
+			msleep(20);
+
+		}						
+	} else if (voltage == SEC_VOLTAGE_18) {
+	
+		if (state->config->use_lnb_pin59) {
+			ret = avl6211_i2c_read32(state, diseqc_tx_cntrl_addr, &x1);
+			if (ret)
+				goto err;
+			x1 &= 0xfffffdff;
+			x1 |= 0x200;
+			ret = avl6211_i2c_write32(state, diseqc_tx_cntrl_addr, x1);
+			if (ret)
+				goto err;
+			msleep(20);	//delay 20ms
+		}
+		if (state->config->use_lnb_pin60) {
+			ret = avl6211_i2c_read32(state, gpio_reg_enb, &x1);
+			if (ret)
+				goto err;
+			x1 &= ~(1<<1);
+			ret = avl6211_i2c_write32(state, gpio_reg_enb, x1);  
+			if (ret)
+				goto err;
+			ret = avl6211_i2c_read32(state, gpio_data_reg_out, &x1);	
+			if (ret)
+				goto err;
+			x1 |= 1<<1 ;			
+			ret = avl6211_i2c_write32(state, gpio_data_reg_out, x1);
+			if (ret)
+				goto err;
+			msleep(20);
+		}		
+	}
+	
+	if (!state->gpio_on) {	
+		state->gpio_on = true;		
+		if (state->config->set_external_vol_gpio) 
+			state->config->set_external_vol_gpio(&state->demod_id, 1);
+	}
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_read_ber(struct dvb_frontend* fe, u32* ber)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u32 r_ber;
+
+	*ber = 0;
+	
+	if (state->locked == 1) {		
+		ret = avl6211_i2c_read32(state, rp_uint_BER_addr, &r_ber);
+		if (ret)
+			goto err;
+			
+		if (r_ber > 0)			
+			*ber = r_ber / 1000000000;			
+	}
+	
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+u8 DVBS_SNR[6] = { 12, 32, 41, 52, 58, 62 };
+u8 DVBS2Qpsk_SNR[8] = { 10, 24, 32, 41, 47, 52, 63, 65 };
+u8 DVBS28psk_SNR[6] = { 57, 67, 80, 95, 100, 110 };
+static int avl6211_read_snr(struct dvb_frontend* fe, u16 *snr)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u8 SNRrefer = 0;
+	u32 r_snr, code_rate, modulation;
+
+	*snr = 0;
+	
+	if (state->locked == 1) {
+		ret = avl6211_i2c_read32(state, rs_int_SNR_dB_addr, &r_snr);
+		if (ret)
+			goto err;
+		if (r_snr < 10000) {
+			ret = avl6211_i2c_read32(state, rs_code_rate_addr, &code_rate);
+			if (ret)
+				goto err;
+			ret = avl6211_i2c_read32(state, rs_modulation_addr, &modulation);
+			if (ret)
+				goto err;
+				
+			if (code_rate < 6)
+				SNRrefer = DVBS_SNR[code_rate];			
+			else {
+				if (modulation == 1)
+					SNRrefer = DVBS28psk_SNR[code_rate - 10];
+				else	
+					SNRrefer = DVBS2Qpsk_SNR[code_rate - 9];
+			}	
+			if ((r_snr / 10) > SNRrefer) {
+				r_snr = r_snr/10 - SNRrefer;
+				if (r_snr >= 100)
+					*snr = 99;
+				else if (r_snr >= 50)  //  >5.0dB
+					*snr = 80+ (r_snr - 50)*20/50;
+				else if (r_snr >= 25)  //  > 2.5dB
+					*snr = 50+ (r_snr - 25)*30/25;
+				else if (r_snr >= 10)  //  > 1dB
+					*snr = 25+ (r_snr - 10)*25/15;			
+				else 
+					*snr = 5 + (r_snr)*20/10;
+					
+				*snr = (*snr * 65535) / 100;
+			}
+		}
+	}
+	
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+struct Signal_Level
+{
+	u16 SignalLevel;
+	short SignalDBM;
+};
+struct Signal_Level  AGC_LUT [91]=
+{
+    {63688,  0},{62626, -1},{61840, -2},{61175, -3},{60626, -4},{60120, -5},{59647, -6},{59187, -7},{58741, -8},{58293, -9},
+    {57822,-10},{57387,-11},{56913,-12},{56491,-13},{55755,-14},{55266,-15},{54765,-16},{54221,-17},{53710,-18},{53244,-19},
+    {52625,-20},{52043,-21},{51468,-22},{50904,-23},{50331,-24},{49772,-25},{49260,-26},{48730,-27},{48285,-28},{47804,-29},
+    {47333,-30},{46880,-31},{46460,-32},{46000,-33},{45539,-34},{45066,-35},{44621,-36},{44107,-37},{43611,-38},{43082,-39},
+    {42512,-40},{41947,-41},{41284,-42},{40531,-43},{39813,-44},{38978,-45},{38153,-46},{37294,-47},{36498,-48},{35714,-49},
+    {35010,-50},{34432,-51},{33814,-52},{33315,-53},{32989,-54},{32504,-55},{32039,-56},{31608,-57},{31141,-58},{30675,-59},
+    {30215,-60},{29711,-61},{29218,-62},{28688,-63},{28183,-64},{27593,-65},{26978,-66},{26344,-67},{25680,-68},{24988,-69},
+    {24121,-70},{23285,-71},{22460,-72},{21496,-73},{20495,-74},{19320,-75},{18132,-76},{16926,-77},{15564,-78},{14398,-79},
+    {12875,-80},{11913,-81},{10514,-82},{ 9070,-83},{ 7588,-84},{ 6044,-85},{ 4613,-86},{ 3177,-87},{ 1614,-88},{  123,-89},
+    {    0,-90}
+};
+static int avl6211_read_signal_strength(struct dvb_frontend* fe, u16* signal_strength)
+{
+	#define Level_High_Stage	36
+	#define Level_Low_Stage		76
+
+	#define Percent_Space_High	10
+	#define Percent_Space_Mid	30
+	#define Percent_Space_Low	60
+	
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u32 rf;
+	u16 Level;
+	int i = 0;
+	int Percent = 0;
+	*signal_strength = 0;
+		
+	if (state->locked == 1) {
+		ret = avl6211_i2c_read32(state, rx_aagc_gain, &rf);
+		if (ret)
+			goto err;
+		
+		rf += 0x800000;
+		rf &= 0xffffff;	
+		Level = (u16)(rf >> 8);
+
+	while( Level < AGC_LUT[i++].SignalLevel);
+	
+	if (i <= Level_High_Stage)
+		Percent = Percent_Space_Low+Percent_Space_Mid+ (Level_High_Stage-i)*Percent_Space_High/Level_High_Stage;
+	else if(i<=Level_Low_Stage)
+		Percent = Percent_Space_Low+ (Level_Low_Stage-i)*Percent_Space_Mid/(Level_Low_Stage-Level_High_Stage);
+	else
+		Percent =(90-i)*Percent_Space_Low/(90-Level_Low_Stage);
+
+	*signal_strength = (Percent * 65535) / 100;	
+	}
+	
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_read_status(struct dvb_frontend* fe, enum fe_status* status)
+{
+	struct avl6211_state *state = fe->demodulator_priv;	
+	int ret;
+	*status = 0;
+	
+	ret = avl6211_i2c_read16(state, rs_fec_lock_addr, &state->locked);
+	if (ret)
+		goto err;
+
+	if (state->locked == 1) 
+		*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER | 
+				FE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;
+		
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)
+{
+	*ucblocks = 0;
+	return 0;
+}
+static int avl6211_get_frontend(struct dvb_frontend* fe)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	u32 code_rate;
+	u16 ret;
+		
+	if (!state->locked)
+		return 0;
+	
+	ret = avl6211_i2c_read32(state, rs_code_rate_addr, &code_rate);
+	if (ret)
+		goto err;
+		
+	p->frequency = state->frequency;
+	p->inversion = INVERSION_AUTO;
+	p->symbol_rate = state->symbol_rate;
+	
+	switch (code_rate) { 
+		case 0:
+		p->fec_inner = FEC_1_2;
+		break;
+		case 1:
+		p->fec_inner = FEC_2_3;
+		break;
+		case 2:
+		p->fec_inner = FEC_3_4;
+		break;
+		case 13:
+		p->fec_inner = FEC_4_5;
+		break;
+		case 14:
+		p->fec_inner = FEC_5_6;
+		break;
+		case 4:
+		p->fec_inner = FEC_6_7;
+		break;
+		case 5:
+		p->fec_inner = FEC_7_8;
+		break;
+		case 15:
+		p->fec_inner = FEC_8_9;
+		break;
+		case 10:
+		p->fec_inner = FEC_3_5;
+		break;
+		case 16:
+		p->fec_inner = FEC_9_10;
+		break;
+		default:
+		p->fec_inner = FEC_AUTO;
+		break;
+	}
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_channel_lock(struct dvb_frontend* fe)
+{
+    struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u32 IQ;
+	u32 autoIQ_Detect;
+	u16 Standard;
+	u16 auto_manual_lock;
+	int cnt = 0;
+
+	ret = avl6211_i2c_write16(state, rc_lock_mode_addr, 0);	
+	if (ret)
+		goto err;
+		
+	IQ = ((state->flags) & CI_FLAG_IQ_BIT_MASK) >> CI_FLAG_IQ_BIT;
+	ret = avl6211_i2c_write32(state, rc_specinv_addr, IQ);
+	if (ret)
+		goto err;
+	
+	Standard = (u16)(((state->flags) & CI_FLAG_DVBS2_BIT_MASK) >> CI_FLAG_DVBS2_BIT);
+	autoIQ_Detect = (((state->flags) & CI_FLAG_IQ_AUTO_BIT_MASK) >> CI_FLAG_IQ_AUTO_BIT);
+	auto_manual_lock = (u16)(((state->flags) & CI_FLAG_MANUAL_LOCK_MODE_BIT_MASK) >> CI_FLAG_MANUAL_LOCK_MODE_BIT);
+
+	
+	if((Standard == CI_FLAG_DVBS2_UNDEF) || (autoIQ_Detect == 1))
+		Standard = 0x14;
+
+	if (state->symbol_rate == 0)
+		state->symbol_rate = 1;
+	
+	ret = avl6211_i2c_write16(state, rc_fec_bypass_coderate_addr, auto_manual_lock);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write16(state, rc_decode_mode_addr, Standard);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write16(state, rc_iq_mode_addr, (u16)autoIQ_Detect);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, rc_int_sym_rate_MHz_addr, state->symbol_rate);
+	if (ret)
+		goto err;
+	
+	
+	ret = avl6211_send_op(OP_RX_INIT_GO, state);
+	if (ret)
+		goto err;
+		
+	do {
+		ret = avl6211_get_op_status(state);
+		if(!ret)
+			break;
+		msleep(1);
+	} while(cnt++ < 200);
+	
+	if (ret)
+		goto err;
+		
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_set_frontend(struct dvb_frontend* fe)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	int ret;
+	u16 cnt;
+	u32 max_time;
+	
+	
+	state->frequency = c->frequency;
+	state->symbol_rate = c->symbol_rate;
+	
+	state->locked = 0;
+
+	dev_dbg(&state->i2c->dev, 
+		"%s: delivery_system=%d frequency=%d symbol_rate=%d\n", 
+		__func__, c->delivery_system, c->frequency, c->symbol_rate);
+
+	state->tuner_lpf = (state->symbol_rate / 100000);
+	if (state->tuner_lpf > 440)
+		state->tuner_lpf = 440;
+
+	ret = av2011_lock(fe);
+	if (ret)
+		goto err;
+
+	/* Wait for tuner locking */
+	max_time = 150;  /* Max waiting time: 150ms */
+
+	cnt = max_time / 10;
+	do {	
+		ret = av2011_tuner_lock_status(fe);		
+
+		if (!ret)
+			break;
+		else {		
+			msleep(10);    /* Wait 10ms for demod to lock the channel */			
+			continue;
+		}		
+		
+	} while (--cnt);
+
+	if (!cnt) {
+		ret = -EAGAIN;
+		goto err;
+	}
+	
+	dev_dbg(&state->i2c->dev, "Tuner successfully lock!\n");
+
+	state->flags = (CI_FLAG_IQ_NO_SWAPPED) << CI_FLAG_IQ_BIT;			//Normal IQ
+	state->flags |= (CI_FLAG_IQ_AUTO_BIT_AUTO) << CI_FLAG_IQ_AUTO_BIT;	//Enable automatic IQ swap detection
+	state->flags |= (CI_FLAG_DVBS2_UNDEF) << CI_FLAG_DVBS2_BIT;			//Enable automatic standard detection
+
+	//This function should be called after tuner locked to lock the channel.
+	ret = avl6211_channel_lock(fe);
+	if (ret)
+		goto err;
+		
+	/* Wait a bit more when we have slow symbol rates */
+	if (c->symbol_rate < 5000000)
+		max_time = 5000*2; /* Max waiting time: 1000ms */
+	else if (c->symbol_rate < 10000000)
+		max_time = 600*2;  /* Max waiting time: 600ms */
+	else
+		max_time = 250*2;  /* Max waiting time: 250ms */
+
+	cnt = max_time / 10;
+	do {
+		ret = avl6211_i2c_read16(state, rs_fec_lock_addr, &state->locked);
+
+		if (!ret && state->locked == 1)
+				break;
+
+		msleep(10);    /* Wait 10ms for demod to lock the channel */		
+	} while (--cnt);
+	
+	if (!cnt) {
+		ret = -EAGAIN;
+		goto err;
+	}
+	dev_dbg(&state->i2c->dev, "Service locked!!!\n");
+
+	ret = avl6211_send_op(OP_RX_RESET_BERPER, state);
+	if (ret)
+		goto err;
+	
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+	
+}
+
+static int avl6211_get_demod_status(struct dvb_frontend* fe)
+{
+	struct avl6211_state *state = fe->demodulator_priv;
+	int ret;
+	u8	buf[2]; 
+	u32 x1 = 0;
+	
+	ret = avl6211_i2c_read32(state, core_reset_b_reg, &x1);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_read16(state, core_ready_word_addr, (u16 *)buf);	
+	if (ret)
+		goto err;
+	
+	if ((x1 == 0) || (buf[0] != 0x5a) || (buf[1] != 0xa5)) {
+		ret = -EINVAL;
+		goto err;
+	}
+	
+	return 0;
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int avl6211_setup_pll(struct avl6211_state* state, const struct avl6211_pllconf * pll_ptr)
+{
+	int ret;
+	
+	ret = avl6211_i2c_write32(state, pll_clkf_map_addr, pll_ptr->m_uiClkf);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, pll_bwadj_map_addr, pll_ptr->m_uiClkf);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, pll_clkr_map_addr, pll_ptr->m_uiClkr);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, pll_od_map_addr, pll_ptr->m_uiPllod);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, pll_od2_map_addr, pll_ptr->m_uiPllod2);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, pll_od3_map_addr, pll_ptr->m_uiPllod3);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, pll_softvalue_en_map_addr, 1);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, reset_register_addr, 0);
+	if (ret)
+		goto err;
+	
+	/* Reset do not check for error */
+	avl6211_i2c_write32(state, reset_register_addr, 1);
+	
+	state->demod_freq = pll_ptr->demod_freq;
+	state->fec_freq = pll_ptr->fec_freq;
+	state->mpeg_freq = pll_ptr->mpeg_freq;
+
+	return 0;
+	
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static int avl6211_load_firmware(struct dvb_frontend* fe)
+{
+	struct avl6211_state* state = fe->demodulator_priv;
+	const struct firmware *fw = NULL;
+	u8 *buffer = NULL;
+	u32 buf_size, data_size;
+	u32 i = 4;
+	int ret;
+	
+	ret = avl6211_i2c_write32(state, core_reset_b_reg, 0);
+	if (ret)
+		goto err;
+
+	dev_dbg(&state->i2c->dev, "Uploading demod firmware (%s)...\n", AVL6211_DEMOD_FW);
+	ret = request_firmware(&fw, AVL6211_DEMOD_FW, &state->i2c->dev);
+	if (ret) {
+		dev_dbg(&state->i2c->dev, "Firmware upload failed. Timeout or file not found\n");
+		goto err;
+	}    
+
+	buffer = kmalloc(fw->size , GFP_KERNEL);
+	if (!buffer) {
+		release_firmware(fw);
+		fw = NULL;
+		dev_dbg(&state->i2c->dev, "Failed to allocate tmp memory for firmware\n");
+		return -ENOMEM;
+	}
+	memcpy(buffer, fw->data, fw->size);
+	
+	release_firmware(fw);
+	fw = NULL;
+	
+	data_size = extract_32(buffer);
+	while (i < data_size)
+	{
+		buf_size = extract_32(buffer + i);
+		i += 4;
+		ret = avl6211_i2c_write(state, buffer + i + 1, (u16)(buf_size + 3));
+		if (ret)
+			goto err;
+			
+		i += 4 + buf_size;
+	}
+	
+	ret = avl6211_i2c_write32(state, 0x00000000, 0x00003ffc);
+	if (ret)
+			goto err;
+	ret = avl6211_i2c_write16(state, core_ready_word_addr, 0x0000);
+	if (ret)
+			goto err;
+	ret = avl6211_i2c_write32(state, error_msg_addr, 0x00000000);
+	if (ret)
+			goto err;
+	ret = avl6211_i2c_write32(state, error_msg_addr + 4, 0x00000000);
+	if (ret)
+			goto err;
+
+	/* Reset do not check for error */
+	avl6211_i2c_write32(state, core_reset_b_reg, 1);
+	
+	kfree(buffer);
+	return 0;
+	
+err:
+	kfree(buffer);
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+
+static int avl6211_init(struct dvb_frontend* fe)
+{
+	struct avl6211_state* state = fe->demodulator_priv;
+	int ret;
+
+	if (state->boot)
+		return 0;
+		
+	ret = avl6211_setup_pll(state, (const struct avl6211_pllconf * )(pll_conf + state->config->demod_refclk));
+	if (ret)
+		goto err;
+		
+	msleep(100);
+	
+	ret = avl6211_load_firmware(fe);
+	if (ret)
+		goto err;
+		
+	msleep(100);
+	
+	ret = avl6211_get_demod_status(fe);
+	if (ret)
+		goto err;
+	
+	
+	ret = avl6211_i2c_write32(state, 0x263E, 50000);
+	if (ret)
+		goto err;
+	/* Set clk to match the PLL */
+	ret = avl6211_i2c_write16(state, rc_int_dmd_clk_MHz_addr,  state->demod_freq);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write16(state, rc_int_fec_clk_MHz_addr, state->fec_freq);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write16(state, rc_int_mpeg_clk_MHz_addr, state->mpeg_freq);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, rc_format_addr, 1);
+	if (ret)
+		goto err;
+	
+	/* Set AGC polarization */
+	ret = avl6211_i2c_write32(state, rc_rfagc_pol_addr, (u32)state->config->tuner_rfagc);
+	if (ret)
+		goto err;	
+	/* Drive RF AGC */
+	ret = avl6211_i2c_write16(state, rc_aagc_ref_addr, 0x30);
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write32(state, rc_rfagc_tri_enb, 1);
+	if (ret)
+		goto err;
+
+	ret = avl6211_i2c_write16(state, rc_blind_scan_tuner_spectrum_inversion_addr, (u16)state->config->tuner_spectrum);
+	if (ret)
+		goto err;
+	
+	ret = avl6211_i2c_write32(state, rc_mpeg_mode_addr, (u32)(state->config->mpeg_format));
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write16(state, rc_mpeg_serial_addr, (u16)(state->config->mpeg_mode));
+	if (ret)
+		goto err;
+	ret = avl6211_i2c_write16(state, rc_mpeg_posedge_addr, (u16)(state->config->mpeg_pol));
+	if (ret)
+		goto err;
+	
+	if (state->config->mpeg_mode) {
+		ret = avl6211_i2c_write32(state, rc_outpin_sel_addr, (u32)(state->config->mpeg_pin));		
+		if (ret)
+			goto err;
+	}
+	
+	ret = avl6211_i2c_write32(state, rc_mpeg_bus_tri_enb, 1);
+	if (ret)
+		goto err;
+	
+	ret = av2011_tuner_init(fe);
+	if (ret)
+		goto err;
+	ret = avl6211_diseqc_init(fe);
+	if (ret)
+		goto err;
+	
+	ret = avl6211_i2c_write32(state,  gpio_data_reg_out, 0);
+	if (ret)
+		goto err;
+	
+	ret = avl6211_i2c_write32(state, gpio_reg_enb, 0);
+	if (ret)
+		goto err;
+	
+	state->boot = true;
+	
+	dev_dbg(&state->i2c->dev, "AVL6211+AV2011 init OK\n");
+	
+	return 0;
+
+err:
+	dev_dbg(&state->i2c->dev, "%s: failed=%d\n", __func__, ret);
+	return ret;
+}
+static void avl6211_release(struct dvb_frontend* fe)
+{
+	struct avl6211_state* state = fe->demodulator_priv;
+	kfree(state);
+}
+
+static struct dvb_frontend_ops avl6211_ops = {
+	.delsys = { SYS_DVBS, SYS_DVBS2 }, 
+	.info = {
+		.name = "Availink AVL6211+AV2011 DVB-S/S2",	
+		.frequency_min = 950000,
+		.frequency_max = 2150000,
+		.frequency_stepsize = 0,		
+		.frequency_tolerance = 0,
+		.symbol_rate_min = 800000,		/* Min = 800K */
+		.symbol_rate_max = 50000000,	/* Max = 50M */
+		.caps = FE_CAN_INVERSION_AUTO |
+			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_4_5 | FE_CAN_FEC_5_6 | FE_CAN_FEC_6_7 |
+			FE_CAN_FEC_7_8 | FE_CAN_FEC_8_9 | FE_CAN_FEC_AUTO |
+			FE_CAN_QPSK    | FE_CAN_RECOVER | FE_CAN_2G_MODULATION			
+	},
+
+	.init = avl6211_init,
+	.release = avl6211_release,
+	.read_status = avl6211_read_status,
+	.read_ber = avl6211_read_ber,
+	.read_signal_strength = avl6211_read_signal_strength,
+	.read_snr = avl6211_read_snr,
+	.read_ucblocks = avl6211_read_ucblocks,
+	.set_tone = avl6211_set_tone,	
+	.set_voltage = avl6211_set_voltage,
+	.diseqc_send_master_cmd = avl6211_send_diseqc_msg,
+	.diseqc_send_burst = avl6211_diseqc_send_burst,
+	.set_frontend = avl6211_set_frontend,
+	.get_frontend = avl6211_get_frontend,
+};
+
+struct dvb_frontend* avl6211_attach(struct avl6211_config* config, struct i2c_adapter* i2c)
+{
+	struct avl6211_state* state = NULL;
+	int ret;
+	u32 ChipID = 0;
+	
+	state = kzalloc(sizeof(struct avl6211_state), GFP_KERNEL);
+	if (!state) {
+		ret = -ENOMEM;
+		dev_err(&i2c->dev, "kzalloc() failed\n");
+		goto err1;
+	}
+
+	state->config = config;
+	state->i2c = i2c;	
+	state->demod_id = 0;
+	
+	ret = avl6211_i2c_read32(state, rs_cust_chip_id_addr, &ChipID);
+	if (ret || ChipID != 0x0000000F)
+		goto err2;
+
+	dev_info(&i2c->dev, "AVL6211+AV2011 DVB-S/S2 successfully attached\n");	
+	
+	memcpy(&state->frontend.ops, &avl6211_ops, sizeof(struct dvb_frontend_ops));
+	state->frontend.demodulator_priv = state;
+
+	return &state->frontend;
+	
+err2:	
+	kfree(state);
+err1:	
+	dev_dbg(&i2c->dev, "%s: failed=%d\n", __func__, ret);	
+	return NULL;
+}
+
+EXPORT_SYMBOL(avl6211_attach);
+
+MODULE_DESCRIPTION("Availink AVL6211+AV2011 demod+tuner driver");
+MODULE_AUTHOR("Sasa Savic <sasa.savic.sr@gmail.com>");
+MODULE_LICENSE("GPL");
diff -Nur linux-95ba9d626c0fce672caa296f5911ab9190881642/drivers/amlogic/dvb-avl/avl6211.h linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/drivers/amlogic/dvb-avl/avl6211.h
--- linux-95ba9d626c0fce672caa296f5911ab9190881642/drivers/amlogic/dvb-avl/avl6211.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/drivers/amlogic/dvb-avl/avl6211.h	2019-02-11 22:25:03.000000000 +0100
@@ -0,0 +1,155 @@
+/*
+ * Driver for the Availink AVL6211+AV2011 DVB-S/S2 demod+tuner
+ *
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+ 
+#ifndef __AVL6211_H_
+#define __AVL6211_H_
+
+#include <linux/types.h>
+#include <linux/i2c.h>
+
+
+#define AVL6211_DEMOD_FW 		"dvb-fe-avl6211.fw" 
+
+#define I2C_MAX_READ	64
+#define I2C_MAX_WRITE	64
+
+
+#define CI_FLAG_IQ_BIT							0x00000000
+#define CI_FLAG_IQ_BIT_MASK						0x00000001
+#define CI_FLAG_IQ_NO_SWAPPED					0x00000000
+#define CI_FLAG_IQ_SWAPPED						0x00000001
+#define CI_FLAG_IQ_AUTO_BIT_MASK				0x00000020  
+
+
+#define CI_FLAG_IQ_AUTO_BIT						0x00000005
+#define CI_FLAG_IQ_AUTO_BIT_AUTO				0x00000001
+
+#define CI_FLAG_DVBS2_BIT						0x00000002
+#define CI_FLAG_DVBS2_UNDEF						0x00000004
+#define CI_FLAG_DVBS2_BIT_MASK					0x0000001c
+
+#define CI_FLAG_MANUAL_LOCK_MODE_BIT			0x00000001
+#define CI_FLAG_MANUAL_LOCK_MODE_BIT_MASK		0x00000002
+#define CI_FLAG_LOCK_MODE_BIT_MASK				0x00000040
+
+
+#define ENABLE_FAST_REACQ           0x01
+#define DISABLE_FAST_REACQ          0x00
+#define ENABLE_CCI                  0x03
+#define DISABLE_CCI                 0x02
+#define MAX_LOWIF_SR                5000000
+#define IF_OFFSET                   500
+
+
+/* Demod commands */
+#define OP_RX_NOOP                  0x00
+#define OP_RX_LD_DEFAULT            0x01
+#define OP_RX_INIT_GO               0x02
+#define OP_RX_RESET_BERPER          0x03
+#define OP_RX_HALT                  0x04
+#define OP_RX_SLEEP                 0x05
+#define OP_RX_WAKE                  0x06
+#define OP_RX_BLIND_SCAN            0x08
+#define OP_RX_STDOUT_MODE           0x09
+	
+/* Diseqc status */
+#define DISEQC_STATUS_UNINIT				0x00
+#define DISEQC_STATUS_INIT					0x01
+#define DISEQC_STATUS_CONTINUOUS			0x02
+#define DISEQC_STATUS_TONE					0x03
+#define DISEQC_STATUS_MOD					0x04
+
+#define I2CM_CMD_LENGTH   0x14
+#define I2CM_RSP_LENGTH   0x14
+
+#define OP_I2CM_NOOP      0x00
+#define OP_I2CM_INIT	  0x01
+#define OP_I2CM_WRITE     0x02
+#define OP_I2CM_READ      0x03
+
+	
+
+#define format_addr(X, Y)		\
+	do {						\
+		Y[0] =(u8)((X) >> 16);	\
+		Y[1] =(u8)((X) >> 8);	\
+		Y[2] =(u8)(X);			\
+	} while (0)
+
+
+#define format_16(X, Y)			\
+	do {						\
+		Y[0] =(u8)((X) >> 8);	\
+		Y[1] =(u8)((X) & 0xFF);	\
+	} while (0)
+
+
+#define format_32(X, Y)			\
+	do {						\
+		Y[0] =(u8)((X) >> 24);	\
+		Y[1] =(u8)((X) >> 16);	\
+		Y[2] =(u8)((X) >> 8);	\
+		Y[3] =(u8)((X) & 0xFF);	\
+	} while (0)
+
+
+struct avl6211_pllconf
+{
+	u16 m_uiClkf; /* Feedback clock divider */
+	u16 m_uiClkr; /* Reference clock divider */
+	u16 m_uiPllod; /* PLL output divider */
+	u16 m_uiPllod2; /* PLL output divider 2 */
+	u16 m_uiPllod3; /* PLL output divider 3 */
+	u16 ref_freq; /* Reference clock in kHz */
+	u16 demod_freq; /* Demod clock in 10kHz */
+	u16 fec_freq; /* FEC clock in 10kHz */
+	u16 mpeg_freq; /* MPEG clock in 10kHz */
+};
+
+struct avl6211_config
+{
+	u8 tuner_address; /* Tuner i2c address */
+	u16 tuner_i2c_clock;	
+	u8 demod_address;	/* The demodulator's i2c address  0x0C */ 
+				
+	u8 mpeg_pol; /* 0 - Falling, 1 - Rising */
+	u8 mpeg_mode; /* 0 - Parallel, 1 - Serial */
+	u8 mpeg_format; /* 0 - Default TS stream, 1 - TS stream plus parity format */
+	
+	u8 demod_refclk; /* Reference clock frequency selection */
+
+	/* Serial data is output on pin */
+	u8 mpeg_pin; /* 0 -  MPEG_DATA_0, 1 - MPEG_DATA_7 */
+	
+	u8 tuner_rfagc; /* 0 - Normal pol, 1 - Inverted pol */
+	u8 tuner_spectrum; /* 0 - signal spectrum normal, 1 - signal spectrum inverted */
+	
+	u8 use_lnb_pin59; /* control 13/18V over demod GPIO pin59 */
+	u8 use_lnb_pin60; /* control 13/18V over demod GPIO pin60 */
+
+	int (*set_external_vol_gpio)(int *demod_id, int on); /* external 13/18V control */
+};
+
+
+
+//extern struct dvb_frontend* avl6211_attach(struct i2c_adapter* i2c, struct avl6211_config* config, int id);
+extern struct dvb_frontend* avl6211_attach(struct avl6211_config* config, struct i2c_adapter* i2c);
+
+#endif
diff -Nur linux-95ba9d626c0fce672caa296f5911ab9190881642/drivers/amlogic/dvb-avl/avl6211_reg.h linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/drivers/amlogic/dvb-avl/avl6211_reg.h
--- linux-95ba9d626c0fce672caa296f5911ab9190881642/drivers/amlogic/dvb-avl/avl6211_reg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/drivers/amlogic/dvb-avl/avl6211_reg.h	2019-02-11 22:25:03.000000000 +0100
@@ -0,0 +1,101 @@
+/*
+ * Driver for the Availink AVL6211+AV2011 DVB-S/S2 demod+tuner
+ *
+ * Copyright (C) 2014 Sasa Savic <sasa.savic.sr@gmail.com>
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2 of the License, or
+ *    (at your option) any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License along
+ *    with this program; if not, write to the Free Software Foundation, Inc.,
+ *    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+ 
+#ifndef __AVL6211_REG_H_
+#define __AVL6211_REG_H_
+
+
+#define core_reset_b_reg            				0x600000
+#define gpio_data_in_to_reg         				0x6C0004
+#define gpio_data_reg_out           				0x6C0008
+#define gpio_reg_enb                				0x6C000C
+
+#define pll_clkr_map_addr           				0x6C40C0
+#define pll_clkf_map_addr          				0x6C4100
+#define pll_od_map_addr             				0x6C4080
+#define pll_od2_map_addr            				0x6C4140
+#define pll_od3_map_addr            				0x6C4180
+#define pll_bwadj_map_addr          				0x6C41C0
+#define pll_softvalue_en_map_addr   				0x6C4200
+#define reset_register_addr         				0x6C4000
+
+	
+#define rx_aagc_gain                                0x0040004C
+#define rc_rfagc_tri_enb                            0x006C002C
+#define rc_mpeg_bus_tri_enb                         0x006C0028
+
+
+#define raptor_status_addr                         (0x00000860 + 0x0)
+#define rx_state_addr                              (0x00000690 + 0x0)
+#define rx_cmd_addr                                (0x00000400 + 0x0)
+#define i2cm_cmd_addr                              (0x00000404 + 0x0)
+#define i2cm_rsp_addr                              (0x00000418 + 0x0)
+#define error_msg_addr                             (0x0000042c + 0x0)
+#define rx_config_addr                             (0x0000043c + 0x0)
+#define core_ready_word_addr                       (0x00000434 + 0x0)
+
+#define rs_cust_chip_id_addr                        0x006C0034
+
+#define	rp_uint_BER_addr                           (raptor_status_addr + 0x0)
+#define	rc_rfagc_pol_addr                          (rx_config_addr + 0x0)
+#define	rc_equalizer_addr                          (rx_config_addr + 0x8)
+#define	rs_code_rate_addr                          (rx_state_addr + 0x8)
+#define	rs_modulation_addr                         (rx_state_addr + 0xc)
+#define	rc_format_addr                             (rx_config_addr + 0x10)
+#define	rc_mpeg_mode_addr                          (rx_config_addr + 0x20)
+#define	rc_outpin_sel_addr                         (rx_config_addr + 0x24)
+#define	rs_int_SNR_dB_addr                         (rx_state_addr + 0x40)
+#define	rc_aagc_ref_addr                           (rx_config_addr + 0xaa)
+#define	rc_mpeg_posedge_addr                       (rx_config_addr + 0xbc)
+#define	rc_mpeg_serial_addr                        (rx_config_addr + 0xbe)
+#define	rs_fec_lock_addr                           (rx_state_addr + 0x164)
+#define	rc_specinv_addr                            (rx_config_addr + 0x34)
+#define	rc_int_sym_rate_MHz_addr                   (rx_config_addr + 0x54)
+#define	rc_dvbs_ber_addr                           (rx_config_addr + 0x98)
+#define	rc_int_dmd_clk_MHz_addr                    (rx_config_addr + 0x162)
+#define	rc_int_fec_clk_MHz_addr                    (rx_config_addr + 0x164)
+#define	rc_int_mpeg_clk_MHz_addr                   (rx_config_addr + 0x166)
+#define	rc_int_carrier_freq_half_range_MHz_addr    (rx_config_addr + 0x16c)
+#define	rc_fec_bypass_coderate_addr                (rx_config_addr + 0x194)
+#define	rc_i2cm_speed_kHz_addr                     (rx_config_addr + 0x1ae)
+#define	rc_tuner_slave_addr_addr                   (rx_config_addr + 0x1b6)
+#define	rc_tuner_max_LPF_100kHz_addr               (rx_config_addr + 0x1b8)
+#define	rc_tuner_LPF_margin_100kHz_addr            (rx_config_addr + 0x1ba)
+#define	rc_tuner_use_internal_control_addr         (rx_config_addr + 0x1bc)
+
+#define	rc_decode_mode_addr                        (rx_config_addr + 0x202)
+#define	rc_iq_mode_addr                            (rx_config_addr + 0x204)
+#define	rc_lock_mode_addr                          (rx_config_addr + 0x20a)
+#define	rc_blind_scan_tuner_spectrum_inversion_addr (rx_config_addr + 0x220)
+
+
+
+#define diseqc_tx_cntrl_addr						0x00700000
+#define diseqc_tone_frac_n_addr						0x00700004
+#define diseqc_tone_frac_d_addr						0x00700008
+#define diseqc_tx_st_addr						0x0070000c
+#define diseqc_rx_msg_tim_addr						0x00700014
+#define diseqc_rx_cntrl_addr						0x0070001c
+#define diseqc_srst_addr						0x00700020
+#define diseqc_samp_frac_n_addr						0x00700028
+#define diseqc_samp_frac_d_addr						0x0070002c
+#define diseqc_tx_fifo_map_addr						0x00700080
+
+#endif
diff -Nur linux-95ba9d626c0fce672caa296f5911ab9190881642/drivers/amlogic/dvb-avl/Kconfig linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/drivers/amlogic/dvb-avl/Kconfig
--- linux-95ba9d626c0fce672caa296f5911ab9190881642/drivers/amlogic/dvb-avl/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/drivers/amlogic/dvb-avl/Kconfig	2019-01-27 10:45:07.141809310 +0100
@@ -0,0 +1,20 @@
+#
+# AVL6211 dvb driver configuration
+#
+
+menu "AVL6211 DVB driver"
+
+config AVL6211
+	tristate "AVL6211 DVB driver"
+	default n
+	select DVB_CORE
+	help
+		Select to enable AVL6211 DVB driver.
+		
+config AM_DISABLE_DSC
+	bool "disable the descrambler"
+	default n
+	depends on AM_DVB
+	help
+		Select to disable descrambler driver
+endmenu
diff -Nur linux-95ba9d626c0fce672caa296f5911ab9190881642/drivers/amlogic/dvb-avl/Makefile linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/drivers/amlogic/dvb-avl/Makefile
--- linux-95ba9d626c0fce672caa296f5911ab9190881642/drivers/amlogic/dvb-avl/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/drivers/amlogic/dvb-avl/Makefile	2019-01-22 18:55:57.000000000 +0100
@@ -0,0 +1,10 @@
+
+#	AVL6862 DVB-Sx/Tx/C frontend driver
+
+obj-$(CONFIG_AVL6211) += aml.o
+
+aml-objs=aml_dvb.o aml_dmx.o aml_fe.o avl6211.o
+
+EXTRA_CFLAGS += -I.
+EXTRA_CFLAGS += -Idrivers/media/dvb-core -Idrivers/media/usb/dvb-usb -Idrivers/media/dvb-frontends -Idrivers/media/tuners
+
diff -Nur linux-95ba9d626c0fce672caa296f5911ab9190881642/drivers/amlogic/Kconfig linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/drivers/amlogic/Kconfig
--- linux-95ba9d626c0fce672caa296f5911ab9190881642/drivers/amlogic/Kconfig	2018-03-21 06:58:27.000000000 +0100
+++ linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/drivers/amlogic/Kconfig	2019-02-11 19:17:51.610984236 +0100
@@ -77,7 +77,7 @@
 source "drivers/amlogic/d2d3/Kconfig"
 source "drivers/amlogic/amvecm/Kconfig"
 source "drivers/amlogic/dvb_tv/Kconfig"
-
+source "drivers/amlogic/dvb-avl/Kconfig"
 #
 #	GPU
 #
diff -Nur linux-95ba9d626c0fce672caa296f5911ab9190881642/drivers/amlogic/Makefile linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/drivers/amlogic/Makefile
--- linux-95ba9d626c0fce672caa296f5911ab9190881642/drivers/amlogic/Makefile	2018-03-21 06:58:27.000000000 +0100
+++ linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/drivers/amlogic/Makefile	2019-02-11 19:28:03.409512426 +0100
@@ -85,6 +85,7 @@
 obj-y += hdmi/
 
 obj-$(CONFIG_AM_DVB) += dvb_tv/
+obj-$(CONFIG_AVL6211) += dvb-avl/
 obj-$(CONFIG_AM_SMARTCARD) += smartcard/
 
 obj-$(CONFIG_AM_WIFI) += wifi/
diff -Nur linux-95ba9d626c0fce672caa296f5911ab9190881642/include/linux/amlogic/amstream.h linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/include/linux/amlogic/amstream.h
--- linux-95ba9d626c0fce672caa296f5911ab9190881642/include/linux/amlogic/amstream.h	2018-03-21 06:58:27.000000000 +0100
+++ linux-95ba9d626c0fce672caa296f5911ab9190881642-avl/include/linux/amlogic/amstream.h	2019-01-21 17:05:51.091608672 +0100
@@ -255,6 +255,7 @@
         int (*set_vid)(int vpid);
         int (*set_aid)(int apid);
         int (*set_sid)(int spid);
+        int (*set_pcrid)(int pcrpid);
         int (*set_skipbyte)(int skipbyte);
         int (*set_demux)(int dev);
 };
